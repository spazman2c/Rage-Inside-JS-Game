import {
  ShaderCodeInliner
} from "./chunk-2UG34J2G.js";
import {
  CreateGround,
  DynamicTexture
} from "./chunk-MX7WAJUU.js";
import {
  PBRMaterial
} from "./chunk-DM5IV5M2.js";
import {
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  Color3,
  Color4,
  Constants,
  Effect,
  EffectFallbacks,
  HandleFallbacksForShadows,
  ImageProcessingConfiguration,
  MaterialDefines,
  MaterialFlags,
  Matrix,
  Plane,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMisc,
  PrepareUniformsAndSamplersList,
  PushMaterial,
  Quaternion,
  RegisterClass,
  RenderTargetTexture,
  Scene,
  SerializationHelper,
  ShaderStore,
  SmartArray,
  StandardMaterial,
  Tags,
  Texture,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  __decorate,
  addClipPlaneUniforms,
  bindClipPlane,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-5XB6PROF.js";
import "./chunk-SSYGV25P.js";

// node_modules/@babylonjs/materials/cell/cell.fragment.js
var name2 = "cellPixelShader";
var shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
vec3 computeCustomDiffuseLighting(lightingInfo info,vec3 diffuseBase,float shadow)
{diffuseBase=info.diffuse*shadow;
#ifdef CELLBASIC
float level=1.0;if (info.ndl<0.5)
level=0.5;diffuseBase.rgb*vec3(level,level,level);
#else
float ToonThresholds[4];ToonThresholds[0]=0.95;ToonThresholds[1]=0.5;ToonThresholds[2]=0.2;ToonThresholds[3]=0.03;float ToonBrightnessLevels[5];ToonBrightnessLevels[0]=1.0;ToonBrightnessLevels[1]=0.8;ToonBrightnessLevels[2]=0.6;ToonBrightnessLevels[3]=0.35;ToonBrightnessLevels[4]=0.2;if (info.ndl>ToonThresholds[0])
{diffuseBase.rgb*=ToonBrightnessLevels[0];}
else if (info.ndl>ToonThresholds[1])
{diffuseBase.rgb*=ToonBrightnessLevels[1];}
else if (info.ndl>ToonThresholds[2])
{diffuseBase.rgb*=ToonBrightnessLevels[2];}
else if (info.ndl>ToonThresholds[3])
{diffuseBase.rgb*=ToonBrightnessLevels[3];}
else
{diffuseBase.rgb*=ToonBrightnessLevels[4];}
#endif
return max(diffuseBase,vec3(0.2));}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV);
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef VERTEXCOLOR
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
lightingInfo info;vec3 diffuseBase=vec3(0.,0.,0.);float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif 
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name2] = shader;

// node_modules/@babylonjs/materials/cell/cell.vertex.js
var name3 = "cellVertexShader";
var shader2 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name3] = shader2;

// node_modules/@babylonjs/materials/cell/cellMaterial.js
var CellMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.NDOTL = true;
    this.CUSTOMUSERLIGHTING = true;
    this.CELLBASIC = true;
    this.DEPTHPREPASS = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var CellMaterial = class _CellMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this._computeHighLevel = false;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new CellMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
      }
    }
    defines.CELLBASIC = !this.computeHighLevel;
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "cell";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant"
      ];
      const samplers = ["diffuseSampler"];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights - 1 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this._diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this._diffuseTexture.getTextureMatrix());
      }
      bindClipPlane(this._activeEffect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    return this._diffuseTexture === texture;
  }
  dispose(forceDisposeEffect) {
    if (this._diffuseTexture) {
      this._diffuseTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  getClassName() {
    return "CellMaterial";
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _CellMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.CellMaterial";
    return serializationObject;
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _CellMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], CellMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], CellMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsColor3("diffuse")
], CellMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize("computeHighLevel")
], CellMaterial.prototype, "_computeHighLevel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], CellMaterial.prototype, "computeHighLevel", void 0);
__decorate([
  serialize("disableLighting")
], CellMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], CellMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], CellMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], CellMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.CellMaterial", CellMaterial);

// node_modules/@babylonjs/materials/custom/customMaterial.js
var CustomShaderStructure = class {
  constructor() {
  }
};
var ShaderSpecialParts = class {
  constructor() {
  }
};
var CustomMaterial = class _CustomMaterial extends StandardMaterial {
  /**
   * Runs after the material is bound to a mesh
   * @param mesh mesh bound
   * @param effect bound effect used to render
   */
  AttachAfterBind(mesh, effect) {
    if (this._newUniformInstances) {
      for (const el in this._newUniformInstances) {
        const ea = el.toString().split("-");
        if (ea[0] == "vec2") {
          effect.setVector2(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "vec3") {
          if (this._newUniformInstances[el] instanceof Color3) {
            effect.setColor3(ea[1], this._newUniformInstances[el]);
          } else {
            effect.setVector3(ea[1], this._newUniformInstances[el]);
          }
        } else if (ea[0] == "vec4") {
          if (this._newUniformInstances[el] instanceof Color4) {
            effect.setDirectColor4(ea[1], this._newUniformInstances[el]);
          } else {
            effect.setVector4(ea[1], this._newUniformInstances[el]);
          }
          effect.setVector4(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "mat4") {
          effect.setMatrix(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "float") {
          effect.setFloat(ea[1], this._newUniformInstances[el]);
        }
      }
    }
    if (this._newSamplerInstances) {
      for (const el in this._newSamplerInstances) {
        const ea = el.toString().split("-");
        if (ea[0] == "sampler2D" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {
          effect.setTexture(ea[1], this._newSamplerInstances[el]);
        }
      }
    }
  }
  /**
   * @internal
   */
  ReviewUniform(name30, arr) {
    if (name30 == "uniform" && this._newUniforms) {
      for (let ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") == -1) {
          arr.push(this._newUniforms[ind].replace(/\[\d*\]/g, ""));
        }
      }
    }
    if (name30 == "sampler" && this._newUniforms) {
      for (let ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") != -1) {
          arr.push(this._newUniforms[ind].replace(/\[\d*\]/g, ""));
        }
      }
    }
    return arr;
  }
  /**
   * Builds the material
   * @param shaderName name of the shader
   * @param uniforms list of uniforms
   * @param uniformBuffers list of uniform buffers
   * @param samplers list of samplers
   * @param defines list of defines
   * @param attributes list of attributes
   * @returns the shader name
   */
  Builder(shaderName, uniforms, uniformBuffers, samplers, defines, attributes) {
    if (attributes && this._customAttributes && this._customAttributes.length > 0) {
      attributes.push(...this._customAttributes);
    }
    this.ReviewUniform("uniform", uniforms);
    this.ReviewUniform("sampler", samplers);
    const name30 = this._createdShaderName;
    if (Effect.ShadersStore[name30 + "VertexShader"] && Effect.ShadersStore[name30 + "PixelShader"]) {
      return name30;
    }
    Effect.ShadersStore[name30 + "VertexShader"] = this._injectCustomCode(this.VertexShader, "vertex");
    Effect.ShadersStore[name30 + "PixelShader"] = this._injectCustomCode(this.FragmentShader, "fragment");
    return name30;
  }
  _injectCustomCode(code, shaderType) {
    const customCode = this._getCustomCode(shaderType);
    for (const point in customCode) {
      const injectedCode = customCode[point];
      if (injectedCode && injectedCode.length > 0) {
        const fullPointName = "#define " + point;
        code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
      }
    }
    return code;
  }
  _getCustomCode(shaderType) {
    var _a, _b;
    if (shaderType === "vertex") {
      return {
        CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,
        CUSTOM_VERTEX_DEFINITIONS: (((_a = this._customUniform) == null ? void 0 : _a.join("\n")) || "") + (this.CustomParts.Vertex_Definitions || ""),
        CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,
        CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,
        CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,
        CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,
        CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed
      };
    }
    return {
      CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,
      CUSTOM_FRAGMENT_DEFINITIONS: (((_b = this._customUniform) == null ? void 0 : _b.join("\n")) || "") + (this.CustomParts.Fragment_Definitions || ""),
      CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,
      CUSTOM_FRAGMENT_UPDATE_DIFFUSE: this.CustomParts.Fragment_Custom_Diffuse,
      CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,
      CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,
      CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,
      CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog
    };
  }
  constructor(name30, scene) {
    super(name30, scene);
    this.CustomParts = new ShaderSpecialParts();
    this.customShaderNameResolve = this.Builder;
    this.FragmentShader = Effect.ShadersStore["defaultPixelShader"];
    this.VertexShader = Effect.ShadersStore["defaultVertexShader"];
    _CustomMaterial.ShaderIndexer++;
    this._createdShaderName = "custom_" + _CustomMaterial.ShaderIndexer;
  }
  _afterBind(mesh, effect = null, subMesh) {
    if (!effect) {
      return;
    }
    this.AttachAfterBind(mesh, effect);
    try {
      super._afterBind(mesh, effect, subMesh);
    } catch (e) {
    }
  }
  /**
   * Adds a new uniform to the shader
   * @param name the name of the uniform to add
   * @param kind the type of the uniform to add
   * @param param the value of the uniform to add
   * @returns the current material
   */
  AddUniform(name30, kind, param) {
    if (!this._customUniform) {
      this._customUniform = new Array();
      this._newUniforms = new Array();
      this._newSamplerInstances = {};
      this._newUniformInstances = {};
    }
    if (param) {
      if (kind.indexOf("sampler") != -1) {
        this._newSamplerInstances[kind + "-" + name30] = param;
      } else {
        this._newUniformInstances[kind + "-" + name30] = param;
      }
    }
    this._customUniform.push("uniform " + kind + " " + name30 + ";");
    this._newUniforms.push(name30);
    return this;
  }
  /**
   * Adds a custom attribute
   * @param name the name of the attribute
   * @returns the current material
   */
  AddAttribute(name30) {
    if (!this._customAttributes) {
      this._customAttributes = [];
    }
    this._customAttributes.push(name30);
    return this;
  }
  /**
   * Sets the code on Fragment_Begin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Begin(shaderPart) {
    this.CustomParts.Fragment_Begin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Definitions portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Definitions(shaderPart) {
    this.CustomParts.Fragment_Definitions = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_MainBegin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_MainBegin(shaderPart) {
    this.CustomParts.Fragment_MainBegin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_MainEnd portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_MainEnd(shaderPart) {
    this.CustomParts.Fragment_MainEnd = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_Diffuse portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_Diffuse(shaderPart) {
    this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace("result", "diffuseColor");
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_Alpha portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_Alpha(shaderPart) {
    this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace("result", "alpha");
    return this;
  }
  /**
   * Sets the code on Fragment_Before_Lights portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_Lights(shaderPart) {
    this.CustomParts.Fragment_Before_Lights = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Before_Fog portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_Fog(shaderPart) {
    this.CustomParts.Fragment_Before_Fog = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Before_FragColor portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_FragColor(shaderPart) {
    this.CustomParts.Fragment_Before_FragColor = shaderPart.replace("result", "color");
    return this;
  }
  /**
   * Sets the code on Vertex_Begin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Begin(shaderPart) {
    this.CustomParts.Vertex_Begin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_Definitions portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Definitions(shaderPart) {
    this.CustomParts.Vertex_Definitions = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_MainBegin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_MainBegin(shaderPart) {
    this.CustomParts.Vertex_MainBegin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_Before_PositionUpdated portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Before_PositionUpdated(shaderPart) {
    this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace("result", "positionUpdated");
    return this;
  }
  /**
   * Sets the code on Vertex_Before_NormalUpdated portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Before_NormalUpdated(shaderPart) {
    this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace("result", "normalUpdated");
    return this;
  }
  /**
   * Sets the code on Vertex_After_WorldPosComputed portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_After_WorldPosComputed(shaderPart) {
    this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_MainEnd portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_MainEnd(shaderPart) {
    this.CustomParts.Vertex_MainEnd = shaderPart;
    return this;
  }
};
CustomMaterial.ShaderIndexer = 1;
RegisterClass("BABYLON.CustomMaterial", CustomMaterial);

// node_modules/@babylonjs/materials/custom/pbrCustomMaterial.js
var ShaderAlbedoParts = class {
  constructor() {
  }
};
var ShaderAlebdoParts = ShaderAlbedoParts;
var PBRCustomMaterial = class _PBRCustomMaterial extends PBRMaterial {
  /**
   * Runs after the material is bound to a mesh
   * @param mesh mesh bound
   * @param effect bound effect used to render
   */
  AttachAfterBind(mesh, effect) {
    if (this._newUniformInstances) {
      for (const el in this._newUniformInstances) {
        const ea = el.toString().split("-");
        if (ea[0] == "vec2") {
          effect.setVector2(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "vec3") {
          if (this._newUniformInstances[el] instanceof Color3) {
            effect.setColor3(ea[1], this._newUniformInstances[el]);
          } else {
            effect.setVector3(ea[1], this._newUniformInstances[el]);
          }
        } else if (ea[0] == "vec4") {
          if (this._newUniformInstances[el] instanceof Color4) {
            effect.setDirectColor4(ea[1], this._newUniformInstances[el]);
          } else {
            effect.setVector4(ea[1], this._newUniformInstances[el]);
          }
          effect.setVector4(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "mat4") {
          effect.setMatrix(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "float") {
          effect.setFloat(ea[1], this._newUniformInstances[el]);
        }
      }
    }
    if (this._newSamplerInstances) {
      for (const el in this._newSamplerInstances) {
        const ea = el.toString().split("-");
        if (ea[0] == "sampler2D" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {
          effect.setTexture(ea[1], this._newSamplerInstances[el]);
        }
      }
    }
  }
  /**
   * @internal
   */
  ReviewUniform(name30, arr) {
    if (name30 == "uniform" && this._newUniforms) {
      for (let ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") == -1) {
          arr.push(this._newUniforms[ind].replace(/\[\d*\]/g, ""));
        }
      }
    }
    if (name30 == "sampler" && this._newUniforms) {
      for (let ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") != -1) {
          arr.push(this._newUniforms[ind].replace(/\[\d*\]/g, ""));
        }
      }
    }
    return arr;
  }
  /**
   * Builds the material
   * @param shaderName name of the shader
   * @param uniforms list of uniforms
   * @param uniformBuffers list of uniform buffers
   * @param samplers list of samplers
   * @param defines list of defines
   * @param attributes list of attributes
   * @param options options to compile the shader
   * @returns the shader name
   */
  Builder(shaderName, uniforms, uniformBuffers, samplers, defines, attributes, options) {
    if (options) {
      const currentProcessing = options.processFinalCode;
      options.processFinalCode = (type, code) => {
        if (type === "vertex") {
          return currentProcessing ? currentProcessing(type, code) : code;
        }
        const sci = new ShaderCodeInliner(code);
        sci.inlineToken = "#define pbr_inline";
        sci.processCode();
        return currentProcessing ? currentProcessing(type, sci.code) : sci.code;
      };
    }
    if (attributes && this._customAttributes && this._customAttributes.length > 0) {
      attributes.push(...this._customAttributes);
    }
    this.ReviewUniform("uniform", uniforms);
    this.ReviewUniform("sampler", samplers);
    const name30 = this._createdShaderName;
    if (Effect.ShadersStore[name30 + "VertexShader"] && Effect.ShadersStore[name30 + "PixelShader"]) {
      return name30;
    }
    Effect.ShadersStore[name30 + "VertexShader"] = this._injectCustomCode(this.VertexShader, "vertex");
    Effect.ShadersStore[name30 + "PixelShader"] = this._injectCustomCode(this.FragmentShader, "fragment");
    return name30;
  }
  _injectCustomCode(code, shaderType) {
    const customCode = this._getCustomCode(shaderType);
    for (const point in customCode) {
      const injectedCode = customCode[point];
      if (injectedCode && injectedCode.length > 0) {
        const fullPointName = "#define " + point;
        code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
      }
    }
    return code;
  }
  _getCustomCode(shaderType) {
    var _a, _b;
    if (shaderType === "vertex") {
      return {
        CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,
        CUSTOM_VERTEX_DEFINITIONS: (((_a = this._customUniform) == null ? void 0 : _a.join("\n")) || "") + (this.CustomParts.Vertex_Definitions || ""),
        CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,
        CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,
        CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,
        CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,
        CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed
      };
    }
    return {
      CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,
      CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,
      CUSTOM_FRAGMENT_DEFINITIONS: (((_b = this._customUniform) == null ? void 0 : _b.join("\n")) || "") + (this.CustomParts.Fragment_Definitions || ""),
      CUSTOM_FRAGMENT_UPDATE_ALBEDO: this.CustomParts.Fragment_Custom_Albedo,
      CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,
      CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,
      CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS: this.CustomParts.Fragment_Custom_MetallicRoughness,
      CUSTOM_FRAGMENT_UPDATE_MICROSURFACE: this.CustomParts.Fragment_Custom_MicroSurface,
      CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION: this.CustomParts.Fragment_Before_FinalColorComposition,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,
      CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,
      CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog
    };
  }
  constructor(name30, scene) {
    super(name30, scene);
    this.CustomParts = new ShaderAlbedoParts();
    this.customShaderNameResolve = this.Builder;
    this.FragmentShader = Effect.ShadersStore["pbrPixelShader"];
    this.VertexShader = Effect.ShadersStore["pbrVertexShader"];
    this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockAlbedoOpacity>/g, Effect.IncludesShadersStore["pbrBlockAlbedoOpacity"]);
    this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockReflectivity>/g, Effect.IncludesShadersStore["pbrBlockReflectivity"]);
    this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockFinalColorComposition>/g, Effect.IncludesShadersStore["pbrBlockFinalColorComposition"]);
    _PBRCustomMaterial.ShaderIndexer++;
    this._createdShaderName = "custompbr_" + _PBRCustomMaterial.ShaderIndexer;
  }
  _afterBind(mesh, effect = null, subMesh) {
    if (!effect) {
      return;
    }
    this.AttachAfterBind(mesh, effect);
    try {
      super._afterBind(mesh, effect, subMesh);
    } catch (e) {
    }
  }
  /**
   * Adds a new uniform to the shader
   * @param name the name of the uniform to add
   * @param kind the type of the uniform to add
   * @param param the value of the uniform to add
   * @returns the current material
   */
  AddUniform(name30, kind, param) {
    if (!this._customUniform) {
      this._customUniform = new Array();
      this._newUniforms = new Array();
      this._newSamplerInstances = {};
      this._newUniformInstances = {};
    }
    if (param) {
      if (kind.indexOf("sampler") != -1) {
        this._newSamplerInstances[kind + "-" + name30] = param;
      } else {
        this._newUniformInstances[kind + "-" + name30] = param;
      }
    }
    this._customUniform.push("uniform " + kind + " " + name30 + ";");
    this._newUniforms.push(name30);
    return this;
  }
  /**
   * Adds a custom attribute
   * @param name the name of the attribute
   * @returns the current material
   */
  AddAttribute(name30) {
    if (!this._customAttributes) {
      this._customAttributes = [];
    }
    this._customAttributes.push(name30);
    return this;
  }
  /**
   * Sets the code on Fragment_Begin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Begin(shaderPart) {
    this.CustomParts.Fragment_Begin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Definitions portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Definitions(shaderPart) {
    this.CustomParts.Fragment_Definitions = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_MainBegin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_MainBegin(shaderPart) {
    this.CustomParts.Fragment_MainBegin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_Albedo portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_Albedo(shaderPart) {
    this.CustomParts.Fragment_Custom_Albedo = shaderPart.replace("result", "surfaceAlbedo");
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_Alpha portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_Alpha(shaderPart) {
    this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace("result", "alpha");
    return this;
  }
  /**
   * Sets the code on Fragment_Before_Lights portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_Lights(shaderPart) {
    this.CustomParts.Fragment_Before_Lights = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_MetallicRoughness portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_MetallicRoughness(shaderPart) {
    this.CustomParts.Fragment_Custom_MetallicRoughness = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Custom_MicroSurface portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Custom_MicroSurface(shaderPart) {
    this.CustomParts.Fragment_Custom_MicroSurface = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Before_Fog portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_Fog(shaderPart) {
    this.CustomParts.Fragment_Before_Fog = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Before_FinalColorComposition portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_FinalColorComposition(shaderPart) {
    this.CustomParts.Fragment_Before_FinalColorComposition = shaderPart;
    return this;
  }
  /**
   * Sets the code on Fragment_Before_FragColor portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_Before_FragColor(shaderPart) {
    this.CustomParts.Fragment_Before_FragColor = shaderPart.replace("result", "color");
    return this;
  }
  /**
   * Sets the code on Fragment_MainEnd portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Fragment_MainEnd(shaderPart) {
    this.CustomParts.Fragment_MainEnd = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_Begin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Begin(shaderPart) {
    this.CustomParts.Vertex_Begin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_Definitions portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Definitions(shaderPart) {
    this.CustomParts.Vertex_Definitions = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_MainBegin portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_MainBegin(shaderPart) {
    this.CustomParts.Vertex_MainBegin = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_Before_PositionUpdated portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Before_PositionUpdated(shaderPart) {
    this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace("result", "positionUpdated");
    return this;
  }
  /**
   * Sets the code on Vertex_Before_NormalUpdated portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_Before_NormalUpdated(shaderPart) {
    this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace("result", "normalUpdated");
    return this;
  }
  /**
   * Sets the code on Vertex_After_WorldPosComputed portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_After_WorldPosComputed(shaderPart) {
    this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;
    return this;
  }
  /**
   * Sets the code on Vertex_MainEnd portion
   * @param shaderPart the code string
   * @returns the current material
   */
  Vertex_MainEnd(shaderPart) {
    this.CustomParts.Vertex_MainEnd = shaderPart;
    return this;
  }
};
PBRCustomMaterial.ShaderIndexer = 1;
RegisterClass("BABYLON.PBRCustomMaterial", PBRCustomMaterial);

// node_modules/@babylonjs/materials/fire/fire.fragment.js
var name4 = "firePixelShader";
var shader3 = `precision highp float;uniform vec4 vEyePosition;varying vec3 vPositionW;
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
uniform sampler2D distortionSampler;uniform sampler2D opacitySampler;
#ifdef DIFFUSE
varying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
vec4 bx2(vec4 x)
{return vec4(2.0)*x-vec4(1.0);}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);float alpha=1.0;
#ifdef DIFFUSE
const float distortionAmount0 =0.092;const float distortionAmount1 =0.092;const float distortionAmount2 =0.092;vec2 heightAttenuation=vec2(0.3,0.39);vec4 noise0=texture2D(distortionSampler,vDistortionCoords1);vec4 noise1=texture2D(distortionSampler,vDistortionCoords2);vec4 noise2=texture2D(distortionSampler,vDistortionCoords3);vec4 noiseSum=bx2(noise0)*distortionAmount0+bx2(noise1)*distortionAmount1+bx2(noise2)*distortionAmount2;vec4 perturbedBaseCoords=vec4(vDiffuseUV,0.0,1.0)+noiseSum*(vDiffuseUV.y*heightAttenuation.x+heightAttenuation.y);vec4 opacityColor=texture2D(opacitySampler,perturbedBaseCoords.xy);
#ifdef ALPHATEST
if (opacityColor.r<0.1)
discard;
#endif
#include<depthPrePass>
baseColor=texture2D(diffuseSampler,perturbedBaseCoords.xy)*2.0;baseColor*=opacityColor;baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef VERTEXCOLOR
baseColor.rgb*=vColor.rgb;
#endif
vec3 diffuseBase=vec3(1.0,1.0,1.0);
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec4 color=vec4(baseColor.rgb,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name4] = shader3;

// node_modules/@babylonjs/materials/fire/fire.vertex.js
var name5 = "fireVertexShader";
var shader4 = `precision highp float;attribute vec3 position;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
uniform float time;uniform float speed;
#ifdef DIFFUSE
varying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef DIFFUSE
vDiffuseUV=uv;vDiffuseUV.y-=0.2;
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#ifdef DIFFUSE
vec3 layerSpeed=vec3(-0.2,-0.52,-0.1)*speed;vDistortionCoords1.x=uv.x;vDistortionCoords1.y=uv.y+layerSpeed.x*time/1000.0;vDistortionCoords2.x=uv.x;vDistortionCoords2.y=uv.y+layerSpeed.y*time/1000.0;vDistortionCoords3.x=uv.x;vDistortionCoords3.y=uv.y+layerSpeed.z*time/1000.0;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name5] = shader4;

// node_modules/@babylonjs/materials/fire/fireMaterial.js
var FireMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.UV1 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.BonesPerMesh = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var FireMaterial = class _FireMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this.speed = 1;
    this._scaledDiffuse = new Color3();
    this._lastTime = 0;
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return true;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FireMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        if (!this._diffuseTexture.isReady()) {
          return false;
        } else {
          defines._needUVs = true;
          defines.DIFFUSE = true;
        }
      }
    }
    defines.ALPHATEST = this._opacityTexture ? true : false;
    if (defines._areMiscDirty) {
      defines.POINTSIZE = this.pointsCloud || scene.forcePointsCloud;
      defines.FOG = scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled;
      defines.LOGARITHMICDEPTH = this._useLogarithmicDepth;
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, false, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fire";
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant",
        // Fire
        "time",
        "speed"
      ];
      addClipPlaneUniforms(uniforms);
      const join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: [],
        samplers: [
          "diffuseSampler",
          // Fire
          "distortionSampler",
          "opacitySampler"
        ],
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: null,
        maxSimultaneousLights: 4,
        transformFeedbackVaryings: null
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this._diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this._diffuseTexture.getTextureMatrix());
        this._activeEffect.setTexture("distortionSampler", this._distortionTexture);
        this._activeEffect.setTexture("opacitySampler", this._opacityTexture);
      }
      bindClipPlane(this._activeEffect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this._scaledDiffuse, this.alpha * mesh.visibility);
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._lastTime += scene.getEngine().getDeltaTime();
    this._activeEffect.setFloat("time", this._lastTime);
    this._activeEffect.setFloat("speed", this.speed);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    if (this._distortionTexture && this._distortionTexture.animations && this._distortionTexture.animations.length > 0) {
      results.push(this._distortionTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._distortionTexture) {
      activeTextures.push(this._distortionTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    if (this._distortionTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    return false;
  }
  getClassName() {
    return "FireMaterial";
  }
  dispose(forceDisposeEffect) {
    if (this._diffuseTexture) {
      this._diffuseTexture.dispose();
    }
    if (this._distortionTexture) {
      this._distortionTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _FireMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FireMaterial";
    serializationObject.diffuseColor = this.diffuseColor.asArray();
    serializationObject.speed = this.speed;
    if (this._diffuseTexture) {
      serializationObject._diffuseTexture = this._diffuseTexture.serialize();
    }
    if (this._distortionTexture) {
      serializationObject._distortionTexture = this._distortionTexture.serialize();
    }
    if (this._opacityTexture) {
      serializationObject._opacityTexture = this._opacityTexture.serialize();
    }
    return serializationObject;
  }
  static Parse(source, scene, rootUrl) {
    const material = new _FireMaterial(source.name, scene);
    material.diffuseColor = Color3.FromArray(source.diffuseColor);
    material.speed = source.speed;
    material.alpha = source.alpha;
    material.id = source.id;
    Tags.AddTagsTo(material, source.tags);
    material.backFaceCulling = source.backFaceCulling;
    material.wireframe = source.wireframe;
    if (source._diffuseTexture) {
      material._diffuseTexture = Texture.Parse(source._diffuseTexture, scene, rootUrl);
    }
    if (source._distortionTexture) {
      material._distortionTexture = Texture.Parse(source._distortionTexture, scene, rootUrl);
    }
    if (source._opacityTexture) {
      material._opacityTexture = Texture.Parse(source._opacityTexture, scene, rootUrl);
    }
    return material;
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], FireMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FireMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsTexture("distortionTexture")
], FireMaterial.prototype, "_distortionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FireMaterial.prototype, "distortionTexture", void 0);
__decorate([
  serializeAsTexture("opacityTexture")
], FireMaterial.prototype, "_opacityTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FireMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsColor3("diffuse")
], FireMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize()
], FireMaterial.prototype, "speed", void 0);
RegisterClass("BABYLON.FireMaterial", FireMaterial);

// node_modules/@babylonjs/materials/fur/fur.fragment.js
var name6 = "furPixelShader";
var shader5 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;uniform vec4 furColor;uniform float furLength;varying vec3 vPositionW;varying float vfur_length;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#ifdef HIGHLEVEL
uniform float furOffset;uniform float furOcclusion;uniform sampler2D furTexture;varying vec2 vFurUV;
#endif
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<fogFragmentDeclaration>
#include<clipPlaneFragmentDeclaration>
float Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=furColor;vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
baseColor*=texture2D(diffuseSampler,vDiffuseUV);
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef VERTEXCOLOR
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef HIGHLEVEL
vec4 furTextureColor=texture2D(furTexture,vec2(vFurUV.x,vFurUV.y));if (furTextureColor.a<=0.0 || furTextureColor.g<furOffset) {discard;}
float occlusion=mix(0.0,furTextureColor.b*1.2,furOffset);baseColor=vec4(baseColor.xyz*max(occlusion,furOcclusion),1.1-furOffset);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec3 finalDiffuse=clamp(diffuseBase.rgb*baseColor.rgb,0.0,1.0);
#ifdef HIGHLEVEL
vec4 color=vec4(finalDiffuse,alpha);
#else
float r=vfur_length/furLength*0.5;vec4 color=vec4(finalDiffuse*(0.5+r),alpha);
#endif
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name6] = shader5;

// node_modules/@babylonjs/materials/fur/fur.vertex.js
var name7 = "furVertexShader";
var shader6 = `precision highp float;attribute vec3 position;attribute vec3 normal;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
uniform float furLength;uniform float furAngle;
#ifdef HIGHLEVEL
uniform float furOffset;uniform vec3 furGravity;uniform float furTime;uniform float furSpacing;uniform float furDensity;
#endif
#ifdef HEIGHTMAP
uniform sampler2D heightTexture;
#endif
#ifdef HIGHLEVEL
varying vec2 vFurUV;
#endif
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
varying float vfur_length;
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
float Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
float r=Rand(position);
#ifdef HEIGHTMAP
#if __VERSION__>100
vfur_length=furLength*texture(heightTexture,uv).x;
#else
vfur_length=furLength*texture2D(heightTexture,uv).r;
#endif
#else 
vfur_length=(furLength*r);
#endif
vec3 tangent1=vec3(normal.y,-normal.x,0);vec3 tangent2=vec3(-normal.z,0,normal.x);r=Rand(tangent1*r);float J=(2.0+4.0*r);r=Rand(tangent2*r);float K=(2.0+2.0*r);tangent1=tangent1*J+tangent2*K;tangent1=normalize(tangent1);vec3 newPosition=position+normal*vfur_length*cos(furAngle)+tangent1*vfur_length*sin(furAngle);
#ifdef HIGHLEVEL
vec3 forceDirection=vec3(0.0,0.0,0.0);forceDirection.x=sin(furTime+position.x*0.05)*0.2;forceDirection.y=cos(furTime*0.7+position.y*0.04)*0.2;forceDirection.z=sin(furTime*0.7+position.z*0.04)*0.2;vec3 displacement=vec3(0.0,0.0,0.0);displacement=furGravity+forceDirection;float displacementFactor=pow(furOffset,3.0);vec3 aNormal=normal;aNormal.xyz+=displacement*displacementFactor;newPosition=vec3(newPosition.x,newPosition.y,newPosition.z)+(normalize(aNormal)*furOffset*furSpacing);
#endif
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
gl_Position=viewProjection*finalWorld*vec4(newPosition,1.0);vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#ifdef HIGHLEVEL
vFurUV=vDiffuseUV*furDensity;
#endif
#else
#ifdef HIGHLEVEL
vFurUV=uv*furDensity;
#endif
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name7] = shader6;

// node_modules/@babylonjs/materials/fur/furMaterial.js
var FurMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.HEIGHTMAP = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.HIGHLEVEL = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var FurMaterial = class _FurMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this.furLength = 1;
    this.furAngle = 0;
    this.furColor = new Color3(0.44, 0.21, 0.02);
    this.furOffset = 0;
    this.furSpacing = 12;
    this.furGravity = new Vector3(0, 0, 0);
    this.furSpeed = 100;
    this.furDensity = 20;
    this.furOcclusion = 0;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this.highLevelFur = true;
    this._furTime = 0;
  }
  get furTime() {
    return this._furTime;
  }
  set furTime(furTime) {
    this._furTime = furTime;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  updateFur() {
    for (let i = 1; i < this._meshes.length; i++) {
      const offsetFur = this._meshes[i].material;
      offsetFur.furLength = this.furLength;
      offsetFur.furAngle = this.furAngle;
      offsetFur.furGravity = this.furGravity;
      offsetFur.furSpacing = this.furSpacing;
      offsetFur.furSpeed = this.furSpeed;
      offsetFur.furColor = this.furColor;
      offsetFur.diffuseTexture = this.diffuseTexture;
      offsetFur.furTexture = this.furTexture;
      offsetFur.highLevelFur = this.highLevelFur;
      offsetFur.furTime = this.furTime;
      offsetFur.furDensity = this.furDensity;
    }
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FurMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this.diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
        if (this.heightTexture && engine.getCaps().maxVertexTextureImageUnits) {
          if (!this.heightTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.HEIGHTMAP = true;
          }
        }
      }
    }
    if (this.highLevelFur !== defines.HIGHLEVEL) {
      defines.HIGHLEVEL = true;
      defines.markAsUnprocessed();
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fur";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant",
        "furLength",
        "furAngle",
        "furColor",
        "furOffset",
        "furGravity",
        "furTime",
        "furSpacing",
        "furDensity",
        "furOcclusion"
      ];
      addClipPlaneUniforms(uniforms);
      const samplers = ["diffuseSampler", "heightTexture", "furTexture"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this._diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this._diffuseTexture.getTextureMatrix());
      }
      if (this._heightTexture) {
        this._activeEffect.setTexture("heightTexture", this._heightTexture);
      }
      bindClipPlane(this._activeEffect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._activeEffect.setFloat("furLength", this.furLength);
    this._activeEffect.setFloat("furAngle", this.furAngle);
    this._activeEffect.setColor4("furColor", this.furColor, 1);
    if (this.highLevelFur) {
      this._activeEffect.setVector3("furGravity", this.furGravity);
      this._activeEffect.setFloat("furOffset", this.furOffset);
      this._activeEffect.setFloat("furSpacing", this.furSpacing);
      this._activeEffect.setFloat("furDensity", this.furDensity);
      this._activeEffect.setFloat("furOcclusion", this.furOcclusion);
      this._furTime += this.getScene().getEngine().getDeltaTime() / this.furSpeed;
      this._activeEffect.setFloat("furTime", this._furTime);
      this._activeEffect.setTexture("furTexture", this.furTexture);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {
      results.push(this.diffuseTexture);
    }
    if (this.heightTexture && this.heightTexture.animations && this.heightTexture.animations.length > 0) {
      results.push(this.heightTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._heightTexture) {
      activeTextures.push(this._heightTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this.diffuseTexture === texture) {
      return true;
    }
    if (this._heightTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.diffuseTexture) {
      this.diffuseTexture.dispose();
    }
    if (this._meshes) {
      for (let i = 1; i < this._meshes.length; i++) {
        const mat = this._meshes[i].material;
        if (mat) {
          mat.dispose(forceDisposeEffect);
        }
        this._meshes[i].dispose();
      }
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _FurMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FurMaterial";
    if (this._meshes) {
      serializationObject.sourceMeshName = this._meshes[0].name;
      serializationObject.quality = this._meshes.length;
    }
    return serializationObject;
  }
  getClassName() {
    return "FurMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _FurMaterial(source.name, scene), source, scene, rootUrl);
    if (source.sourceMeshName && material.highLevelFur) {
      scene.executeWhenReady(() => {
        const sourceMesh = scene.getMeshByName(source.sourceMeshName);
        if (sourceMesh) {
          const furTexture = _FurMaterial.GenerateTexture("Fur Texture", scene);
          material.furTexture = furTexture;
          _FurMaterial.FurifyMesh(sourceMesh, source.quality);
        }
      });
    }
    return material;
  }
  static GenerateTexture(name30, scene) {
    const texture = new DynamicTexture("FurTexture " + name30, 256, scene, true);
    const context = texture.getContext();
    for (let i = 0; i < 2e4; ++i) {
      context.fillStyle = "rgba(255, " + Math.floor(Math.random() * 255) + ", " + Math.floor(Math.random() * 255) + ", 1)";
      context.fillRect(Math.random() * texture.getSize().width, Math.random() * texture.getSize().height, 2, 2);
    }
    texture.update(false);
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
    return texture;
  }
  // Creates and returns an array of meshes used as shells for the Fur Material
  // that can be disposed later in your code
  // The quality is in interval [0, 100]
  static FurifyMesh(sourceMesh, quality) {
    const meshes = [sourceMesh];
    const mat = sourceMesh.material;
    let i;
    if (!(mat instanceof _FurMaterial)) {
      throw "The material of the source mesh must be a Fur Material";
    }
    for (i = 1; i < quality; i++) {
      const offsetFur = new _FurMaterial(mat.name + i, sourceMesh.getScene());
      sourceMesh.getScene().materials.pop();
      Tags.EnableFor(offsetFur);
      Tags.AddTagsTo(offsetFur, "furShellMaterial");
      offsetFur.furLength = mat.furLength;
      offsetFur.furAngle = mat.furAngle;
      offsetFur.furGravity = mat.furGravity;
      offsetFur.furSpacing = mat.furSpacing;
      offsetFur.furSpeed = mat.furSpeed;
      offsetFur.furColor = mat.furColor;
      offsetFur.diffuseTexture = mat.diffuseTexture;
      offsetFur.furOffset = i / quality;
      offsetFur.furTexture = mat.furTexture;
      offsetFur.highLevelFur = mat.highLevelFur;
      offsetFur.furTime = mat.furTime;
      offsetFur.furDensity = mat.furDensity;
      const offsetMesh = sourceMesh.clone(sourceMesh.name + i);
      offsetMesh.material = offsetFur;
      offsetMesh.skeleton = sourceMesh.skeleton;
      offsetMesh.position = Vector3.Zero();
      meshes.push(offsetMesh);
    }
    for (i = 1; i < meshes.length; i++) {
      meshes[i].parent = sourceMesh;
    }
    sourceMesh.material._meshes = meshes;
    return meshes;
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], FurMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FurMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsTexture("heightTexture")
], FurMaterial.prototype, "_heightTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FurMaterial.prototype, "heightTexture", void 0);
__decorate([
  serializeAsColor3()
], FurMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furLength", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furAngle", void 0);
__decorate([
  serializeAsColor3()
], FurMaterial.prototype, "furColor", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furOffset", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furSpacing", void 0);
__decorate([
  serializeAsVector3()
], FurMaterial.prototype, "furGravity", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furSpeed", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furDensity", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furOcclusion", void 0);
__decorate([
  serialize("disableLighting")
], FurMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], FurMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], FurMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], FurMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "highLevelFur", void 0);
__decorate([
  serialize()
], FurMaterial.prototype, "furTime", null);
RegisterClass("BABYLON.FurMaterial", FurMaterial);

// node_modules/@babylonjs/materials/gradient/gradient.fragment.js
var name8 = "gradientPixelShader";
var shader7 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 topColor;uniform vec4 bottomColor;uniform float offset;uniform float scale;uniform float smoothness;varying vec3 vPositionW;varying vec3 vPosition;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0]
#include<__decl__lightFragment>[1]
#include<__decl__lightFragment>[2]
#include<__decl__lightFragment>[3]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);float h=vPosition.y*scale+offset;float mysmoothness=clamp(smoothness,0.01,max(smoothness,10.));vec4 baseColor=mix(bottomColor,topColor,max(pow(max(h,0.0),mysmoothness),0.0));vec3 diffuseColor=baseColor.rgb;float alpha=baseColor.a;
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
#ifdef VERTEXCOLOR
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef EMISSIVE
vec3 diffuseBase=baseColor.rgb;
#else
vec3 diffuseBase=vec3(0.,0.,0.);
#endif
lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name8] = shader7;

// node_modules/@babylonjs/materials/gradient/gradient.vertex.js
var name9 = "gradientVertexShader";
var shader8 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;varying vec3 vPosition;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);vPosition=position;
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name9] = shader8;

// node_modules/@babylonjs/materials/gradient/gradientMaterial.js
var GradientMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.EMISSIVE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var GradientMaterial = class _GradientMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this._maxSimultaneousLights = 4;
    this.topColor = new Color3(1, 0, 0);
    this.topColorAlpha = 1;
    this.bottomColor = new Color3(0, 0, 1);
    this.bottomColorAlpha = 1;
    this.offset = 0;
    this.scale = 1;
    this.smoothness = 1;
    this._disableLighting = false;
  }
  needAlphaBlending() {
    return this.alpha < 1 || this.topColorAlpha < 1 || this.bottomColorAlpha < 1;
  }
  needAlphaTesting() {
    return true;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new GradientMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    defines.EMISSIVE = this._disableLighting;
    PrepareDefinesForAttributes(mesh, defines, false, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "gradient";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "mBones",
        "logarithmicDepthConstant",
        "topColor",
        "bottomColor",
        "offset",
        "smoothness",
        "scale"
      ];
      addClipPlaneUniforms(uniforms);
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, effect);
    if (this._mustRebind(scene, effect, subMesh)) {
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._activeEffect.setColor4("topColor", this.topColor, this.topColorAlpha);
    this._activeEffect.setColor4("bottomColor", this.bottomColor, this.bottomColorAlpha);
    this._activeEffect.setFloat("offset", this.offset);
    this._activeEffect.setFloat("scale", this.scale);
    this._activeEffect.setFloat("smoothness", this.smoothness);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _GradientMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GradientMaterial";
    return serializationObject;
  }
  getClassName() {
    return "GradientMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _GradientMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize("maxSimultaneousLights")
], GradientMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], GradientMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serializeAsColor3()
], GradientMaterial.prototype, "topColor", void 0);
__decorate([
  serialize()
], GradientMaterial.prototype, "topColorAlpha", void 0);
__decorate([
  serializeAsColor3()
], GradientMaterial.prototype, "bottomColor", void 0);
__decorate([
  serialize()
], GradientMaterial.prototype, "bottomColorAlpha", void 0);
__decorate([
  serialize()
], GradientMaterial.prototype, "offset", void 0);
__decorate([
  serialize()
], GradientMaterial.prototype, "scale", void 0);
__decorate([
  serialize()
], GradientMaterial.prototype, "smoothness", void 0);
__decorate([
  serialize("disableLighting")
], GradientMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], GradientMaterial.prototype, "disableLighting", void 0);
RegisterClass("BABYLON.GradientMaterial", GradientMaterial);

// node_modules/@babylonjs/materials/grid/grid.fragment.js
var name10 = "gridPixelShader";
var shader9 = `#extension GL_OES_standard_derivatives : enable
#define SQRT2 1.41421356
#define PI 3.14159
precision highp float;uniform float visibility;uniform vec3 mainColor;uniform vec3 lineColor;uniform vec4 gridControl;uniform vec3 gridOffset;varying vec3 vPosition;varying vec3 vNormal;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#ifdef OPACITY
varying vec2 vOpacityUV;uniform sampler2D opacitySampler;uniform vec2 vOpacityInfos;
#endif
float getDynamicVisibility(float position) {float majorGridFrequency=gridControl.y;if (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)
{return 1.0;}
return gridControl.z;}
float getAnisotropicAttenuation(float differentialLength) {const float maxNumberOfLines=10.0;return clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);}
float isPointOnLine(float position,float differentialLength) {float fractionPartOfPosition=position-floor(position+0.5); 
fractionPartOfPosition/=differentialLength; 
#ifdef ANTIALIAS
fractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);float result=0.5+0.5*cos(fractionPartOfPosition*PI); 
return result;
#else
return abs(fractionPartOfPosition)<SQRT2/4. ? 1. : 0.;
#endif
}
float contributionOnAxis(float position) {float differentialLength=length(vec2(dFdx(position),dFdy(position)));differentialLength*=SQRT2; 
float result=isPointOnLine(position,differentialLength);float dynamicVisibility=getDynamicVisibility(position);result*=dynamicVisibility;float anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);result*=anisotropicAttenuation;return result;}
float normalImpactOnAxis(float x) {float normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);return normalImpact;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
float gridRatio=gridControl.x;vec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;float x=contributionOnAxis(gridPos.x);float y=contributionOnAxis(gridPos.y);float z=contributionOnAxis(gridPos.z);vec3 normal=normalize(vNormal);x*=normalImpactOnAxis(normal.x);y*=normalImpactOnAxis(normal.y);z*=normalImpactOnAxis(normal.z);
#ifdef MAX_LINE
float grid=clamp(max(max(x,y),z),0.,1.);
#else
float grid=clamp(x+y+z,0.,1.);
#endif
vec3 color=mix(mainColor,lineColor,grid);
#ifdef FOG
#include<fogFragment>
#endif
float opacity=1.0;
#ifdef TRANSPARENT
opacity=clamp(grid,0.08,gridControl.w*grid);
#endif
#ifdef OPACITY
opacity*=texture2D(opacitySampler,vOpacityUV).a;
#endif
gl_FragColor=vec4(color.rgb,opacity*visibility);
#ifdef TRANSPARENT
#ifdef PREMULTIPLYALPHA
gl_FragColor.rgb*=opacity;
#endif
#else
#endif
#include<logDepthFragment>
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name10] = shader9;

// node_modules/@babylonjs/materials/grid/grid.vertex.js
var name11 = "gridVertexShader";
var shader10 = `precision highp float;attribute vec3 position;attribute vec3 normal;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#include<instancesDeclaration>
uniform mat4 projection;uniform mat4 view;varying vec3 vPosition;varying vec3 vNormal;
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#ifdef OPACITY
varying vec2 vOpacityUV;uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
vec4 worldPos=finalWorld*vec4(position,1.0);
#include<fogVertex>
vec4 cameraSpacePosition=view*worldPos;gl_Position=projection*cameraSpacePosition;
#ifdef OPACITY
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
if (vOpacityInfos.x==0.)
{vOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));}
else
{vOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));}
#endif 
#include<logDepthVertex>
vPosition=position;vNormal=normal;
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name11] = shader10;

// node_modules/@babylonjs/materials/grid/gridMaterial.js
var GridMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.OPACITY = false;
    this.ANTIALIAS = false;
    this.TRANSPARENT = false;
    this.FOG = false;
    this.PREMULTIPLYALPHA = false;
    this.MAX_LINE = false;
    this.UV1 = false;
    this.UV2 = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var GridMaterial = class _GridMaterial extends PushMaterial {
  /**
   * constructor
   * @param name The name given to the material in order to identify it afterwards.
   * @param scene The scene the material is used in.
   */
  constructor(name30, scene) {
    super(name30, scene);
    this.mainColor = Color3.Black();
    this.lineColor = Color3.Teal();
    this.gridRatio = 1;
    this.gridOffset = Vector3.Zero();
    this.majorUnitFrequency = 10;
    this.minorUnitVisibility = 0.33;
    this.opacity = 1;
    this.antialias = true;
    this.preMultiplyAlpha = false;
    this.useMaxLine = false;
    this._gridControl = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);
  }
  /**
   * @returns whether or not the grid requires alpha blending.
   */
  needAlphaBlending() {
    return this.opacity < 1 || this._opacityTexture && this._opacityTexture.isReady();
  }
  needAlphaBlendingForMesh(mesh) {
    return mesh.visibility < 1 || this.needAlphaBlending();
  }
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new GridMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    if (defines.TRANSPARENT !== this.opacity < 1) {
      defines.TRANSPARENT = !defines.TRANSPARENT;
      defines.markAsUnprocessed();
    }
    if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {
      defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;
      defines.markAsUnprocessed();
    }
    if (defines.MAX_LINE !== this.useMaxLine) {
      defines.MAX_LINE = !defines.MAX_LINE;
      defines.markAsUnprocessed();
    }
    if (defines.ANTIALIAS !== this.antialias) {
      defines.ANTIALIAS = !defines.ANTIALIAS;
      defines.markAsUnprocessed();
    }
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.OPACITY = true;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, false, this.fogEnabled, false, defines);
    PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), this, defines, !!useInstances);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      PrepareDefinesForAttributes(mesh, defines, false, false);
      const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      PrepareAttributesForInstances(attribs, defines);
      const join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect("grid", attribs, [
        "projection",
        "mainColor",
        "lineColor",
        "gridControl",
        "gridOffset",
        "vFogInfos",
        "vFogColor",
        "world",
        "view",
        "opacityMatrix",
        "vOpacityInfos",
        "visibility",
        "logarithmicDepthConstant"
      ], ["opacitySampler"], join, void 0, this.onCompiled, this.onError), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this._activeEffect.setFloat("visibility", mesh.visibility);
    if (!defines.INSTANCES || defines.THIN_INSTANCE) {
      this.bindOnlyWorldMatrix(world);
    }
    this._activeEffect.setMatrix("view", scene.getViewMatrix());
    this._activeEffect.setMatrix("projection", scene.getProjectionMatrix());
    if (this._mustRebind(scene, effect, subMesh)) {
      this._activeEffect.setColor3("mainColor", this.mainColor);
      this._activeEffect.setColor3("lineColor", this.lineColor);
      this._activeEffect.setVector3("gridOffset", this.gridOffset);
      this._gridControl.x = this.gridRatio;
      this._gridControl.y = Math.round(this.majorUnitFrequency);
      this._gridControl.z = this.minorUnitVisibility;
      this._gridControl.w = this.opacity;
      this._activeEffect.setVector4("gridControl", this._gridControl);
      if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
        this._activeEffect.setTexture("opacitySampler", this._opacityTexture);
        this._activeEffect.setFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
        this._activeEffect.setMatrix("opacityMatrix", this._opacityTexture.getTextureMatrix());
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Dispose the material and its associated resources.
   * @param forceDisposeEffect will also dispose the used effect when true
   */
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _GridMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GridMaterial";
    return serializationObject;
  }
  getClassName() {
    return "GridMaterial";
  }
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _GridMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsColor3()
], GridMaterial.prototype, "mainColor", void 0);
__decorate([
  serializeAsColor3()
], GridMaterial.prototype, "lineColor", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "gridRatio", void 0);
__decorate([
  serializeAsVector3()
], GridMaterial.prototype, "gridOffset", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "majorUnitFrequency", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "minorUnitVisibility", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "opacity", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "antialias", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "preMultiplyAlpha", void 0);
__decorate([
  serialize()
], GridMaterial.prototype, "useMaxLine", void 0);
__decorate([
  serializeAsTexture("opacityTexture")
], GridMaterial.prototype, "_opacityTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], GridMaterial.prototype, "opacityTexture", void 0);
RegisterClass("BABYLON.GridMaterial", GridMaterial);

// node_modules/@babylonjs/materials/lava/lava.fragment.js
var name12 = "lavaPixelShader";
var shader11 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;uniform float time;uniform float speed;uniform float movingSpeed;uniform vec3 fogColor;uniform sampler2D noiseTexture;uniform float fogDensity;varying float noise;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0]
#include<__decl__lightFragment>[1]
#include<__decl__lightFragment>[2]
#include<__decl__lightFragment>[3]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
float random( vec3 scale,float seed ){return fract( sin( dot( gl_FragCoord.xyz+seed,scale ) )*43758.5453+seed ) ;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
vec4 noiseTex=texture2D( noiseTexture,vDiffuseUV );vec2 T1=vDiffuseUV+vec2( 1.5,-1.5 )*time *0.02;vec2 T2=vDiffuseUV+vec2( -0.5,2.0 )*time*0.01*speed;T1.x+=noiseTex.x*2.0;T1.y+=noiseTex.y*2.0;T2.x-=noiseTex.y*0.2+time*0.001*movingSpeed;T2.y+=noiseTex.z*0.2+time*0.002*movingSpeed;float p=texture2D( noiseTexture,T1*3.0 ).a;vec4 lavaColor=texture2D( diffuseSampler,T2*4.0);vec4 temp=lavaColor*( vec4( p,p,p,p )*2. )+( lavaColor*lavaColor-0.1 );baseColor=temp;float depth=gl_FragCoord.z*4.0;const float LOG2=1.442695;float fogFactor=exp2(-fogDensity*fogDensity*depth*depth*LOG2 );fogFactor=1.0-clamp( fogFactor,0.0,1.0 );baseColor=mix( baseColor,vec4( fogColor,baseColor.w ),fogFactor );diffuseColor=baseColor.rgb;
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef VERTEXCOLOR
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0]
#include<lightFragment>[1]
#include<lightFragment>[2]
#include<lightFragment>[3]
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name12] = shader11;

// node_modules/@babylonjs/materials/lava/lava.vertex.js
var name13 = "lavaVertexShader";
var shader12 = `precision highp float;uniform float time;uniform float lowFrequencySpeed;varying float noise;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
/* NOISE FUNCTIONS */
vec3 mod289(vec3 x)
{return x-floor(x*(1.0/289.0))*289.0;}
vec4 mod289(vec4 x)
{return x-floor(x*(1.0/289.0))*289.0;}
vec4 permute(vec4 x)
{return mod289(((x*34.0)+1.0)*x);}
vec4 taylorInvSqrt(vec4 r)
{return 1.79284291400159-0.85373472095314*r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
float pnoise(vec3 P,vec3 rep)
{vec3 Pi0=mod(floor(P),rep); 
vec3 Pi1=mod(Pi0+vec3(1.0),rep); 
Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P); 
vec3 Pf1=Pf0-vec3(1.0); 
vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}
/* END FUNCTION */
float turbulence( vec3 p ) {float w=100.0;float t=-.5;for (float f=1.0 ; f<=10.0 ; f++ ){float power=pow( 2.0,f );t+=abs( pnoise( vec3( power*p ),vec3( 10.0,10.0,10.0 ) )/power );}
return t;}
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
#ifdef NORMAL
noise=10.0* -.10*turbulence( .5*normal+time*1.15 );float b=lowFrequencySpeed*5.0*pnoise( 0.05*position +vec3(time*1.025),vec3( 100.0 ) );float displacement=- 1.5*noise+b;vec3 newPosition=position+normal*displacement;gl_Position=viewProjection*finalWorld*vec4( newPosition,1.0 );vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<logDepthVertex>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name13] = shader12;

// node_modules/@babylonjs/materials/lava/lavaMaterial.js
var LavaMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LIGHT0 = false;
    this.LIGHT1 = false;
    this.LIGHT2 = false;
    this.LIGHT3 = false;
    this.SPOTLIGHT0 = false;
    this.SPOTLIGHT1 = false;
    this.SPOTLIGHT2 = false;
    this.SPOTLIGHT3 = false;
    this.HEMILIGHT0 = false;
    this.HEMILIGHT1 = false;
    this.HEMILIGHT2 = false;
    this.HEMILIGHT3 = false;
    this.DIRLIGHT0 = false;
    this.DIRLIGHT1 = false;
    this.DIRLIGHT2 = false;
    this.DIRLIGHT3 = false;
    this.POINTLIGHT0 = false;
    this.POINTLIGHT1 = false;
    this.POINTLIGHT2 = false;
    this.POINTLIGHT3 = false;
    this.SHADOW0 = false;
    this.SHADOW1 = false;
    this.SHADOW2 = false;
    this.SHADOW3 = false;
    this.SHADOWS = false;
    this.SHADOWESM0 = false;
    this.SHADOWESM1 = false;
    this.SHADOWESM2 = false;
    this.SHADOWESM3 = false;
    this.SHADOWPOISSON0 = false;
    this.SHADOWPOISSON1 = false;
    this.SHADOWPOISSON2 = false;
    this.SHADOWPOISSON3 = false;
    this.SHADOWPCF0 = false;
    this.SHADOWPCF1 = false;
    this.SHADOWPCF2 = false;
    this.SHADOWPCF3 = false;
    this.SHADOWPCSS0 = false;
    this.SHADOWPCSS1 = false;
    this.SHADOWPCSS2 = false;
    this.SHADOWPCSS3 = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.UNLIT = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var LavaMaterial = class _LavaMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.speed = 1;
    this.movingSpeed = 1;
    this.lowFrequencySpeed = 1;
    this.fogDensity = 0.15;
    this._lastTime = 0;
    this.diffuseColor = new Color3(1, 1, 1);
    this._disableLighting = false;
    this._unlit = false;
    this._maxSimultaneousLights = 4;
    this._scaledDiffuse = new Color3();
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new LavaMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = true;
    PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "lava";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant",
        "time",
        "speed",
        "movingSpeed",
        "fogColor",
        "fogDensity",
        "lowFrequencySpeed"
      ];
      addClipPlaneUniforms(uniforms);
      const samplers = ["diffuseSampler", "noiseTexture"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    defines.UNLIT = this._unlit;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this.diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this.diffuseTexture.getTextureMatrix());
      }
      if (this.noiseTexture) {
        this._activeEffect.setTexture("noiseTexture", this.noiseTexture);
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this._scaledDiffuse, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._lastTime += scene.getEngine().getDeltaTime();
    this._activeEffect.setFloat("time", this._lastTime * this.speed / 1e3);
    if (!this.fogColor) {
      this.fogColor = Color3.Black();
    }
    this._activeEffect.setColor3("fogColor", this.fogColor);
    this._activeEffect.setFloat("fogDensity", this.fogDensity);
    this._activeEffect.setFloat("lowFrequencySpeed", this.lowFrequencySpeed);
    this._activeEffect.setFloat("movingSpeed", this.movingSpeed);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {
      results.push(this.diffuseTexture);
    }
    if (this.noiseTexture && this.noiseTexture.animations && this.noiseTexture.animations.length > 0) {
      results.push(this.noiseTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this.diffuseTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.diffuseTexture) {
      this.diffuseTexture.dispose();
    }
    if (this.noiseTexture) {
      this.noiseTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _LavaMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.LavaMaterial";
    return serializationObject;
  }
  getClassName() {
    return "LavaMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _LavaMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], LavaMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], LavaMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsTexture()
], LavaMaterial.prototype, "noiseTexture", void 0);
__decorate([
  serializeAsColor3()
], LavaMaterial.prototype, "fogColor", void 0);
__decorate([
  serialize()
], LavaMaterial.prototype, "speed", void 0);
__decorate([
  serialize()
], LavaMaterial.prototype, "movingSpeed", void 0);
__decorate([
  serialize()
], LavaMaterial.prototype, "lowFrequencySpeed", void 0);
__decorate([
  serialize()
], LavaMaterial.prototype, "fogDensity", void 0);
__decorate([
  serializeAsColor3()
], LavaMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize("disableLighting")
], LavaMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], LavaMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("unlit")
], LavaMaterial.prototype, "_unlit", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], LavaMaterial.prototype, "unlit", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], LavaMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], LavaMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.LavaMaterial", LavaMaterial);

// node_modules/@babylonjs/materials/mix/mix.fragment.js
var name14 = "mixPixelShader";
var shader13 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#ifdef DIFFUSE
varying vec2 vTextureUV;uniform sampler2D mixMap1Sampler;uniform vec2 vTextureInfos;
#ifdef MIXMAP2
uniform sampler2D mixMap2Sampler;
#endif
uniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform sampler2D diffuse4Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;uniform vec2 diffuse4Infos;
#ifdef MIXMAP2
uniform sampler2D diffuse5Sampler;uniform sampler2D diffuse6Sampler;uniform sampler2D diffuse7Sampler;uniform sampler2D diffuse8Sampler;uniform vec2 diffuse5Infos;uniform vec2 diffuse6Infos;uniform vec2 diffuse7Infos;uniform vec2 diffuse8Infos;
#endif
#endif
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 finalMixColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;
#ifdef MIXMAP2
vec4 mixColor2=vec4(1.,1.,1.,1.);
#endif
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#else
float glossiness=0.;
#endif
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef DIFFUSE
vec4 mixColor=texture2D(mixMap1Sampler,vTextureUV);
#include<depthPrePass>
mixColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);vec4 diffuse4Color=texture2D(diffuse4Sampler,vTextureUV*diffuse4Infos);diffuse1Color.rgb*=mixColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,mixColor.g);diffuse3Color.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse3Color.rgb,diffuse4Color.rgb,1.0-mixColor.a);
#ifdef MIXMAP2
mixColor=texture2D(mixMap2Sampler,vTextureUV);mixColor.rgb*=vTextureInfos.y;vec4 diffuse5Color=texture2D(diffuse5Sampler,vTextureUV*diffuse5Infos);vec4 diffuse6Color=texture2D(diffuse6Sampler,vTextureUV*diffuse6Infos);vec4 diffuse7Color=texture2D(diffuse7Sampler,vTextureUV*diffuse7Infos);vec4 diffuse8Color=texture2D(diffuse8Sampler,vTextureUV*diffuse8Infos);diffuse5Color.rgb=mix(finalMixColor.rgb,diffuse5Color.rgb,mixColor.r);diffuse6Color.rgb=mix(diffuse5Color.rgb,diffuse6Color.rgb,mixColor.g);diffuse7Color.rgb=mix(diffuse6Color.rgb,diffuse7Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse7Color.rgb,diffuse8Color.rgb,1.0-mixColor.a);
#endif
#endif
#ifdef VERTEXCOLOR
finalMixColor.rgb*=vColor.rgb;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#else
vec3 finalSpecular=vec3(0.0);
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor*finalMixColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name14] = shader13;

// node_modules/@babylonjs/materials/mix/mix.vertex.js
var name15 = "mixVertexShader";
var shader14 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vTextureInfos.x==0.)
{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}
else
{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name15] = shader14;

// node_modules/@babylonjs/materials/mix/mixMaterial.js
var MixMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.SPECULARTERM = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.MIXMAP2 = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var MixMaterial = class _MixMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(0, 0, 0);
    this.specularPower = 64;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MixMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (scene.texturesEnabled) {
      if (!this._mixTexture1 || !this._mixTexture1.isReady()) {
        return false;
      }
      defines._needUVs = true;
      if (MaterialFlags.DiffuseTextureEnabled) {
        if (!this._diffuseTexture1 || !this._diffuseTexture1.isReady()) {
          return false;
        }
        defines.DIFFUSE = true;
        if (!this._diffuseTexture2 || !this._diffuseTexture2.isReady()) {
          return false;
        }
        if (!this._diffuseTexture3 || !this._diffuseTexture3.isReady()) {
          return false;
        }
        if (!this._diffuseTexture4 || !this._diffuseTexture4.isReady()) {
          return false;
        }
        if (this._mixTexture2) {
          if (!this._mixTexture2.isReady()) {
            return false;
          }
          defines.MIXMAP2 = true;
          if (!this._diffuseTexture5 || !this._diffuseTexture5.isReady()) {
            return false;
          }
          if (!this._diffuseTexture6 || !this._diffuseTexture6.isReady()) {
            return false;
          }
          if (!this._diffuseTexture7 || !this._diffuseTexture7.isReady()) {
            return false;
          }
          if (!this._diffuseTexture8 || !this._diffuseTexture8.isReady()) {
            return false;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mix";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vSpecularColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vTextureInfos",
        "mBones",
        "textureMatrix",
        "logarithmicDepthConstant",
        "diffuse1Infos",
        "diffuse2Infos",
        "diffuse3Infos",
        "diffuse4Infos",
        "diffuse5Infos",
        "diffuse6Infos",
        "diffuse7Infos",
        "diffuse8Infos"
      ];
      const samplers = [
        "mixMap1Sampler",
        "mixMap2Sampler",
        "diffuse1Sampler",
        "diffuse2Sampler",
        "diffuse3Sampler",
        "diffuse4Sampler",
        "diffuse5Sampler",
        "diffuse6Sampler",
        "diffuse7Sampler",
        "diffuse8Sampler"
      ];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this._mixTexture1) {
        this._activeEffect.setTexture("mixMap1Sampler", this._mixTexture1);
        this._activeEffect.setFloat2("vTextureInfos", this._mixTexture1.coordinatesIndex, this._mixTexture1.level);
        this._activeEffect.setMatrix("textureMatrix", this._mixTexture1.getTextureMatrix());
        if (MaterialFlags.DiffuseTextureEnabled) {
          if (this._diffuseTexture1) {
            this._activeEffect.setTexture("diffuse1Sampler", this._diffuseTexture1);
            this._activeEffect.setFloat2("diffuse1Infos", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);
          }
          if (this._diffuseTexture2) {
            this._activeEffect.setTexture("diffuse2Sampler", this._diffuseTexture2);
            this._activeEffect.setFloat2("diffuse2Infos", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);
          }
          if (this._diffuseTexture3) {
            this._activeEffect.setTexture("diffuse3Sampler", this._diffuseTexture3);
            this._activeEffect.setFloat2("diffuse3Infos", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);
          }
          if (this._diffuseTexture4) {
            this._activeEffect.setTexture("diffuse4Sampler", this._diffuseTexture4);
            this._activeEffect.setFloat2("diffuse4Infos", this._diffuseTexture4.uScale, this._diffuseTexture4.vScale);
          }
        }
      }
      if (this._mixTexture2) {
        this._activeEffect.setTexture("mixMap2Sampler", this._mixTexture2);
        if (MaterialFlags.DiffuseTextureEnabled) {
          if (this._diffuseTexture5) {
            this._activeEffect.setTexture("diffuse5Sampler", this._diffuseTexture5);
            this._activeEffect.setFloat2("diffuse5Infos", this._diffuseTexture5.uScale, this._diffuseTexture5.vScale);
          }
          if (this._diffuseTexture6) {
            this._activeEffect.setTexture("diffuse6Sampler", this._diffuseTexture6);
            this._activeEffect.setFloat2("diffuse6Infos", this._diffuseTexture6.uScale, this._diffuseTexture6.vScale);
          }
          if (this._diffuseTexture7) {
            this._activeEffect.setTexture("diffuse7Sampler", this._diffuseTexture7);
            this._activeEffect.setFloat2("diffuse7Infos", this._diffuseTexture7.uScale, this._diffuseTexture7.vScale);
          }
          if (this._diffuseTexture8) {
            this._activeEffect.setTexture("diffuse8Sampler", this._diffuseTexture8);
            this._activeEffect.setFloat2("diffuse8Infos", this._diffuseTexture8.uScale, this._diffuseTexture8.vScale);
          }
        }
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (defines.SPECULARTERM) {
      this._activeEffect.setColor4("vSpecularColor", this.specularColor, this.specularPower);
    }
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this._mixTexture1 && this._mixTexture1.animations && this._mixTexture1.animations.length > 0) {
      results.push(this._mixTexture1);
    }
    if (this._mixTexture2 && this._mixTexture2.animations && this._mixTexture2.animations.length > 0) {
      results.push(this._mixTexture2);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._mixTexture1) {
      activeTextures.push(this._mixTexture1);
    }
    if (this._diffuseTexture1) {
      activeTextures.push(this._diffuseTexture1);
    }
    if (this._diffuseTexture2) {
      activeTextures.push(this._diffuseTexture2);
    }
    if (this._diffuseTexture3) {
      activeTextures.push(this._diffuseTexture3);
    }
    if (this._diffuseTexture4) {
      activeTextures.push(this._diffuseTexture4);
    }
    if (this._mixTexture2) {
      activeTextures.push(this._mixTexture2);
    }
    if (this._diffuseTexture5) {
      activeTextures.push(this._diffuseTexture5);
    }
    if (this._diffuseTexture6) {
      activeTextures.push(this._diffuseTexture6);
    }
    if (this._diffuseTexture7) {
      activeTextures.push(this._diffuseTexture7);
    }
    if (this._diffuseTexture8) {
      activeTextures.push(this._diffuseTexture8);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._mixTexture1 === texture) {
      return true;
    }
    if (this._diffuseTexture1 === texture) {
      return true;
    }
    if (this._diffuseTexture2 === texture) {
      return true;
    }
    if (this._diffuseTexture3 === texture) {
      return true;
    }
    if (this._diffuseTexture4 === texture) {
      return true;
    }
    if (this._mixTexture2 === texture) {
      return true;
    }
    if (this._diffuseTexture5 === texture) {
      return true;
    }
    if (this._diffuseTexture6 === texture) {
      return true;
    }
    if (this._diffuseTexture7 === texture) {
      return true;
    }
    if (this._diffuseTexture8 === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this._mixTexture1) {
      this._mixTexture1.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _MixMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MixMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MixMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MixMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("mixTexture1")
], MixMaterial.prototype, "_mixTexture1", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "mixTexture1", void 0);
__decorate([
  serializeAsTexture("mixTexture2")
], MixMaterial.prototype, "_mixTexture2", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "mixTexture2", void 0);
__decorate([
  serializeAsTexture("diffuseTexture1")
], MixMaterial.prototype, "_diffuseTexture1", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture1", void 0);
__decorate([
  serializeAsTexture("diffuseTexture2")
], MixMaterial.prototype, "_diffuseTexture2", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture2", void 0);
__decorate([
  serializeAsTexture("diffuseTexture3")
], MixMaterial.prototype, "_diffuseTexture3", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture3", void 0);
__decorate([
  serializeAsTexture("diffuseTexture4")
], MixMaterial.prototype, "_diffuseTexture4", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture4", void 0);
__decorate([
  serializeAsTexture("diffuseTexture1")
], MixMaterial.prototype, "_diffuseTexture5", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture5", void 0);
__decorate([
  serializeAsTexture("diffuseTexture2")
], MixMaterial.prototype, "_diffuseTexture6", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture6", void 0);
__decorate([
  serializeAsTexture("diffuseTexture3")
], MixMaterial.prototype, "_diffuseTexture7", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture7", void 0);
__decorate([
  serializeAsTexture("diffuseTexture4")
], MixMaterial.prototype, "_diffuseTexture8", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], MixMaterial.prototype, "diffuseTexture8", void 0);
__decorate([
  serializeAsColor3()
], MixMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3()
], MixMaterial.prototype, "specularColor", void 0);
__decorate([
  serialize()
], MixMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("disableLighting")
], MixMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], MixMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], MixMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], MixMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.MixMaterial", MixMaterial);

// node_modules/@babylonjs/materials/normal/normal.fragment.js
var name16 = "normalPixelShader";
var shader15 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef LIGHTING
#include<helperFunctions>
#include<__decl__lightFragment>[0]
#include<__decl__lightFragment>[1]
#include<__decl__lightFragment>[2]
#include<__decl__lightFragment>[3]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#endif
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV);
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef NORMAL
baseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef LIGHTING
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0]
#include<lightFragment>[1]
#include<lightFragment>[2]
#include<lightFragment>[3]
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse= baseColor.rgb;
#endif
vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name16] = shader15;

// node_modules/@babylonjs/materials/normal/normal.vertex.js
var name17 = "normalVertexShader";
var shader16 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name17] = shader16;

// node_modules/@babylonjs/materials/normal/normalMaterial.js
var NormalMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LIGHT0 = false;
    this.LIGHT1 = false;
    this.LIGHT2 = false;
    this.LIGHT3 = false;
    this.SPOTLIGHT0 = false;
    this.SPOTLIGHT1 = false;
    this.SPOTLIGHT2 = false;
    this.SPOTLIGHT3 = false;
    this.HEMILIGHT0 = false;
    this.HEMILIGHT1 = false;
    this.HEMILIGHT2 = false;
    this.HEMILIGHT3 = false;
    this.DIRLIGHT0 = false;
    this.DIRLIGHT1 = false;
    this.DIRLIGHT2 = false;
    this.DIRLIGHT3 = false;
    this.POINTLIGHT0 = false;
    this.POINTLIGHT1 = false;
    this.POINTLIGHT2 = false;
    this.POINTLIGHT3 = false;
    this.SHADOW0 = false;
    this.SHADOW1 = false;
    this.SHADOW2 = false;
    this.SHADOW3 = false;
    this.SHADOWS = false;
    this.SHADOWESM0 = false;
    this.SHADOWESM1 = false;
    this.SHADOWESM2 = false;
    this.SHADOWESM3 = false;
    this.SHADOWPOISSON0 = false;
    this.SHADOWPOISSON1 = false;
    this.SHADOWPOISSON2 = false;
    this.SHADOWPOISSON3 = false;
    this.SHADOWPCF0 = false;
    this.SHADOWPCF1 = false;
    this.SHADOWPCF2 = false;
    this.SHADOWPCF3 = false;
    this.SHADOWPCSS0 = false;
    this.SHADOWPCSS1 = false;
    this.SHADOWPCSS2 = false;
    this.SHADOWPCSS3 = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.LIGHTING = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var NormalMaterial = class _NormalMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaBlendingForMesh(mesh) {
    return this.needAlphaBlending() || mesh.visibility < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new NormalMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = true;
    PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    defines.LIGHTING = !this._disableLighting;
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "normal";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant"
      ];
      const samplers = ["diffuseSampler"];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this.diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this.diffuseTexture.getTextureMatrix());
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {
      results.push(this.diffuseTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this.diffuseTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.diffuseTexture) {
      this.diffuseTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _NormalMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.NormalMaterial";
    return serializationObject;
  }
  getClassName() {
    return "NormalMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _NormalMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], NormalMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], NormalMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsColor3()
], NormalMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize("disableLighting")
], NormalMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], NormalMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], NormalMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], NormalMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.NormalMaterial", NormalMaterial);

// node_modules/@babylonjs/materials/shadowOnly/shadowOnly.fragment.js
var name18 = "shadowOnlyPixelShader";
var shader17 = `precision highp float;uniform vec4 vEyePosition;uniform float alpha;uniform vec3 shadowColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0..1]
vec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name18] = shader17;

// node_modules/@babylonjs/materials/shadowOnly/shadowOnly.vertex.js
var name19 = "shadowOnlyVertexShader";
var shader18 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name19] = shader18;

// node_modules/@babylonjs/materials/shadowOnly/shadowOnlyMaterial.js
var ShadowOnlyMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var ShadowOnlyMaterial = class _ShadowOnlyMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this._needAlphaBlending = true;
    this.shadowColor = Color3.Black();
  }
  needAlphaBlending() {
    return this._needAlphaBlending;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  get activeLight() {
    return this._activeLight;
  }
  set activeLight(light) {
    this._activeLight = light;
  }
  _getFirstShadowLightForMesh(mesh) {
    for (const light of mesh.lightSources) {
      if (light.shadowEnabled) {
        return light;
      }
    }
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    var _a;
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new ShadowOnlyMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (this._activeLight) {
      for (const light of mesh.lightSources) {
        if (light.shadowEnabled) {
          if (this._activeLight === light) {
            break;
          }
          const lightPosition = mesh.lightSources.indexOf(this._activeLight);
          if (lightPosition !== -1) {
            mesh.lightSources.splice(lightPosition, 1);
            mesh.lightSources.splice(0, 0, this._activeLight);
          }
          break;
        }
      }
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, 1);
    const shadowGenerator = (_a = this._getFirstShadowLightForMesh(mesh)) == null ? void 0 : _a.getShadowGenerator();
    this._needAlphaBlending = true;
    if (shadowGenerator && shadowGenerator.getClassName && shadowGenerator.getClassName() === "CascadedShadowGenerator") {
      const csg = shadowGenerator;
      this._needAlphaBlending = !csg.autoCalcDepthBounds;
    }
    PrepareDefinesForAttributes(mesh, defines, false, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, 1);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "shadowOnly";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "alpha",
        "shadowColor",
        "mBones",
        "logarithmicDepthConstant"
      ];
      const samplers = [];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 1
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      this._activeEffect.setFloat("alpha", this.alpha);
      this._activeEffect.setColor3("shadowColor", this.shadowColor);
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    if (scene.lightsEnabled) {
      BindLights(scene, mesh, this._activeEffect, defines, 1);
      const light = this._getFirstShadowLightForMesh(mesh);
      if (light) {
        light._renderId = -1;
      }
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || defines["SHADOWCSM0"]) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _ShadowOnlyMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.ShadowOnlyMaterial";
    return serializationObject;
  }
  getClassName() {
    return "ShadowOnlyMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);
  }
};
RegisterClass("BABYLON.ShadowOnlyMaterial", ShadowOnlyMaterial);

// node_modules/@babylonjs/materials/simple/simple.fragment.js
var name20 = "simplePixelShader";
var shader19 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV);
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif 
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name20] = shader19;

// node_modules/@babylonjs/materials/simple/simple.vertex.js
var name21 = "simpleVertexShader";
var shader20 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name21] = shader20;

// node_modules/@babylonjs/materials/simple/simpleMaterial.js
var SimpleMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var SimpleMaterial = class _SimpleMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new SimpleMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "simple";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant"
      ];
      const samplers = ["diffuseSampler"];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights - 1 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this._diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this._diffuseTexture.getTextureMatrix());
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this.diffuseTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this._diffuseTexture) {
      this._diffuseTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _SimpleMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.SimpleMaterial";
    return serializationObject;
  }
  getClassName() {
    return "SimpleMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _SimpleMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], SimpleMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], SimpleMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsColor3("diffuse")
], SimpleMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize("disableLighting")
], SimpleMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], SimpleMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], SimpleMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], SimpleMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.SimpleMaterial", SimpleMaterial);

// node_modules/@babylonjs/materials/sky/sky.fragment.js
var name22 = "skyPixelShader";
var shader21 = `precision highp float;varying vec3 vPositionW;
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneFragmentDeclaration>
uniform vec3 cameraPosition;uniform vec3 cameraOffset;uniform vec3 up;uniform float luminance;uniform float turbidity;uniform float rayleigh;uniform float mieCoefficient;uniform float mieDirectionalG;uniform vec3 sunPosition;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
const float e=2.71828182845904523536028747135266249775724709369995957;const float pi=3.141592653589793238462643383279502884197169;const float n=1.0003;const float N=2.545E25;const float pn=0.035;const vec3 lambda=vec3(680E-9,550E-9,450E-9);const vec3 K=vec3(0.686,0.678,0.666);const float v=4.0;const float rayleighZenithLength=8.4E3;const float mieZenithLength=1.25E3;const float EE=1000.0;const float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;const float cutoffAngle=pi/1.95;const float steepness=1.5;vec3 totalRayleigh(vec3 lambda)
{return (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));}
vec3 simplifiedRayleigh()
{return 0.0005/vec3(94,40,18);}
float rayleighPhase(float cosTheta)
{ 
return (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));}
vec3 totalMie(vec3 lambda,vec3 K,float T)
{float c=(0.2*T )*10E-18;return 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;}
float hgPhase(float cosTheta,float g)
{return (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));}
float sunIntensity(float zenithAngleCos)
{return EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));}
float A=0.15;float B=0.50;float C=0.10;float D=0.20;float EEE=0.02;float F=0.30;float W=1000.0;vec3 Uncharted2Tonemap(vec3 x)
{return ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;}
#if DITHER
#include<helperFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
/**
*--------------------------------------------------------------------------------------------------
* Sky Color
*--------------------------------------------------------------------------------------------------
*/
float sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);float rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));vec3 sunDirection=normalize(sunPosition);float sunE=sunIntensity(dot(sunDirection,up));vec3 betaR=simplifiedRayleigh()*rayleighCoefficient;vec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;float zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));float sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));float sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));vec3 Fex=exp(-(betaR*sR+betaM*sM));float cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);float rPhase=rayleighPhase(cosTheta*0.5+0.5);vec3 betaRTheta=betaR*rPhase;float mPhase=hgPhase(cosTheta,mieDirectionalG);vec3 betaMTheta=betaM*mPhase;vec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));Lin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));vec3 direction=normalize(vPositionW-cameraPosition);float theta=acos(direction.y);float phi=atan(direction.z,direction.x);vec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);vec3 L0=vec3(0.1)*Fex;float sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);L0+=(sunE*19000.0*Fex)*sundisk;vec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));vec3 texColor=(Lin+L0);texColor*=0.04 ;texColor+=vec3(0.0,0.001,0.0025)*0.3;float g_fMaxLuminance=1.0;float fLumScaled=0.1/luminance; 
float fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled); 
float ExposureBias=fLumCompressed;vec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);vec3 retColor=curr*whiteScale;/**
*--------------------------------------------------------------------------------------------------
* Sky Color
*--------------------------------------------------------------------------------------------------
*/
float alpha=1.0;
#ifdef VERTEXCOLOR
retColor.rgb*=vColor.rgb;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if DITHER
retColor.rgb+=dither(gl_FragCoord.xy,0.5);
#endif
vec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name22] = shader21;

// node_modules/@babylonjs/materials/sky/sky.vertex.js
var name23 = "skyVertexShader";
var shader22 = `precision highp float;attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
uniform mat4 world;uniform mat4 view;uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<logDepthDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
gl_Position=viewProjection*world*vec4(position,1.0);vec4 worldPos=world*vec4(position,1.0);vPositionW=vec3(worldPos);
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#ifdef VERTEXCOLOR
vColor=color;
#endif
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name23] = shader22;

// node_modules/@babylonjs/materials/sky/skyMaterial.js
var SkyMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.DITHER = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var SkyMaterial = class _SkyMaterial extends PushMaterial {
  /**
   * Instantiates a new sky material.
   * This material allows to create dynamic and texture free
   * effects for skyboxes by taking care of the atmosphere state.
   * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat
   * @param name Define the name of the material in the scene
   * @param scene Define the scene the material belong to
   */
  constructor(name30, scene) {
    super(name30, scene);
    this.luminance = 1;
    this.turbidity = 10;
    this.rayleigh = 2;
    this.mieCoefficient = 5e-3;
    this.mieDirectionalG = 0.8;
    this.distance = 500;
    this.inclination = 0.49;
    this.azimuth = 0.25;
    this.sunPosition = new Vector3(0, 100, 0);
    this.useSunPosition = false;
    this.cameraOffset = Vector3.Zero();
    this.up = Vector3.Up();
    this.dithering = false;
    this._cameraPosition = Vector3.Zero();
    this._skyOrientation = new Quaternion();
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    return this.alpha < 1;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns false as the sky material doesn't need alpha testing.
   */
  needAlphaTesting() {
    return false;
  }
  /**
   * Get the texture used for alpha test purpose.
   * @returns null as the sky material has no texture.
   */
  getAlphaTestTexture() {
    return null;
  }
  /**
   * Get if the submesh is ready to be used and all its information available.
   * Child classes can use it to update shaders
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new SkyMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);
    PrepareDefinesForAttributes(mesh, defines, true, false);
    if (defines.IMAGEPROCESSINGPOSTPROCESS !== scene.imageProcessingConfiguration.applyByPostProcess) {
      defines.markAsMiscDirty();
    }
    if (defines.DITHER !== this.dithering) {
      defines.markAsMiscDirty();
    }
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      defines.DITHER = this.dithering;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      const shaderName = "sky";
      const uniforms = [
        "world",
        "viewProjection",
        "view",
        "vFogInfos",
        "vFogColor",
        "logarithmicDepthConstant",
        "pointSize",
        "luminance",
        "turbidity",
        "rayleigh",
        "mieCoefficient",
        "mieDirectionalG",
        "sunPosition",
        "cameraPosition",
        "cameraOffset",
        "up"
      ];
      addClipPlaneUniforms(uniforms);
      const join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, attribs, uniforms, [], join, fallbacks, this.onCompiled, this.onError), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    if (this._mustRebind(scene, effect, subMesh)) {
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    const camera = scene.activeCamera;
    if (camera) {
      const cameraWorldMatrix = camera.getWorldMatrix();
      this._cameraPosition.x = cameraWorldMatrix.m[12];
      this._cameraPosition.y = cameraWorldMatrix.m[13];
      this._cameraPosition.z = cameraWorldMatrix.m[14];
      this._activeEffect.setVector3("cameraPosition", this._cameraPosition);
    }
    this._activeEffect.setVector3("cameraOffset", this.cameraOffset);
    this._activeEffect.setVector3("up", this.up);
    if (this.luminance > 0) {
      this._activeEffect.setFloat("luminance", this.luminance);
    }
    this._activeEffect.setFloat("turbidity", this.turbidity);
    this._activeEffect.setFloat("rayleigh", this.rayleigh);
    this._activeEffect.setFloat("mieCoefficient", this.mieCoefficient);
    this._activeEffect.setFloat("mieDirectionalG", this.mieDirectionalG);
    if (!this.useSunPosition) {
      const theta = Math.PI * (this.inclination - 0.5);
      const phi = 2 * Math.PI * (this.azimuth - 0.5);
      this.sunPosition.x = this.distance * Math.cos(phi) * Math.cos(theta);
      this.sunPosition.y = this.distance * Math.sin(-theta);
      this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);
      Quaternion.FromUnitVectorsToRef(Vector3.UpReadOnly, this.up, this._skyOrientation);
      this.sunPosition.rotateByQuaternionToRef(this._skyOrientation, this.sunPosition);
    }
    this._activeEffect.setVector3("sunPosition", this.sunPosition);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   */
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @returns the cloned material
   */
  clone(name30) {
    return SerializationHelper.Clone(() => new _SkyMaterial(name30, this.getScene()), this);
  }
  /**
   * Serializes this material in a JSON representation
   * @returns the serialized material object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.SkyMaterial";
    return serializationObject;
  }
  /**
   * Gets the current class name of the material e.g. "SkyMaterial"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "SkyMaterial";
  }
  /**
   * Creates a sky material from parsed material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new sky material
   */
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _SkyMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], SkyMaterial.prototype, "luminance", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "turbidity", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "rayleigh", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "mieCoefficient", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "mieDirectionalG", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "distance", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "inclination", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "azimuth", void 0);
__decorate([
  serializeAsVector3()
], SkyMaterial.prototype, "sunPosition", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "useSunPosition", void 0);
__decorate([
  serializeAsVector3()
], SkyMaterial.prototype, "cameraOffset", void 0);
__decorate([
  serializeAsVector3()
], SkyMaterial.prototype, "up", void 0);
__decorate([
  serialize()
], SkyMaterial.prototype, "dithering", void 0);
RegisterClass("BABYLON.SkyMaterial", SkyMaterial);

// node_modules/@babylonjs/materials/terrain/terrain.fragment.js
var name24 = "terrainPixelShader";
var shader23 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#ifdef DIFFUSE
varying vec2 vTextureUV;uniform sampler2D textureSampler;uniform vec2 vTextureInfos;uniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;
#endif
#ifdef BUMP
uniform sampler2D bump1Sampler;uniform sampler2D bump2Sampler;uniform sampler2D bump3Sampler;
#endif
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#ifdef BUMP
#extension GL_OES_standard_derivatives : enable
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));return mat3(tangent*invmax,binormal*invmax,normal);}
vec3 perturbNormal(vec3 viewDir,vec3 mixColor)
{vec3 bump1Color=texture2D(bump1Sampler,vTextureUV*diffuse1Infos).xyz;vec3 bump2Color=texture2D(bump2Sampler,vTextureUV*diffuse2Infos).xyz;vec3 bump3Color=texture2D(bump3Sampler,vTextureUV*diffuse3Infos).xyz;bump1Color.rgb*=mixColor.r;bump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);vec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);map=map*255./127.-128./127.;mat3 TBN=cotangent_frame(vNormalW*vTextureInfos.y,-viewDir,vTextureUV);return normalize(TBN*map);}
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#else
float glossiness=0.;
#endif
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef DIFFUSE
baseColor=texture2D(textureSampler,vTextureUV);
#if defined(BUMP) && defined(DIFFUSE)
normalW=perturbNormal(viewDirectionW,baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);diffuse1Color.rgb*=baseColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);baseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#else
vec3 finalSpecular=vec3(0.0);
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor*baseColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name24] = shader23;

// node_modules/@babylonjs/materials/terrain/terrain.vertex.js
var name25 = "terrainVertexShader";
var shader24 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<logDepthDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vTextureInfos.x==0.)
{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}
else
{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name25] = shader24;

// node_modules/@babylonjs/materials/terrain/terrainMaterial.js
var TerrainMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.BUMP = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.SPECULARTERM = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var TerrainMaterial = class _TerrainMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(0, 0, 0);
    this.specularPower = 64;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new TerrainMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (scene.texturesEnabled) {
      if (!this.mixTexture || !this.mixTexture.isReady()) {
        return false;
      }
      defines._needUVs = true;
      if (MaterialFlags.DiffuseTextureEnabled) {
        if (!this.diffuseTexture1 || !this.diffuseTexture1.isReady()) {
          return false;
        }
        if (!this.diffuseTexture2 || !this.diffuseTexture2.isReady()) {
          return false;
        }
        if (!this.diffuseTexture3 || !this.diffuseTexture3.isReady()) {
          return false;
        }
        defines.DIFFUSE = true;
      }
      if (this.bumpTexture1 && this.bumpTexture2 && this.bumpTexture3 && MaterialFlags.BumpTextureEnabled) {
        if (!this.bumpTexture1.isReady()) {
          return false;
        }
        if (!this.bumpTexture2.isReady()) {
          return false;
        }
        if (!this.bumpTexture3.isReady()) {
          return false;
        }
        defines._needNormals = true;
        defines.BUMP = true;
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "terrain";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vSpecularColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vTextureInfos",
        "mBones",
        "textureMatrix",
        "diffuse1Infos",
        "diffuse2Infos",
        "diffuse3Infos"
      ];
      const samplers = [
        "textureSampler",
        "diffuse1Sampler",
        "diffuse2Sampler",
        "diffuse3Sampler",
        "bump1Sampler",
        "bump2Sampler",
        "bump3Sampler",
        "logarithmicDepthConstant"
      ];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.mixTexture) {
        this._activeEffect.setTexture("textureSampler", this._mixTexture);
        this._activeEffect.setFloat2("vTextureInfos", this._mixTexture.coordinatesIndex, this._mixTexture.level);
        this._activeEffect.setMatrix("textureMatrix", this._mixTexture.getTextureMatrix());
        if (MaterialFlags.DiffuseTextureEnabled) {
          if (this._diffuseTexture1) {
            this._activeEffect.setTexture("diffuse1Sampler", this._diffuseTexture1);
            this._activeEffect.setFloat2("diffuse1Infos", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);
          }
          if (this._diffuseTexture2) {
            this._activeEffect.setTexture("diffuse2Sampler", this._diffuseTexture2);
            this._activeEffect.setFloat2("diffuse2Infos", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);
          }
          if (this._diffuseTexture3) {
            this._activeEffect.setTexture("diffuse3Sampler", this._diffuseTexture3);
            this._activeEffect.setFloat2("diffuse3Infos", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);
          }
        }
        if (MaterialFlags.BumpTextureEnabled && scene.getEngine().getCaps().standardDerivatives) {
          if (this._bumpTexture1) {
            this._activeEffect.setTexture("bump1Sampler", this._bumpTexture1);
          }
          if (this._bumpTexture2) {
            this._activeEffect.setTexture("bump2Sampler", this._bumpTexture2);
          }
          if (this._bumpTexture3) {
            this._activeEffect.setTexture("bump3Sampler", this._bumpTexture3);
          }
        }
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (defines.SPECULARTERM) {
      this._activeEffect.setColor4("vSpecularColor", this.specularColor, this.specularPower);
    }
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {
      results.push(this.mixTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._mixTexture) {
      activeTextures.push(this._mixTexture);
    }
    if (this._diffuseTexture1) {
      activeTextures.push(this._diffuseTexture1);
    }
    if (this._diffuseTexture2) {
      activeTextures.push(this._diffuseTexture2);
    }
    if (this._diffuseTexture3) {
      activeTextures.push(this._diffuseTexture3);
    }
    if (this._bumpTexture1) {
      activeTextures.push(this._bumpTexture1);
    }
    if (this._bumpTexture2) {
      activeTextures.push(this._bumpTexture2);
    }
    if (this._bumpTexture3) {
      activeTextures.push(this._bumpTexture3);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._mixTexture === texture) {
      return true;
    }
    if (this._diffuseTexture1 === texture) {
      return true;
    }
    if (this._diffuseTexture2 === texture) {
      return true;
    }
    if (this._diffuseTexture3 === texture) {
      return true;
    }
    if (this._bumpTexture1 === texture) {
      return true;
    }
    if (this._bumpTexture2 === texture) {
      return true;
    }
    if (this._bumpTexture3 === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.mixTexture) {
      this.mixTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _TerrainMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.TerrainMaterial";
    return serializationObject;
  }
  getClassName() {
    return "TerrainMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _TerrainMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("mixTexture")
], TerrainMaterial.prototype, "_mixTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "mixTexture", void 0);
__decorate([
  serializeAsTexture("diffuseTexture1")
], TerrainMaterial.prototype, "_diffuseTexture1", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "diffuseTexture1", void 0);
__decorate([
  serializeAsTexture("diffuseTexture2")
], TerrainMaterial.prototype, "_diffuseTexture2", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "diffuseTexture2", void 0);
__decorate([
  serializeAsTexture("diffuseTexture3")
], TerrainMaterial.prototype, "_diffuseTexture3", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "diffuseTexture3", void 0);
__decorate([
  serializeAsTexture("bumpTexture1")
], TerrainMaterial.prototype, "_bumpTexture1", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "bumpTexture1", void 0);
__decorate([
  serializeAsTexture("bumpTexture2")
], TerrainMaterial.prototype, "_bumpTexture2", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "bumpTexture2", void 0);
__decorate([
  serializeAsTexture("bumpTexture3")
], TerrainMaterial.prototype, "_bumpTexture3", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TerrainMaterial.prototype, "bumpTexture3", void 0);
__decorate([
  serializeAsColor3()
], TerrainMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3()
], TerrainMaterial.prototype, "specularColor", void 0);
__decorate([
  serialize()
], TerrainMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("disableLighting")
], TerrainMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], TerrainMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], TerrainMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], TerrainMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.TerrainMaterial", TerrainMaterial);

// node_modules/@babylonjs/materials/triPlanar/triplanar.fragment.js
var name26 = "triplanarPixelShader";
var shader25 = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
varying vec3 vPositionW;
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#ifdef DIFFUSEX
varying vec2 vTextureUVX;uniform sampler2D diffuseSamplerX;
#ifdef BUMPX
uniform sampler2D normalSamplerX;
#endif
#endif
#ifdef DIFFUSEY
varying vec2 vTextureUVY;uniform sampler2D diffuseSamplerY;
#ifdef BUMPY
uniform sampler2D normalSamplerY;
#endif
#endif
#ifdef DIFFUSEZ
varying vec2 vTextureUVZ;uniform sampler2D diffuseSamplerZ;
#ifdef BUMPZ
uniform sampler2D normalSamplerZ;
#endif
#endif
#ifdef NORMAL
varying mat3 tangentSpace;
#endif
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(0.,0.,0.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=tangentSpace[2];
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec4 baseNormal=vec4(0.0,0.0,0.0,1.0);normalW*=normalW;
#ifdef DIFFUSEX
baseColor+=texture2D(diffuseSamplerX,vTextureUVX)*normalW.x;
#ifdef BUMPX
baseNormal+=texture2D(normalSamplerX,vTextureUVX)*normalW.x;
#endif
#endif
#ifdef DIFFUSEY
baseColor+=texture2D(diffuseSamplerY,vTextureUVY)*normalW.y;
#ifdef BUMPY
baseNormal+=texture2D(normalSamplerY,vTextureUVY)*normalW.y;
#endif
#endif
#ifdef DIFFUSEZ
baseColor+=texture2D(diffuseSamplerZ,vTextureUVZ)*normalW.z;
#ifdef BUMPZ
baseNormal+=texture2D(normalSamplerZ,vTextureUVZ)*normalW.z;
#endif
#endif
#ifdef NORMAL
normalW=normalize((2.0*baseNormal.xyz-1.0)*tangentSpace);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;
#else
float glossiness=0.;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#else
vec3 finalSpecular=vec3(0.0);
#endif
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse+finalSpecular,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name26] = shader25;

// node_modules/@babylonjs/materials/triPlanar/triplanar.vertex.js
var name27 = "triplanarVertexShader";
var shader26 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSEX
varying vec2 vTextureUVX;
#endif
#ifdef DIFFUSEY
varying vec2 vTextureUVY;
#endif
#ifdef DIFFUSEZ
varying vec2 vTextureUVZ;
#endif
uniform float tileSize;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying mat3 tangentSpace;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef DIFFUSEX
vTextureUVX=worldPos.zy/tileSize;
#endif
#ifdef DIFFUSEY
vTextureUVY=worldPos.xz/tileSize;
#endif
#ifdef DIFFUSEZ
vTextureUVZ=worldPos.xy/tileSize;
#endif
#ifdef NORMAL
vec3 xtan=vec3(0,0,1);vec3 xbin=vec3(0,1,0);vec3 ytan=vec3(1,0,0);vec3 ybin=vec3(0,0,1);vec3 ztan=vec3(1,0,0);vec3 zbin=vec3(0,1,0);vec3 normalizedNormal=normalize(normal);normalizedNormal*=normalizedNormal;vec3 worldBinormal=normalize(xbin*normalizedNormal.x+ybin*normalizedNormal.y+zbin*normalizedNormal.z);vec3 worldTangent=normalize(xtan*normalizedNormal.x+ytan*normalizedNormal.y+ztan*normalizedNormal.z);mat3 normalWorld=mat3(finalWorld);
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
worldTangent=normalize((normalWorld*worldTangent).xyz);worldBinormal=normalize((normalWorld*worldBinormal).xyz);vec3 worldNormal=normalize((normalWorld*normalize(normal)).xyz);tangentSpace[0]=worldTangent;tangentSpace[1]=worldBinormal;tangentSpace[2]=worldNormal;
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name27] = shader26;

// node_modules/@babylonjs/materials/triPlanar/triPlanarMaterial.js
var TriPlanarMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSEX = false;
    this.DIFFUSEY = false;
    this.DIFFUSEZ = false;
    this.BUMPX = false;
    this.BUMPY = false;
    this.BUMPZ = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.SPECULARTERM = false;
    this.NORMAL = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.NONUNIFORMSCALING = false;
    this.LOGARITHMICDEPTH = false;
    this.rebuild();
  }
};
var TriPlanarMaterial = class _TriPlanarMaterial extends PushMaterial {
  constructor(name30, scene) {
    super(name30, scene);
    this.tileSize = 1;
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(0.2, 0.2, 0.2);
    this.specularPower = 64;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new TriPlanarMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (MaterialFlags.DiffuseTextureEnabled) {
          const textures = [this.diffuseTextureX, this.diffuseTextureY, this.diffuseTextureZ];
          const textureDefines = ["DIFFUSEX", "DIFFUSEY", "DIFFUSEZ"];
          for (let i = 0; i < textures.length; i++) {
            if (textures[i]) {
              if (!textures[i].isReady()) {
                return false;
              } else {
                defines[textureDefines[i]] = true;
              }
            }
          }
        }
        if (MaterialFlags.BumpTextureEnabled) {
          const textures = [this.normalTextureX, this.normalTextureY, this.normalTextureZ];
          const textureDefines = ["BUMPX", "BUMPY", "BUMPZ"];
          for (let i = 0; i < textures.length; i++) {
            if (textures[i]) {
              if (!textures[i].isReady()) {
                return false;
              } else {
                defines[textureDefines[i]] = true;
              }
            }
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "triplanar";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vSpecularColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "mBones",
        "tileSize"
      ];
      const samplers = ["diffuseSamplerX", "diffuseSamplerY", "diffuseSamplerZ", "normalSamplerX", "normalSamplerY", "normalSamplerZ", "logarithmicDepthConstant"];
      const uniformBuffers = [];
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    this._activeEffect.setFloat("tileSize", this.tileSize);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.diffuseTextureX) {
        this._activeEffect.setTexture("diffuseSamplerX", this.diffuseTextureX);
      }
      if (this.diffuseTextureY) {
        this._activeEffect.setTexture("diffuseSamplerY", this.diffuseTextureY);
      }
      if (this.diffuseTextureZ) {
        this._activeEffect.setTexture("diffuseSamplerZ", this.diffuseTextureZ);
      }
      if (this.normalTextureX) {
        this._activeEffect.setTexture("normalSamplerX", this.normalTextureX);
      }
      if (this.normalTextureY) {
        this._activeEffect.setTexture("normalSamplerY", this.normalTextureY);
      }
      if (this.normalTextureZ) {
        this._activeEffect.setTexture("normalSamplerZ", this.normalTextureZ);
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (defines.SPECULARTERM) {
      this._activeEffect.setColor4("vSpecularColor", this.specularColor, this.specularPower);
    }
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {
      results.push(this.mixTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTextureX) {
      activeTextures.push(this._diffuseTextureX);
    }
    if (this._diffuseTextureY) {
      activeTextures.push(this._diffuseTextureY);
    }
    if (this._diffuseTextureZ) {
      activeTextures.push(this._diffuseTextureZ);
    }
    if (this._normalTextureX) {
      activeTextures.push(this._normalTextureX);
    }
    if (this._normalTextureY) {
      activeTextures.push(this._normalTextureY);
    }
    if (this._normalTextureZ) {
      activeTextures.push(this._normalTextureZ);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._diffuseTextureX === texture) {
      return true;
    }
    if (this._diffuseTextureY === texture) {
      return true;
    }
    if (this._diffuseTextureZ === texture) {
      return true;
    }
    if (this._normalTextureX === texture) {
      return true;
    }
    if (this._normalTextureY === texture) {
      return true;
    }
    if (this._normalTextureZ === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.mixTexture) {
      this.mixTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _TriPlanarMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.TriPlanarMaterial";
    return serializationObject;
  }
  getClassName() {
    return "TriPlanarMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _TriPlanarMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture()
], TriPlanarMaterial.prototype, "mixTexture", void 0);
__decorate([
  serializeAsTexture("diffuseTextureX")
], TriPlanarMaterial.prototype, "_diffuseTextureX", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "diffuseTextureX", void 0);
__decorate([
  serializeAsTexture("diffuseTexturY")
], TriPlanarMaterial.prototype, "_diffuseTextureY", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "diffuseTextureY", void 0);
__decorate([
  serializeAsTexture("diffuseTextureZ")
], TriPlanarMaterial.prototype, "_diffuseTextureZ", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "diffuseTextureZ", void 0);
__decorate([
  serializeAsTexture("normalTextureX")
], TriPlanarMaterial.prototype, "_normalTextureX", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "normalTextureX", void 0);
__decorate([
  serializeAsTexture("normalTextureY")
], TriPlanarMaterial.prototype, "_normalTextureY", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "normalTextureY", void 0);
__decorate([
  serializeAsTexture("normalTextureZ")
], TriPlanarMaterial.prototype, "_normalTextureZ", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], TriPlanarMaterial.prototype, "normalTextureZ", void 0);
__decorate([
  serialize()
], TriPlanarMaterial.prototype, "tileSize", void 0);
__decorate([
  serializeAsColor3()
], TriPlanarMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3()
], TriPlanarMaterial.prototype, "specularColor", void 0);
__decorate([
  serialize()
], TriPlanarMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("disableLighting")
], TriPlanarMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], TriPlanarMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], TriPlanarMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], TriPlanarMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.TriPlanarMaterial", TriPlanarMaterial);

// node_modules/@babylonjs/materials/water/water.fragment.js
var name28 = "waterPixelShader";
var shader27 = `#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<helperFunctions>
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#ifdef BUMP
varying vec2 vNormalUV;
#ifdef BUMPSUPERIMPOSE
varying vec2 vNormalUV2;
#endif
uniform sampler2D normalSampler;uniform vec2 vNormalInfos;
#endif
uniform sampler2D refractionSampler;uniform sampler2D reflectionSampler;const float LOG2=1.442695;uniform vec3 cameraPosition;uniform vec4 waterColor;uniform float colorBlendFactor;uniform vec4 waterColor2;uniform float colorBlendFactor2;uniform float bumpHeight;uniform float time;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef BUMP
#ifdef BUMPSUPERIMPOSE
baseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));
#else
baseColor=texture2D(normalSampler,vNormalUV);
#endif
vec3 bumpColor=baseColor.rgb;
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
baseColor.rgb*=vNormalInfos.y;
#else
vec3 bumpColor=vec3(1.0);
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef NORMAL
vec2 perturbation=bumpHeight*(baseColor.rg-0.5);
#ifdef BUMPAFFECTSREFLECTION
vec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));if (normalW.y<0.0) {normalW.y=-normalW.y;}
#else
vec3 normalW=normalize(vNormalW);
#endif
#else
vec3 normalW=vec3(1.0,1.0,1.0);vec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);
#endif
#ifdef FRESNELSEPARATE
#ifdef REFLECTION
vec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);
#ifdef IS_REFRACTION_LINEAR
refractiveColor.rgb=toGammaSpace(refractiveColor.rgb);
#endif
vec2 projectedReflectionTexCoords=clamp(vec2(
vReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,
vReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y
),0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);
#ifdef IS_REFLECTION_LINEAR
reflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);
#endif
vec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);float IfresnelTerm=1.0-fresnelTerm;refractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;reflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;baseColor=combinedColor;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;
#else
float glossiness=0.;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#else
vec3 finalSpecular=vec3(0.0);
#endif
#else 
#ifdef REFLECTION
vec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);
#ifdef IS_REFRACTION_LINEAR
refractiveColor.rgb=toGammaSpace(refractiveColor.rgb);
#endif
vec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);
#ifdef IS_REFLECTION_LINEAR
reflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);
#endif
vec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=max(dot(viewDirectionW,upVector),0.0);vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);baseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;
#else
float glossiness=0.;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#else
vec3 finalSpecular=vec3(0.0);
#endif
#endif
vec4 color=vec4(finalDiffuse+finalSpecular,alpha);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#elif defined(IMAGEPROCESSING)
color.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);
#endif
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name28] = shader27;

// node_modules/@babylonjs/materials/water/water.vertex.js
var name29 = "waterVertexShader";
var shader28 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef BUMP
varying vec2 vNormalUV;
#ifdef BUMPSUPERIMPOSE
varying vec2 vNormalUV2;
#endif
uniform mat4 normalMatrix;uniform vec2 vNormalInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<logDepthDeclaration>
uniform mat4 reflectionViewProjection;uniform vec2 windDirection;uniform float waveLength;uniform float time;uniform float windForce;uniform float waveHeight;uniform float waveSpeed;uniform float waveCount;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef BUMP
if (vNormalInfos.x==0.)
{vNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));
#ifdef BUMPSUPERIMPOSE
vNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));
#endif
}
else
{vNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));
#ifdef BUMPSUPERIMPOSE
vNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));
#endif
}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
float finalWaveCount=1.0/(waveCount*0.5);
#ifdef USE_WORLD_COORDINATES
vec3 p=worldPos.xyz;
#else
vec3 p=position;
#endif
float newY=(sin(((p.x/finalWaveCount)+time*waveSpeed))*waveHeight*windDirection.x*5.0)
+ (cos(((p.z/finalWaveCount)+ time*waveSpeed))*waveHeight*windDirection.y*5.0);p.y+=abs(newY);
#ifdef USE_WORLD_COORDINATES
gl_Position=viewProjection*vec4(p,1.0);
#else
gl_Position=viewProjection*finalWorld*vec4(p,1.0);
#endif
#ifdef REFLECTION
vRefractionMapTexCoord.x=0.5*(gl_Position.w+gl_Position.x);vRefractionMapTexCoord.y=0.5*(gl_Position.w+gl_Position.y);vRefractionMapTexCoord.z=gl_Position.w;worldPos=reflectionViewProjection*finalWorld*vec4(position,1.0);vReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);vReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);vReflectionMapTexCoord.z=worldPos.w;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name29] = shader28;

// node_modules/@babylonjs/materials/water/waterMaterial.js
var WaterMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.BUMP = false;
    this.REFLECTION = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.SPECULARTERM = false;
    this.LOGARITHMICDEPTH = false;
    this.USE_REVERSE_DEPTHBUFFER = false;
    this.FRESNELSEPARATE = false;
    this.BUMPSUPERIMPOSE = false;
    this.BUMPAFFECTSREFLECTION = false;
    this.USE_WORLD_COORDINATES = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.EXPOSURE = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.rebuild();
  }
};
var WaterMaterial = class _WaterMaterial extends PushMaterial {
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    return true;
  }
  /**
   * Constructor
   * @param name
   * @param scene
   * @param renderTargetSize
   */
  constructor(name30, scene, renderTargetSize = new Vector2(512, 512)) {
    super(name30, scene);
    this.renderTargetSize = renderTargetSize;
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(0, 0, 0);
    this.specularPower = 64;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this.windForce = 6;
    this.windDirection = new Vector2(0, 1);
    this.waveHeight = 0.4;
    this.bumpHeight = 0.4;
    this._bumpSuperimpose = false;
    this._fresnelSeparate = false;
    this._bumpAffectsReflection = false;
    this.waterColor = new Color3(0.1, 0.1, 0.6);
    this.colorBlendFactor = 0.2;
    this.waterColor2 = new Color3(0.1, 0.1, 0.6);
    this.colorBlendFactor2 = 0.2;
    this.waveLength = 0.1;
    this.waveSpeed = 1;
    this.waveCount = 20;
    this.disableClipPlane = false;
    this._useWorldCoordinatesForWaveDeformation = false;
    this._renderTargets = new SmartArray(16);
    this._mesh = null;
    this._reflectionTransform = Matrix.Zero();
    this._lastTime = 0;
    this._lastDeltaTime = 0;
    this._createRenderTargets(this.getScene(), renderTargetSize);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      this._renderTargets.push(this._reflectionRTT);
      this._renderTargets.push(this._refractionRTT);
      return this._renderTargets;
    };
    this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  // Get / Set
  get refractionTexture() {
    return this._refractionRTT;
  }
  get reflectionTexture() {
    return this._reflectionRTT;
  }
  // Methods
  addToRenderList(node) {
    if (this._refractionRTT && this._refractionRTT.renderList) {
      this._refractionRTT.renderList.push(node);
    }
    if (this._reflectionRTT && this._reflectionRTT.renderList) {
      this._reflectionRTT.renderList.push(node);
    }
  }
  removeFromRenderList(node) {
    if (this._refractionRTT && this._refractionRTT.renderList) {
      const idx = this._refractionRTT.renderList.indexOf(node);
      if (idx !== -1) {
        this._refractionRTT.renderList.splice(idx, 1);
      }
    }
    if (this._reflectionRTT && this._reflectionRTT.renderList) {
      const idx = this._reflectionRTT.renderList.indexOf(node);
      if (idx !== -1) {
        this._reflectionRTT.renderList.splice(idx, 1);
      }
    }
  }
  enableRenderTargets(enable) {
    const refreshRate = enable ? 1 : 0;
    if (this._refractionRTT) {
      this._refractionRTT.refreshRate = refreshRate;
    }
    if (this._reflectionRTT) {
      this._reflectionRTT.refreshRate = refreshRate;
    }
  }
  getRenderList() {
    return this._refractionRTT ? this._refractionRTT.renderList : [];
  }
  get renderTargetsEnabled() {
    return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new WaterMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {
          if (!this.bumpTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.BUMP = true;
          }
        }
        if (MaterialFlags.ReflectionTextureEnabled) {
          defines.REFLECTION = true;
        }
      }
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    if (defines._areMiscDirty) {
      defines.FRESNELSEPARATE = this._fresnelSeparate;
      defines.BUMPSUPERIMPOSE = this._bumpSuperimpose;
      defines.BUMPAFFECTSREFLECTION = this._bumpAffectsReflection;
      defines.USE_WORLD_COORDINATES = this._useWorldCoordinatesForWaveDeformation;
    }
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    PrepareDefinesForAttributes(mesh, defines, true, true);
    this._mesh = mesh;
    if (this._waitingRenderList) {
      for (let i = 0; i < this._waitingRenderList.length; i++) {
        this.addToRenderList(scene.getNodeById(this._waitingRenderList[i]));
      }
      this._waitingRenderList = null;
    }
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.LOGARITHMICDEPTH) {
        fallbacks.addFallback(0, "LOGARITHMICDEPTH");
      }
      HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "water";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vSpecularColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vNormalInfos",
        "mBones",
        "normalMatrix",
        "logarithmicDepthConstant",
        // Water
        "reflectionViewProjection",
        "windDirection",
        "waveLength",
        "time",
        "windForce",
        "cameraPosition",
        "bumpHeight",
        "waveHeight",
        "waterColor",
        "waterColor2",
        "colorBlendFactor",
        "colorBlendFactor2",
        "waveSpeed",
        "waveCount"
      ];
      const samplers = [
        "normalSampler",
        // Water
        "refractionSampler",
        "reflectionSampler"
      ];
      const uniformBuffers = [];
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      addClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this.maxSimultaneousLights
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect || !this._mesh) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {
        this._activeEffect.setTexture("normalSampler", this.bumpTexture);
        this._activeEffect.setFloat2("vNormalInfos", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);
        this._activeEffect.setMatrix("normalMatrix", this.bumpTexture.getTextureMatrix());
      }
      bindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (defines.SPECULARTERM) {
      this._activeEffect.setColor4("vSpecularColor", this.specularColor, this.specularPower);
    }
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    BindLogDepth(defines, this._activeEffect, scene);
    if (MaterialFlags.ReflectionTextureEnabled) {
      this._activeEffect.setTexture("refractionSampler", this._refractionRTT);
      this._activeEffect.setTexture("reflectionSampler", this._reflectionRTT);
    }
    const wrvp = this._reflectionTransform.multiply(scene.getProjectionMatrix());
    const deltaTime = scene.getEngine().getDeltaTime();
    if (deltaTime !== this._lastDeltaTime) {
      this._lastDeltaTime = deltaTime;
      this._lastTime += this._lastDeltaTime;
    }
    this._activeEffect.setMatrix("reflectionViewProjection", wrvp);
    this._activeEffect.setVector2("windDirection", this.windDirection);
    this._activeEffect.setFloat("waveLength", this.waveLength);
    this._activeEffect.setFloat("time", this._lastTime / 1e5);
    this._activeEffect.setFloat("windForce", this.windForce);
    this._activeEffect.setFloat("waveHeight", this.waveHeight);
    this._activeEffect.setFloat("bumpHeight", this.bumpHeight);
    this._activeEffect.setColor4("waterColor", this.waterColor, 1);
    this._activeEffect.setFloat("colorBlendFactor", this.colorBlendFactor);
    this._activeEffect.setColor4("waterColor2", this.waterColor2, 1);
    this._activeEffect.setFloat("colorBlendFactor2", this.colorBlendFactor2);
    this._activeEffect.setFloat("waveSpeed", this.waveSpeed);
    this._activeEffect.setFloat("waveCount", this.waveCount);
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(this._activeEffect);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  _createRenderTargets(scene, renderTargetSize) {
    this._refractionRTT = new RenderTargetTexture(name + "_refraction", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);
    this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    this._refractionRTT.ignoreCameraViewport = true;
    this._reflectionRTT = new RenderTargetTexture(name + "_reflection", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);
    this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    this._reflectionRTT.ignoreCameraViewport = true;
    let isVisible;
    let clipPlane = null;
    let savedViewMatrix;
    const mirrorMatrix = Matrix.Zero();
    this._refractionRTT.onBeforeRender = () => {
      if (this._mesh) {
        isVisible = this._mesh.isVisible;
        this._mesh.isVisible = false;
      }
      if (!this.disableClipPlane) {
        clipPlane = scene.clipPlane;
        const positiony = this._mesh ? this._mesh.absolutePosition.y : 0;
        scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));
      }
    };
    this._refractionRTT.onAfterRender = () => {
      if (this._mesh) {
        this._mesh.isVisible = isVisible;
      }
      if (!this.disableClipPlane) {
        scene.clipPlane = clipPlane;
      }
    };
    this._reflectionRTT.onBeforeRender = () => {
      if (this._mesh) {
        isVisible = this._mesh.isVisible;
        this._mesh.isVisible = false;
      }
      if (!this.disableClipPlane) {
        clipPlane = scene.clipPlane;
        const positiony = this._mesh ? this._mesh.absolutePosition.y : 0;
        scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));
        Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);
      }
      savedViewMatrix = scene.getViewMatrix();
      mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);
      scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());
      scene._mirroredCameraPosition = Vector3.TransformCoordinates(scene.activeCamera.position, mirrorMatrix);
    };
    this._reflectionRTT.onAfterRender = () => {
      if (this._mesh) {
        this._mesh.isVisible = isVisible;
      }
      scene.clipPlane = clipPlane;
      scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());
      scene._mirroredCameraPosition = null;
    };
  }
  getAnimatables() {
    const results = [];
    if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {
      results.push(this.bumpTexture);
    }
    if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {
      results.push(this._reflectionRTT);
    }
    if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {
      results.push(this._refractionRTT);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.bumpTexture) {
      this.bumpTexture.dispose();
    }
    let index = this.getScene().customRenderTargets.indexOf(this._refractionRTT);
    if (index != -1) {
      this.getScene().customRenderTargets.splice(index, 1);
    }
    index = -1;
    index = this.getScene().customRenderTargets.indexOf(this._reflectionRTT);
    if (index != -1) {
      this.getScene().customRenderTargets.splice(index, 1);
    }
    if (this._reflectionRTT) {
      this._reflectionRTT.dispose();
    }
    if (this._refractionRTT) {
      this._refractionRTT.dispose();
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name30) {
    return SerializationHelper.Clone(() => new _WaterMaterial(name30, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.WaterMaterial";
    serializationObject.renderList = [];
    if (this._refractionRTT && this._refractionRTT.renderList) {
      for (let i = 0; i < this._refractionRTT.renderList.length; i++) {
        serializationObject.renderList.push(this._refractionRTT.renderList[i].id);
      }
    }
    return serializationObject;
  }
  getClassName() {
    return "WaterMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    const mat = SerializationHelper.Parse(() => new _WaterMaterial(source.name, scene), source, scene, rootUrl);
    mat._waitingRenderList = source.renderList;
    return mat;
  }
  static CreateDefaultMesh(name30, scene) {
    const mesh = CreateGround(name30, { width: 512, height: 512, subdivisions: 32, updatable: false }, scene);
    return mesh;
  }
};
__decorate([
  serializeAsTexture("bumpTexture")
], WaterMaterial.prototype, "_bumpTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], WaterMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsColor3()
], WaterMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3()
], WaterMaterial.prototype, "specularColor", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("disableLighting")
], WaterMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], WaterMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], WaterMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], WaterMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "windForce", void 0);
__decorate([
  serializeAsVector2()
], WaterMaterial.prototype, "windDirection", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "waveHeight", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "bumpHeight", void 0);
__decorate([
  serialize("bumpSuperimpose")
], WaterMaterial.prototype, "_bumpSuperimpose", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], WaterMaterial.prototype, "bumpSuperimpose", void 0);
__decorate([
  serialize("fresnelSeparate")
], WaterMaterial.prototype, "_fresnelSeparate", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], WaterMaterial.prototype, "fresnelSeparate", void 0);
__decorate([
  serialize("bumpAffectsReflection")
], WaterMaterial.prototype, "_bumpAffectsReflection", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], WaterMaterial.prototype, "bumpAffectsReflection", void 0);
__decorate([
  serializeAsColor3()
], WaterMaterial.prototype, "waterColor", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "colorBlendFactor", void 0);
__decorate([
  serializeAsColor3()
], WaterMaterial.prototype, "waterColor2", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "colorBlendFactor2", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "waveLength", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "waveSpeed", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "waveCount", void 0);
__decorate([
  serialize()
], WaterMaterial.prototype, "disableClipPlane", void 0);
__decorate([
  serialize("useWorldCoordinatesForWaveDeformation")
], WaterMaterial.prototype, "_useWorldCoordinatesForWaveDeformation", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], WaterMaterial.prototype, "useWorldCoordinatesForWaveDeformation", void 0);
RegisterClass("BABYLON.WaterMaterial", WaterMaterial);
export {
  CellMaterial,
  CustomMaterial,
  CustomShaderStructure,
  FireMaterial,
  FurMaterial,
  GradientMaterial,
  GridMaterial,
  LavaMaterial,
  MixMaterial,
  NormalMaterial,
  PBRCustomMaterial,
  ShaderAlbedoParts,
  ShaderAlebdoParts,
  ShaderSpecialParts,
  ShadowOnlyMaterial,
  SimpleMaterial,
  SkyMaterial,
  TerrainMaterial,
  TriPlanarMaterial,
  WaterMaterial
};
//# sourceMappingURL=@babylonjs_materials.js.map
