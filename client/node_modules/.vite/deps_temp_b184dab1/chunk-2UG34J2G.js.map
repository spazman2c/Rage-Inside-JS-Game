{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/codeStringParsingTools.ts", "../../../dev/core/src/Engines/Processors/shaderCodeInliner.ts", "../../../dev/core/src/Shaders/ShadersInclude/imageProcessingCompatibility.ts"],
  "sourcesContent": ["/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            Logger.Log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    Logger.Warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingCompatibility\";\nconst shader = `#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingCompatibility = { name, shader };\n"],
  "mappings": "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",
  "names": ["name", "parameters"]
}
