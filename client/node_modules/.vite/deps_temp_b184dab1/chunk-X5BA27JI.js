import {
  BindBonesParameters,
  BindFogParameters,
  BindLogDepth,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  Color3,
  Color4,
  EffectFallbacks,
  Engine,
  EngineStore,
  ErrorCodes,
  GetClass,
  IsBase64DataUrl,
  LightConstants,
  Logger,
  Matrix,
  Node,
  Observable,
  PrepareAttributesForBakedVertexAnimation,
  PushAttributesForInstances,
  PushMaterial,
  Quaternion,
  RandomGUID,
  RegisterClass,
  RuntimeError,
  Scalar,
  Scene,
  SceneLoaderFlags,
  SerializationHelper,
  Size,
  Tags,
  Texture,
  TmpColors,
  TmpVectors,
  Tools,
  UniformBuffer,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  WebRequest,
  __decorate,
  addClipPlaneUniforms,
  bindClipPlane,
  expandToProperty,
  prepareStringDefinesForClipPlanes,
  serialize,
  serializeAsColor3,
  serializeAsVector3
} from "./chunk-5XB6PROF.js";

// node_modules/@babylonjs/core/Animations/animationKey.js
var AnimationKeyInterpolation;
(function(AnimationKeyInterpolation2) {
  AnimationKeyInterpolation2[AnimationKeyInterpolation2["NONE"] = 0] = "NONE";
  AnimationKeyInterpolation2[AnimationKeyInterpolation2["STEP"] = 1] = "STEP";
})(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange = class _AnimationRange {
  /**
   * Initializes the range of an animation
   * @param name The name of the animation range
   * @param from The starting frame of the animation
   * @param to The ending frame of the animation
   */
  constructor(name, from, to) {
    this.name = name;
    this.from = from;
    this.to = to;
  }
  /**
   * Makes a copy of the animation range
   * @returns A copy of the animation range
   */
  clone() {
    return new _AnimationRange(this.name, this.from, this.to);
  }
};

// node_modules/@babylonjs/core/Animations/animation.js
var _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));
var _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());
var _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());
var _staticOffsetValueSize = Object.freeze(Size.Zero());
var _staticOffsetValueColor3 = Object.freeze(Color3.Black());
var _staticOffsetValueColor4 = Object.freeze(new Color4(0, 0, 0, 0));
var evaluateAnimationState = {
  key: 0,
  repeatCount: 0,
  loopMode: 2
};
var Animation = class _Animation {
  /**
   * @internal Internal use
   */
  static _PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
    let dataType = void 0;
    if (!isNaN(parseFloat(from)) && isFinite(from)) {
      dataType = _Animation.ANIMATIONTYPE_FLOAT;
    } else if (from instanceof Quaternion) {
      dataType = _Animation.ANIMATIONTYPE_QUATERNION;
    } else if (from instanceof Vector3) {
      dataType = _Animation.ANIMATIONTYPE_VECTOR3;
    } else if (from instanceof Vector2) {
      dataType = _Animation.ANIMATIONTYPE_VECTOR2;
    } else if (from instanceof Color3) {
      dataType = _Animation.ANIMATIONTYPE_COLOR3;
    } else if (from instanceof Color4) {
      dataType = _Animation.ANIMATIONTYPE_COLOR4;
    } else if (from instanceof Size) {
      dataType = _Animation.ANIMATIONTYPE_SIZE;
    }
    if (dataType == void 0) {
      return null;
    }
    const animation = new _Animation(name, targetProperty, framePerSecond, dataType, loopMode);
    const keys = [
      { frame: 0, value: from },
      { frame: totalFrame, value: to }
    ];
    animation.setKeys(keys);
    if (easingFunction !== void 0) {
      animation.setEasingFunction(easingFunction);
    }
    return animation;
  }
  /**
   * Sets up an animation
   * @param property The property to animate
   * @param animationType The animation type to apply
   * @param framePerSecond The frames per second of the animation
   * @param easingFunction The easing function used in the animation
   * @returns The created animation
   */
  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {
    const animation = new _Animation(property + "Animation", property, framePerSecond, animationType, _Animation.ANIMATIONLOOPMODE_CONSTANT);
    animation.setEasingFunction(easingFunction);
    return animation;
  }
  /**
   * Create and start an animation on a node
   * @param name defines the name of the global animation that will be run on all nodes
   * @param target defines the target where the animation will take place
   * @param targetProperty defines property to animate
   * @param framePerSecond defines the number of frame per second yo use
   * @param totalFrame defines the number of frames in total
   * @param from defines the initial value
   * @param to defines the final value
   * @param loopMode defines which loop mode you want to use (off by default)
   * @param easingFunction defines the easing function to use (linear by default)
   * @param onAnimationEnd defines the callback to call when animation end
   * @param scene defines the hosting scene
   * @returns the animatable created for this animation
   */
  static CreateAndStartAnimation(name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    if (target.getScene) {
      scene = target.getScene();
    }
    if (!scene) {
      return null;
    }
    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  /**
   * Create and start an animation on a node and its descendants
   * @param name defines the name of the global animation that will be run on all nodes
   * @param node defines the root node where the animation will take place
   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used
   * @param targetProperty defines property to animate
   * @param framePerSecond defines the number of frame per second to use
   * @param totalFrame defines the number of frames in total
   * @param from defines the initial value
   * @param to defines the final value
   * @param loopMode defines which loop mode you want to use (off by default)
   * @param easingFunction defines the easing function to use (linear by default)
   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)
   * @returns the list of animatables created for all nodes
   * @example https://www.babylonjs-playground.com/#MH0VLI
   */
  static CreateAndStartHierarchyAnimation(name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    const scene = node.getScene();
    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  /**
   * Creates a new animation, merges it with the existing animations and starts it
   * @param name Name of the animation
   * @param node Node which contains the scene that begins the animations
   * @param targetProperty Specifies which property to animate
   * @param framePerSecond The frames per second of the animation
   * @param totalFrame The total number of frames
   * @param from The frame at the beginning of the animation
   * @param to The frame at the end of the animation
   * @param loopMode Specifies the loop mode of the animation
   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations
   * @param onAnimationEnd Callback to run once the animation is complete
   * @returns Nullable animation
   */
  static CreateMergeAndStartAnimation(name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
    const animation = _Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
    if (!animation) {
      return null;
    }
    node.animations.push(animation);
    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
  }
  /** @internal */
  static MakeAnimationAdditive(sourceAnimation, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {
    let options;
    if (typeof referenceFrameOrOptions === "object") {
      options = referenceFrameOrOptions;
    } else {
      options = {
        referenceFrame: referenceFrameOrOptions ?? 0,
        range,
        cloneOriginalAnimation: cloneOriginal,
        clonedAnimationName: clonedName
      };
    }
    let animation = sourceAnimation;
    if (options.cloneOriginalAnimation) {
      animation = sourceAnimation.clone();
      animation.name = options.clonedAnimationName || animation.name;
    }
    if (!animation._keys.length) {
      return animation;
    }
    const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;
    let startIndex = 0;
    const firstKey = animation._keys[0];
    let endIndex = animation._keys.length - 1;
    const lastKey = animation._keys[endIndex];
    const valueStore = {
      referenceValue: firstKey.value,
      referencePosition: TmpVectors.Vector3[0],
      referenceQuaternion: TmpVectors.Quaternion[0],
      referenceScaling: TmpVectors.Vector3[1],
      keyPosition: TmpVectors.Vector3[2],
      keyQuaternion: TmpVectors.Quaternion[1],
      keyScaling: TmpVectors.Vector3[3]
    };
    let from = firstKey.frame;
    let to = lastKey.frame;
    if (options.range) {
      const rangeValue = animation.getRange(options.range);
      if (rangeValue) {
        from = rangeValue.from;
        to = rangeValue.to;
      }
    } else {
      from = options.fromFrame ?? from;
      to = options.toFrame ?? to;
    }
    if (from !== firstKey.frame) {
      startIndex = animation.createKeyForFrame(from);
    }
    if (to !== lastKey.frame) {
      endIndex = animation.createKeyForFrame(to);
    }
    if (animation._keys.length === 1) {
      const value = animation._getKeyValue(animation._keys[0]);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else if (referenceFrame <= firstKey.frame) {
      const value = animation._getKeyValue(firstKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else if (referenceFrame >= lastKey.frame) {
      const value = animation._getKeyValue(lastKey.value);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    } else {
      evaluateAnimationState.key = 0;
      const value = animation._interpolate(referenceFrame, evaluateAnimationState);
      valueStore.referenceValue = value.clone ? value.clone() : value;
    }
    if (animation.dataType === _Animation.ANIMATIONTYPE_QUATERNION) {
      valueStore.referenceValue.normalize().conjugateInPlace();
    } else if (animation.dataType === _Animation.ANIMATIONTYPE_MATRIX) {
      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
      valueStore.referenceQuaternion.normalize().conjugateInPlace();
    }
    let startFrame = Number.MAX_VALUE;
    const clippedKeys = options.clipKeys ? [] : null;
    for (let index = startIndex; index <= endIndex; index++) {
      let key = animation._keys[index];
      if (clippedKeys) {
        key = {
          frame: key.frame,
          value: key.value.clone ? key.value.clone() : key.value,
          inTangent: key.inTangent,
          outTangent: key.outTangent,
          interpolation: key.interpolation,
          lockedTangent: key.lockedTangent
        };
        if (startFrame === Number.MAX_VALUE) {
          startFrame = key.frame;
        }
        key.frame -= startFrame;
        clippedKeys.push(key);
      }
      if (index && animation.dataType !== _Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
        continue;
      }
      switch (animation.dataType) {
        case _Animation.ANIMATIONTYPE_MATRIX:
          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
          valueStore.referenceValue.multiplyToRef(key.value, key.value);
          break;
        case _Animation.ANIMATIONTYPE_VECTOR2:
        case _Animation.ANIMATIONTYPE_VECTOR3:
        case _Animation.ANIMATIONTYPE_COLOR3:
        case _Animation.ANIMATIONTYPE_COLOR4:
          key.value.subtractToRef(valueStore.referenceValue, key.value);
          break;
        case _Animation.ANIMATIONTYPE_SIZE:
          key.value.width -= valueStore.referenceValue.width;
          key.value.height -= valueStore.referenceValue.height;
          break;
        default:
          key.value -= valueStore.referenceValue;
      }
    }
    if (clippedKeys) {
      animation.setKeys(clippedKeys, true);
    }
    return animation;
  }
  /**
   * Transition property of an host to the target Value
   * @param property The property to transition
   * @param targetValue The target Value of the property
   * @param host The object where the property to animate belongs
   * @param scene Scene used to run the animation
   * @param frameRate Framerate (in frame/s) to use
   * @param transition The transition type we want to use
   * @param duration The duration of the animation, in milliseconds
   * @param onAnimationEnd Callback trigger at the end of the animation
   * @returns Nullable animation
   */
  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {
    if (duration <= 0) {
      host[property] = targetValue;
      if (onAnimationEnd) {
        onAnimationEnd();
      }
      return null;
    }
    const endFrame = frameRate * (duration / 1e3);
    transition.setKeys([
      {
        frame: 0,
        value: host[property].clone ? host[property].clone() : host[property]
      },
      {
        frame: endFrame,
        value: targetValue
      }
    ]);
    if (!host.animations) {
      host.animations = [];
    }
    host.animations.push(transition);
    const animation = scene.beginAnimation(host, 0, endFrame, false);
    animation.onAnimationEnd = onAnimationEnd;
    return animation;
  }
  /**
   * Return the array of runtime animations currently using this animation
   */
  get runtimeAnimations() {
    return this._runtimeAnimations;
  }
  /**
   * Specifies if any of the runtime animations are currently running
   */
  get hasRunningRuntimeAnimations() {
    for (const runtimeAnimation of this._runtimeAnimations) {
      if (!runtimeAnimation.isStopped()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Initializes the animation
   * @param name Name of the animation
   * @param targetProperty Property to animate
   * @param framePerSecond The frames per second of the animation
   * @param dataType The data type of the animation
   * @param loopMode The loop mode of the animation
   * @param enableBlending Specifies if blending should be enabled
   */
  constructor(name, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
    this.name = name;
    this.targetProperty = targetProperty;
    this.framePerSecond = framePerSecond;
    this.dataType = dataType;
    this.loopMode = loopMode;
    this.enableBlending = enableBlending;
    this._easingFunction = null;
    this._runtimeAnimations = new Array();
    this._events = new Array();
    this.blendingSpeed = 0.01;
    this._ranges = {};
    this.targetPropertyPath = targetProperty.split(".");
    this.dataType = dataType;
    this.loopMode = loopMode === void 0 ? _Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;
    this.uniqueId = _Animation._UniqueIdGenerator++;
  }
  // Methods
  /**
   * Converts the animation to a string
   * @param fullDetails support for multiple levels of logging within scene loading
   * @returns String form of the animation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", property: " + this.targetProperty;
    ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
    ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
    ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
    if (fullDetails) {
      ret += ", Ranges: {";
      let first = true;
      for (const name in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name;
      }
      ret += "}";
    }
    return ret;
  }
  /**
   * Add an event to this animation
   * @param event Event to add
   */
  addEvent(event) {
    this._events.push(event);
    this._events.sort((a, b) => a.frame - b.frame);
  }
  /**
   * Remove all events found at the given frame
   * @param frame The frame to remove events from
   */
  removeEvents(frame) {
    for (let index = 0; index < this._events.length; index++) {
      if (this._events[index].frame === frame) {
        this._events.splice(index, 1);
        index--;
      }
    }
  }
  /**
   * Retrieves all the events from the animation
   * @returns Events from the animation
   */
  getEvents() {
    return this._events;
  }
  /**
   * Creates an animation range
   * @param name Name of the animation range
   * @param from Starting frame of the animation range
   * @param to Ending frame of the animation
   */
  createRange(name, from, to) {
    if (!this._ranges[name]) {
      this._ranges[name] = new AnimationRange(name, from, to);
    }
  }
  /**
   * Deletes an animation range by name
   * @param name Name of the animation range to delete
   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)
   */
  deleteRange(name, deleteFrames = true) {
    const range = this._ranges[name];
    if (!range) {
      return;
    }
    if (deleteFrames) {
      const from = range.from;
      const to = range.to;
      for (let key = this._keys.length - 1; key >= 0; key--) {
        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
          this._keys.splice(key, 1);
        }
      }
    }
    this._ranges[name] = null;
  }
  /**
   * Gets the animation range by name, or null if not defined
   * @param name Name of the animation range
   * @returns Nullable animation range
   */
  getRange(name) {
    return this._ranges[name];
  }
  /**
   * Gets the key frames from the animation
   * @returns The key frames of the animation
   */
  getKeys() {
    return this._keys;
  }
  /**
   * Gets the highest frame rate of the animation
   * @returns Highest frame rate of the animation
   */
  getHighestFrame() {
    let ret = 0;
    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {
      if (ret < this._keys[key].frame) {
        ret = this._keys[key].frame;
      }
    }
    return ret;
  }
  /**
   * Gets the easing function of the animation
   * @returns Easing function of the animation
   */
  getEasingFunction() {
    return this._easingFunction;
  }
  /**
   * Sets the easing function of the animation
   * @param easingFunction A custom mathematical formula for animation
   */
  setEasingFunction(easingFunction) {
    this._easingFunction = easingFunction;
  }
  /**
   * Interpolates a scalar linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated scalar value
   */
  floatInterpolateFunction(startValue, endValue, gradient) {
    return Scalar.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a scalar cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated scalar value
   */
  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a quaternion using a spherical linear interpolation
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated quaternion value
   */
  quaternionInterpolateFunction(startValue, endValue, gradient) {
    return Quaternion.Slerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a quaternion cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation curve
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated quaternion value
   */
  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
  }
  /**
   * Interpolates a Vector3 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated scalar value
   */
  vector3InterpolateFunction(startValue, endValue, gradient) {
    return Vector3.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Vector3 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns InterpolatedVector3 value
   */
  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a Vector2 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated Vector2 value
   */
  vector2InterpolateFunction(startValue, endValue, gradient) {
    return Vector2.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Vector2 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate (value between 0 and 1)
   * @returns Interpolated Vector2 value
   */
  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a size linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Size value
   */
  sizeInterpolateFunction(startValue, endValue, gradient) {
    return Size.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color3 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Color3 value
   */
  color3InterpolateFunction(startValue, endValue, gradient) {
    return Color3.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color3 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns interpolated value
   */
  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * Interpolates a Color4 linearly
   * @param startValue Start value of the animation curve
   * @param endValue End value of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns Interpolated Color3 value
   */
  color4InterpolateFunction(startValue, endValue, gradient) {
    return Color4.Lerp(startValue, endValue, gradient);
  }
  /**
   * Interpolates a Color4 cubically
   * @param startValue Start value of the animation curve
   * @param outTangent End tangent of the animation
   * @param endValue End value of the animation curve
   * @param inTangent Start tangent of the animation curve
   * @param gradient Scalar amount to interpolate
   * @returns interpolated value
   */
  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);
  }
  /**
   * @internal Internal use only
   */
  _getKeyValue(value) {
    if (typeof value === "function") {
      return value();
    }
    return value;
  }
  /**
   * Evaluate the animation value at a given frame
   * @param currentFrame defines the frame where we want to evaluate the animation
   * @returns the animation value
   */
  evaluate(currentFrame) {
    evaluateAnimationState.key = 0;
    return this._interpolate(currentFrame, evaluateAnimationState);
  }
  /**
   * @internal Internal use only
   */
  _interpolate(currentFrame, state, searchClosestKeyOnly = false) {
    if (state.loopMode === _Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
    }
    const keys = this._keys;
    const keysLength = keys.length;
    let key = state.key;
    while (key >= 0 && currentFrame < keys[key].frame) {
      --key;
    }
    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {
      ++key;
    }
    state.key = key;
    if (key < 0) {
      return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[0].value);
    } else if (key + 1 > keysLength - 1) {
      return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[keysLength - 1].value);
    }
    const startKey = keys[key];
    const endKey = keys[key + 1];
    if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {
      return void 0;
    }
    const startValue = this._getKeyValue(startKey.value);
    const endValue = this._getKeyValue(endKey.value);
    if (startKey.interpolation === AnimationKeyInterpolation.STEP) {
      if (endKey.frame > currentFrame) {
        return startValue;
      } else {
        return endValue;
      }
    }
    const useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
    const frameDelta = endKey.frame - startKey.frame;
    let gradient = (currentFrame - startKey.frame) / frameDelta;
    const easingFunction = startKey.easingFunction || this.getEasingFunction();
    if (easingFunction !== null) {
      gradient = easingFunction.ease(gradient);
    }
    switch (this.dataType) {
      case _Animation.ANIMATIONTYPE_FLOAT: {
        const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return floatValue;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return (state.offsetValue ?? 0) * state.repeatCount + floatValue;
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_QUATERNION: {
        const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return quatValue;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));
        }
        return quatValue;
      }
      case _Animation.ANIMATIONTYPE_VECTOR3: {
        const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return vec3Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_VECTOR2: {
        const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return vec2Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_SIZE: {
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return this.sizeInterpolateFunction(startValue, endValue, gradient);
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_COLOR3: {
        const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return color3Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_COLOR4: {
        const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO:
            return color4Value;
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:
            return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));
        }
        break;
      }
      case _Animation.ANIMATIONTYPE_MATRIX: {
        switch (state.loopMode) {
          case _Animation.ANIMATIONLOOPMODE_CYCLE:
          case _Animation.ANIMATIONLOOPMODE_CONSTANT:
          case _Animation.ANIMATIONLOOPMODE_YOYO: {
            if (_Animation.AllowMatricesInterpolation) {
              return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
            }
            return startValue;
          }
          case _Animation.ANIMATIONLOOPMODE_RELATIVE:
          case _Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT: {
            return startValue;
          }
        }
        break;
      }
    }
    return 0;
  }
  /**
   * Defines the function to use to interpolate matrices
   * @param startValue defines the start matrix
   * @param endValue defines the end matrix
   * @param gradient defines the gradient between both matrices
   * @param result defines an optional target matrix where to store the interpolation
   * @returns the interpolated matrix
   */
  matrixInterpolateFunction(startValue, endValue, gradient, result) {
    if (_Animation.AllowMatrixDecomposeForInterpolation) {
      if (result) {
        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      return Matrix.DecomposeLerp(startValue, endValue, gradient);
    }
    if (result) {
      Matrix.LerpToRef(startValue, endValue, gradient, result);
      return result;
    }
    return Matrix.Lerp(startValue, endValue, gradient);
  }
  /**
   * Makes a copy of the animation
   * @returns Cloned animation
   */
  clone() {
    const clone = new _Animation(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
    clone.enableBlending = this.enableBlending;
    clone.blendingSpeed = this.blendingSpeed;
    if (this._keys) {
      clone.setKeys(this._keys);
    }
    if (this._ranges) {
      clone._ranges = {};
      for (const name in this._ranges) {
        const range = this._ranges[name];
        if (!range) {
          continue;
        }
        clone._ranges[name] = range.clone();
      }
    }
    return clone;
  }
  /**
   * Sets the key frames of the animation
   * @param values The animation key frames to set
   * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)
   */
  setKeys(values, dontClone = false) {
    this._keys = !dontClone ? values.slice(0) : values;
  }
  /**
   * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame
   * @param frame Frame number
   * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key
   */
  createKeyForFrame(frame) {
    evaluateAnimationState.key = 0;
    const value = this._interpolate(frame, evaluateAnimationState, true);
    if (!value) {
      return this._keys[evaluateAnimationState.key].frame === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;
    }
    const newKey = {
      frame,
      value: value.clone ? value.clone() : value
    };
    this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);
    return evaluateAnimationState.key + 1;
  }
  /**
   * Serializes the animation to an object
   * @returns Serialized object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.property = this.targetProperty;
    serializationObject.framePerSecond = this.framePerSecond;
    serializationObject.dataType = this.dataType;
    serializationObject.loopBehavior = this.loopMode;
    serializationObject.enableBlending = this.enableBlending;
    serializationObject.blendingSpeed = this.blendingSpeed;
    const dataType = this.dataType;
    serializationObject.keys = [];
    const keys = this.getKeys();
    for (let index = 0; index < keys.length; index++) {
      const animationKey = keys[index];
      const key = {};
      key.frame = animationKey.frame;
      switch (dataType) {
        case _Animation.ANIMATIONTYPE_FLOAT:
          key.values = [animationKey.value];
          if (animationKey.inTangent !== void 0) {
            key.values.push(animationKey.inTangent);
          }
          if (animationKey.outTangent !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent);
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
        case _Animation.ANIMATIONTYPE_MATRIX:
        case _Animation.ANIMATIONTYPE_VECTOR3:
        case _Animation.ANIMATIONTYPE_COLOR3:
        case _Animation.ANIMATIONTYPE_COLOR4:
          key.values = animationKey.value.asArray();
          if (animationKey.inTangent != void 0) {
            key.values.push(animationKey.inTangent.asArray());
          }
          if (animationKey.outTangent != void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.outTangent.asArray());
          }
          if (animationKey.interpolation !== void 0) {
            if (animationKey.inTangent === void 0) {
              key.values.push(void 0);
            }
            if (animationKey.outTangent === void 0) {
              key.values.push(void 0);
            }
            key.values.push(animationKey.interpolation);
          }
          break;
      }
      serializationObject.keys.push(key);
    }
    serializationObject.ranges = [];
    for (const name in this._ranges) {
      const source = this._ranges[name];
      if (!source) {
        continue;
      }
      const range = {};
      range.name = name;
      range.from = source.from;
      range.to = source.to;
      serializationObject.ranges.push(range);
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  static _UniversalLerp(left, right, amount) {
    const constructor = left.constructor;
    if (constructor.Lerp) {
      return constructor.Lerp(left, right, amount);
    } else if (constructor.Slerp) {
      return constructor.Slerp(left, right, amount);
    } else if (left.toFixed) {
      return left * (1 - amount) + amount * right;
    } else {
      return right;
    }
  }
  /**
   * Parses an animation object and creates an animation
   * @param parsedAnimation Parsed animation object
   * @returns Animation object
   */
  static Parse(parsedAnimation) {
    const animation = new _Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
    const dataType = parsedAnimation.dataType;
    const keys = [];
    let data;
    let index;
    if (parsedAnimation.enableBlending) {
      animation.enableBlending = parsedAnimation.enableBlending;
    }
    if (parsedAnimation.blendingSpeed) {
      animation.blendingSpeed = parsedAnimation.blendingSpeed;
    }
    for (index = 0; index < parsedAnimation.keys.length; index++) {
      const key = parsedAnimation.keys[index];
      let inTangent = void 0;
      let outTangent = void 0;
      let interpolation = void 0;
      switch (dataType) {
        case _Animation.ANIMATIONTYPE_FLOAT:
          data = key.values[0];
          if (key.values.length >= 2) {
            inTangent = key.values[1];
          }
          if (key.values.length >= 3) {
            outTangent = key.values[2];
          }
          if (key.values.length >= 4) {
            interpolation = key.values[3];
          }
          break;
        case _Animation.ANIMATIONTYPE_QUATERNION:
          data = Quaternion.FromArray(key.values);
          if (key.values.length >= 8) {
            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
            if (!_inTangent.equals(Quaternion.Zero())) {
              inTangent = _inTangent;
            }
          }
          if (key.values.length >= 12) {
            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
            if (!_outTangent.equals(Quaternion.Zero())) {
              outTangent = _outTangent;
            }
          }
          if (key.values.length >= 13) {
            interpolation = key.values[12];
          }
          break;
        case _Animation.ANIMATIONTYPE_MATRIX:
          data = Matrix.FromArray(key.values);
          if (key.values.length >= 17) {
            interpolation = key.values[16];
          }
          break;
        case _Animation.ANIMATIONTYPE_COLOR3:
          data = Color3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Color3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Color3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
        case _Animation.ANIMATIONTYPE_COLOR4:
          data = Color4.FromArray(key.values);
          if (key.values[4]) {
            inTangent = Color4.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            outTangent = Color4.FromArray(key.values[5]);
          }
          if (key.values[6]) {
            interpolation = Color4.FromArray(key.values[6]);
          }
          break;
        case _Animation.ANIMATIONTYPE_VECTOR3:
        default:
          data = Vector3.FromArray(key.values);
          if (key.values[3]) {
            inTangent = Vector3.FromArray(key.values[3]);
          }
          if (key.values[4]) {
            outTangent = Vector3.FromArray(key.values[4]);
          }
          if (key.values[5]) {
            interpolation = key.values[5];
          }
          break;
      }
      const keyData = {};
      keyData.frame = key.frame;
      keyData.value = data;
      if (inTangent != void 0) {
        keyData.inTangent = inTangent;
      }
      if (outTangent != void 0) {
        keyData.outTangent = outTangent;
      }
      if (interpolation != void 0) {
        keyData.interpolation = interpolation;
      }
      keys.push(keyData);
    }
    animation.setKeys(keys);
    if (parsedAnimation.ranges) {
      for (index = 0; index < parsedAnimation.ranges.length; index++) {
        data = parsedAnimation.ranges[index];
        animation.createRange(data.name, data.from, data.to);
      }
    }
    return animation;
  }
  /**
   * Appends the serialized animations from the source animations
   * @param source Source containing the animations
   * @param destination Target to store the animations
   */
  static AppendSerializedAnimations(source, destination) {
    SerializationHelper.AppendSerializedAnimations(source, destination);
  }
  /**
   * Creates a new animation or an array of animations from a snippet saved in a remote file
   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)
   * @param url defines the url to load from
   * @returns a promise that will resolve to the new animation or an array of animations
   */
  static ParseFromFileAsync(name, url) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            let serializationObject = JSON.parse(request.responseText);
            if (serializationObject.animations) {
              serializationObject = serializationObject.animations;
            }
            if (serializationObject.length) {
              const output = [];
              for (const serializedAnimation of serializationObject) {
                output.push(this.Parse(serializedAnimation));
              }
              resolve(output);
            } else {
              const output = this.Parse(serializationObject);
              if (name) {
                output.name = name;
              }
              resolve(output);
            }
          } else {
            reject("Unable to load the animation");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  /**
   * Creates an animation or an array of animations from a snippet saved by the Inspector
   * @param snippetId defines the snippet to load
   * @returns a promise that will resolve to the new animation or a new array of animations
   */
  static ParseFromSnippetAsync(snippetId) {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            if (snippet.animations) {
              const serializationObject = JSON.parse(snippet.animations);
              const outputs = [];
              for (const serializedAnimation of serializationObject.animations) {
                const output = this.Parse(serializedAnimation);
                output.snippetId = snippetId;
                outputs.push(output);
              }
              resolve(outputs);
            } else {
              const serializationObject = JSON.parse(snippet.animation);
              const output = this.Parse(serializationObject);
              output.snippetId = snippetId;
              resolve(output);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
Animation._UniqueIdGenerator = 0;
Animation.AllowMatricesInterpolation = false;
Animation.AllowMatrixDecomposeForInterpolation = true;
Animation.SnippetUrl = `https://snippet.babylonjs.com`;
Animation.ANIMATIONTYPE_FLOAT = 0;
Animation.ANIMATIONTYPE_VECTOR3 = 1;
Animation.ANIMATIONTYPE_QUATERNION = 2;
Animation.ANIMATIONTYPE_MATRIX = 3;
Animation.ANIMATIONTYPE_COLOR3 = 4;
Animation.ANIMATIONTYPE_COLOR4 = 7;
Animation.ANIMATIONTYPE_VECTOR2 = 5;
Animation.ANIMATIONTYPE_SIZE = 6;
Animation.ANIMATIONLOOPMODE_RELATIVE = 0;
Animation.ANIMATIONLOOPMODE_CYCLE = 1;
Animation.ANIMATIONLOOPMODE_CONSTANT = 2;
Animation.ANIMATIONLOOPMODE_YOYO = 4;
Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;
Animation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;
RegisterClass("BABYLON.Animation", Animation);
Node._AnimationRangeFactory = (name, from, to) => new AnimationRange(name, from, to);

// node_modules/@babylonjs/core/Animations/animationGroup.js
var TargetedAnimation = class {
  /**
   * Returns the string "TargetedAnimation"
   * @returns "TargetedAnimation"
   */
  getClassName() {
    return "TargetedAnimation";
  }
  /**
   * Serialize the object
   * @returns the JSON object representing the current entity
   */
  serialize() {
    const serializationObject = {};
    serializationObject.animation = this.animation.serialize();
    serializationObject.targetId = this.target.id;
    return serializationObject;
  }
};
var AnimationGroup = class _AnimationGroup {
  /**
   * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.
   */
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    this.syncWithMask(true);
  }
  /**
   * Makes sure that the animations are either played or stopped according to the animation group mask.
   * Note however that the call won't have any effect if the animation group has not been started yet.
   * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.
   */
  syncWithMask(forceUpdate = false) {
    if (!this.mask && !forceUpdate) {
      this._numActiveAnimatables = this._targetedAnimations.length;
      return;
    }
    this._numActiveAnimatables = 0;
    for (let i = 0; i < this._animatables.length; ++i) {
      const animatable = this._animatables[i];
      if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {
        this._numActiveAnimatables++;
        if (animatable.paused) {
          animatable.restart();
        }
      } else {
        if (!animatable.paused) {
          animatable.pause();
        }
      }
    }
  }
  /**
   * Removes all animations for the targets not retained by the animation group mask.
   * Use this function if you know you won't need those animations anymore and if you want to free memory.
   */
  removeUnmaskedAnimations() {
    if (!this.mask || this.mask.disabled) {
      return;
    }
    for (let i = 0; i < this._animatables.length; ++i) {
      const animatable = this._animatables[i];
      if (!this.mask.retainsTarget(animatable.target.name)) {
        animatable.stop();
        this._animatables.splice(i, 1);
        --i;
      }
    }
    for (let index = 0; index < this._targetedAnimations.length; index++) {
      const targetedAnimation = this._targetedAnimations[index];
      if (!this.mask.retainsTarget(targetedAnimation.target.name)) {
        this._targetedAnimations.splice(index, 1);
        --index;
      }
    }
  }
  /**
   * Gets or sets the first frame
   */
  get from() {
    return this._from;
  }
  set from(value) {
    if (this._from === value) {
      return;
    }
    this._from = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.fromFrame = this._from;
    }
  }
  /**
   * Gets or sets the last frame
   */
  get to() {
    return this._to;
  }
  set to(value) {
    if (this._to === value) {
      return;
    }
    this._to = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.toFrame = this._to;
    }
  }
  /**
   * Define if the animations are started
   */
  get isStarted() {
    return this._isStarted;
  }
  /**
   * Gets a value indicating that the current group is playing
   */
  get isPlaying() {
    return this._isStarted && !this._isPaused;
  }
  /**
   * Gets or sets the speed ratio to use for all animations
   */
  get speedRatio() {
    return this._speedRatio;
  }
  /**
   * Gets or sets the speed ratio to use for all animations
   */
  set speedRatio(value) {
    if (this._speedRatio === value) {
      return;
    }
    this._speedRatio = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.speedRatio = this._speedRatio;
    }
  }
  /**
   * Gets or sets if all animations should loop or not
   */
  get loopAnimation() {
    return this._loopAnimation;
  }
  set loopAnimation(value) {
    if (this._loopAnimation === value) {
      return;
    }
    this._loopAnimation = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.loopAnimation = this._loopAnimation;
    }
  }
  /**
   * Gets or sets if all animations should be evaluated additively
   */
  get isAdditive() {
    return this._isAdditive;
  }
  set isAdditive(value) {
    if (this._isAdditive === value) {
      return;
    }
    this._isAdditive = value;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.isAdditive = this._isAdditive;
    }
  }
  /**
   * Gets or sets the weight to apply to all animations of the group
   */
  get weight() {
    return this._weight;
  }
  set weight(value) {
    if (this._weight === value) {
      return;
    }
    this._weight = value;
    this.setWeightForAllAnimatables(this._weight);
  }
  /**
   * Gets the targeted animations for this animation group
   */
  get targetedAnimations() {
    return this._targetedAnimations;
  }
  /**
   * returning the list of animatables controlled by this animation group.
   */
  get animatables() {
    return this._animatables;
  }
  /**
   * Gets the list of target animations
   */
  get children() {
    return this._targetedAnimations;
  }
  /**
   * Gets or sets the order of play of the animation group (default: 0)
   */
  get playOrder() {
    return this._playOrder;
  }
  set playOrder(value) {
    if (this._playOrder === value) {
      return;
    }
    this._playOrder = value;
    if (this._animatables.length > 0) {
      for (let i = 0; i < this._animatables.length; i++) {
        this._animatables[i].playOrder = this._playOrder;
      }
      this._scene.sortActiveAnimatables();
    }
  }
  /**
   * Allows the animations of the animation group to blend with current running animations
   * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)
   */
  get enableBlending() {
    return this._enableBlending;
  }
  set enableBlending(value) {
    if (this._enableBlending === value) {
      return;
    }
    this._enableBlending = value;
    if (value !== null) {
      for (let i = 0; i < this._targetedAnimations.length; ++i) {
        this._targetedAnimations[i].animation.enableBlending = value;
      }
    }
  }
  /**
   * Gets or sets the animation blending speed
   * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)
   */
  get blendingSpeed() {
    return this._blendingSpeed;
  }
  set blendingSpeed(value) {
    if (this._blendingSpeed === value) {
      return;
    }
    this._blendingSpeed = value;
    if (value !== null) {
      for (let i = 0; i < this._targetedAnimations.length; ++i) {
        this._targetedAnimations[i].animation.blendingSpeed = value;
      }
    }
  }
  /**
   * Gets the length (in seconds) of the animation group
   * This function assumes that all animations are played at the same framePerSecond speed!
   * Note: you can only call this method after you've added at least one targeted animation!
   * @param from Starting frame range (default is AnimationGroup.from)
   * @param to Ending frame range (default is AnimationGroup.to)
   * @returns The length in seconds
   */
  getLength(from, to) {
    from = from ?? this._from;
    to = to ?? this._to;
    const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;
    return (to - from) / fps;
  }
  /**
   * Merge the array of animation groups into a new animation group
   * @param animationGroups List of animation groups to merge
   * @param disposeSource If true, animation groups will be disposed after being merged (default: true)
   * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same "from" and "to" frame (default: false)
   * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array
   * @returns The new animation group or null if no animation groups were passed
   */
  static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {
    if (animationGroups.length === 0) {
      return null;
    }
    weight = weight ?? animationGroups[0].weight;
    let beginFrame = Number.MAX_VALUE;
    let endFrame = -Number.MAX_VALUE;
    if (normalize) {
      for (const animationGroup of animationGroups) {
        if (animationGroup.from < beginFrame) {
          beginFrame = animationGroup.from;
        }
        if (animationGroup.to > endFrame) {
          endFrame = animationGroup.to;
        }
      }
    }
    const mergedAnimationGroup = new _AnimationGroup(animationGroups[0].name + "_merged", animationGroups[0]._scene, weight);
    for (const animationGroup of animationGroups) {
      if (normalize) {
        animationGroup.normalize(beginFrame, endFrame);
      }
      for (const targetedAnimation of animationGroup.targetedAnimations) {
        mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);
      }
      if (disposeSource) {
        animationGroup.dispose();
      }
    }
    return mergedAnimationGroup;
  }
  /**
   * Instantiates a new Animation Group.
   * This helps managing several animations at once.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations
   * @param name Defines the name of the group
   * @param scene Defines the scene the group belongs to
   * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning "no weight")
   * @param playOrder Defines the order of play of the animation group (default is 0)
   */
  constructor(name, scene = null, weight = -1, playOrder = 0) {
    this.name = name;
    this._targetedAnimations = new Array();
    this._animatables = new Array();
    this._from = Number.MAX_VALUE;
    this._to = -Number.MAX_VALUE;
    this._speedRatio = 1;
    this._loopAnimation = false;
    this._isAdditive = false;
    this._weight = -1;
    this._playOrder = 0;
    this._enableBlending = null;
    this._blendingSpeed = null;
    this._numActiveAnimatables = 0;
    this._parentContainer = null;
    this.onAnimationEndObservable = new Observable();
    this.onAnimationLoopObservable = new Observable();
    this.onAnimationGroupLoopObservable = new Observable();
    this.onAnimationGroupEndObservable = new Observable();
    this.onAnimationGroupPauseObservable = new Observable();
    this.onAnimationGroupPlayObservable = new Observable();
    this.metadata = null;
    this._mask = null;
    this._animationLoopFlags = [];
    this._scene = scene || EngineStore.LastCreatedScene;
    this._weight = weight;
    this._playOrder = playOrder;
    this.uniqueId = this._scene.getUniqueId();
    this._scene.addAnimationGroup(this);
  }
  /**
   * Add an animation (with its target) in the group
   * @param animation defines the animation we want to add
   * @param target defines the target of the animation
   * @returns the TargetedAnimation object
   */
  addTargetedAnimation(animation, target) {
    const targetedAnimation = new TargetedAnimation();
    targetedAnimation.animation = animation;
    targetedAnimation.target = target;
    const keys = animation.getKeys();
    if (this._from > keys[0].frame) {
      this._from = keys[0].frame;
    }
    if (this._to < keys[keys.length - 1].frame) {
      this._to = keys[keys.length - 1].frame;
    }
    if (this._enableBlending !== null) {
      animation.enableBlending = this._enableBlending;
    }
    if (this._blendingSpeed !== null) {
      animation.blendingSpeed = this._blendingSpeed;
    }
    this._targetedAnimations.push(targetedAnimation);
    return targetedAnimation;
  }
  /**
   * Remove an animation from the group
   * @param animation defines the animation we want to remove
   */
  removeTargetedAnimation(animation) {
    for (let index = this._targetedAnimations.length - 1; index > -1; index--) {
      const targetedAnimation = this._targetedAnimations[index];
      if (targetedAnimation.animation === animation) {
        this._targetedAnimations.splice(index, 1);
      }
    }
  }
  /**
   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
   * It can add constant keys at begin or end
   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)
   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)
   * @returns the animation group
   */
  normalize(beginFrame = null, endFrame = null) {
    if (beginFrame == null) {
      beginFrame = this._from;
    }
    if (endFrame == null) {
      endFrame = this._to;
    }
    for (let index = 0; index < this._targetedAnimations.length; index++) {
      const targetedAnimation = this._targetedAnimations[index];
      const keys = targetedAnimation.animation.getKeys();
      const startKey = keys[0];
      const endKey = keys[keys.length - 1];
      if (startKey.frame > beginFrame) {
        const newKey = {
          frame: beginFrame,
          value: startKey.value,
          inTangent: startKey.inTangent,
          outTangent: startKey.outTangent,
          interpolation: startKey.interpolation
        };
        keys.splice(0, 0, newKey);
      }
      if (endKey.frame < endFrame) {
        const newKey = {
          frame: endFrame,
          value: endKey.value,
          inTangent: endKey.inTangent,
          outTangent: endKey.outTangent,
          interpolation: endKey.interpolation
        };
        keys.push(newKey);
      }
    }
    this._from = beginFrame;
    this._to = endFrame;
    return this;
  }
  _processLoop(animatable, targetedAnimation, index) {
    animatable.onAnimationLoop = () => {
      this.onAnimationLoopObservable.notifyObservers(targetedAnimation);
      if (this._animationLoopFlags[index]) {
        return;
      }
      this._animationLoopFlags[index] = true;
      this._animationLoopCount++;
      if (this._animationLoopCount === this._numActiveAnimatables) {
        this.onAnimationGroupLoopObservable.notifyObservers(this);
        this._animationLoopCount = 0;
        this._animationLoopFlags.length = 0;
      }
    };
  }
  /**
   * Start all animations on given targets
   * @param loop defines if animations must loop
   * @param speedRatio defines the ratio to apply to animation speed (1 by default)
   * @param from defines the from key (optional)
   * @param to defines the to key (optional)
   * @param isAdditive defines the additive state for the resulting animatables (optional)
   * @returns the current animation group
   */
  start(loop = false, speedRatio = 1, from, to, isAdditive) {
    if (this._isStarted || this._targetedAnimations.length === 0) {
      return this;
    }
    this._loopAnimation = loop;
    this._animationLoopCount = 0;
    this._animationLoopFlags.length = 0;
    for (let index = 0; index < this._targetedAnimations.length; index++) {
      const targetedAnimation = this._targetedAnimations[index];
      const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== void 0 ? from : this._from, to !== void 0 ? to : this._to, loop, speedRatio, void 0, void 0, isAdditive !== void 0 ? isAdditive : this._isAdditive);
      animatable.weight = this._weight;
      animatable.playOrder = this._playOrder;
      animatable.onAnimationEnd = () => {
        this.onAnimationEndObservable.notifyObservers(targetedAnimation);
        this._checkAnimationGroupEnded(animatable);
      };
      this._processLoop(animatable, targetedAnimation, index);
      this._animatables.push(animatable);
    }
    this.syncWithMask();
    this._scene.sortActiveAnimatables();
    this._speedRatio = speedRatio;
    this._isStarted = true;
    this._isPaused = false;
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  }
  /**
   * Pause all animations
   * @returns the animation group
   */
  pause() {
    if (!this._isStarted) {
      return this;
    }
    this._isPaused = true;
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.pause();
    }
    this.onAnimationGroupPauseObservable.notifyObservers(this);
    return this;
  }
  /**
   * Play all animations to initial state
   * This function will start() the animations if they were not started or will restart() them if they were paused
   * @param loop defines if animations must loop
   * @returns the animation group
   */
  play(loop) {
    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {
      if (loop !== void 0) {
        this.loopAnimation = loop;
      }
      this.restart();
    } else {
      this.stop();
      this.start(loop, this._speedRatio);
    }
    this._isPaused = false;
    return this;
  }
  /**
   * Reset all animations to initial state
   * @returns the animation group
   */
  reset() {
    if (!this._isStarted) {
      this.play();
      this.goToFrame(0);
      this.stop();
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.reset();
    }
    return this;
  }
  /**
   * Restart animations from key 0
   * @returns the animation group
   */
  restart() {
    if (!this._isStarted) {
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.restart();
    }
    this.syncWithMask();
    this.onAnimationGroupPlayObservable.notifyObservers(this);
    return this;
  }
  /**
   * Stop all animations
   * @returns the animation group
   */
  stop() {
    if (!this._isStarted) {
      return this;
    }
    const list = this._animatables.slice();
    for (let index = 0; index < list.length; index++) {
      list[index].stop(void 0, void 0, true);
    }
    let curIndex = 0;
    for (let index = 0; index < this._scene._activeAnimatables.length; index++) {
      const animatable = this._scene._activeAnimatables[index];
      if (animatable._runtimeAnimations.length > 0) {
        this._scene._activeAnimatables[curIndex++] = animatable;
      }
    }
    this._scene._activeAnimatables.length = curIndex;
    this._isStarted = false;
    return this;
  }
  /**
   * Set animation weight for all animatables
   *
   * @since 6.12.4
   *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,
   *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started
   * @param weight defines the weight to use
   * @returns the animationGroup
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights
   */
  setWeightForAllAnimatables(weight) {
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.weight = weight;
    }
    return this;
  }
  /**
   * Synchronize and normalize all animatables with a source animatable
   * @param root defines the root animatable to synchronize with (null to stop synchronizing)
   * @returns the animationGroup
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights
   */
  syncAllAnimationsWith(root) {
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.syncWith(root);
    }
    return this;
  }
  /**
   * Goes to a specific frame in this animation group
   * @param frame the frame number to go to
   * @returns the animationGroup
   */
  goToFrame(frame) {
    if (!this._isStarted) {
      return this;
    }
    for (let index = 0; index < this._animatables.length; index++) {
      const animatable = this._animatables[index];
      animatable.goToFrame(frame);
    }
    return this;
  }
  /**
   * Dispose all associated resources
   */
  dispose() {
    this._targetedAnimations.length = 0;
    this._animatables.length = 0;
    const index = this._scene.animationGroups.indexOf(this);
    if (index > -1) {
      this._scene.animationGroups.splice(index, 1);
    }
    if (this._parentContainer) {
      const index2 = this._parentContainer.animationGroups.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.animationGroups.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    this.onAnimationEndObservable.clear();
    this.onAnimationGroupEndObservable.clear();
    this.onAnimationGroupPauseObservable.clear();
    this.onAnimationGroupPlayObservable.clear();
    this.onAnimationLoopObservable.clear();
    this.onAnimationGroupLoopObservable.clear();
  }
  _checkAnimationGroupEnded(animatable) {
    const idx = this._animatables.indexOf(animatable);
    if (idx > -1) {
      this._animatables.splice(idx, 1);
    }
    if (this._animatables.length === 0) {
      this._isStarted = false;
      this.onAnimationGroupEndObservable.notifyObservers(this);
    }
  }
  /**
   * Clone the current animation group and returns a copy
   * @param newName defines the name of the new group
   * @param targetConverter defines an optional function used to convert current animation targets to new ones
   * @param cloneAnimations defines if the animations should be cloned or referenced
   * @returns the new animation group
   */
  clone(newName, targetConverter, cloneAnimations = false) {
    const newGroup = new _AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);
    newGroup._from = this.from;
    newGroup._to = this.to;
    newGroup._speedRatio = this.speedRatio;
    newGroup._loopAnimation = this.loopAnimation;
    newGroup._isAdditive = this.isAdditive;
    newGroup._enableBlending = this.enableBlending;
    newGroup._blendingSpeed = this.blendingSpeed;
    newGroup.metadata = this.metadata;
    newGroup.mask = this.mask;
    for (const targetAnimation of this._targetedAnimations) {
      newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);
    }
    return newGroup;
  }
  /**
   * Serializes the animationGroup to an object
   * @returns Serialized object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.from = this.from;
    serializationObject.to = this.to;
    serializationObject.speedRatio = this.speedRatio;
    serializationObject.loopAnimation = this.loopAnimation;
    serializationObject.isAdditive = this.isAdditive;
    serializationObject.weight = this.weight;
    serializationObject.playOrder = this.playOrder;
    serializationObject.enableBlending = this.enableBlending;
    serializationObject.blendingSpeed = this.blendingSpeed;
    serializationObject.targetedAnimations = [];
    for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {
      const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];
      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();
    }
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    return serializationObject;
  }
  // Statics
  /**
   * Returns a new AnimationGroup object parsed from the source provided.
   * @param parsedAnimationGroup defines the source
   * @param scene defines the scene that will receive the animationGroup
   * @returns a new AnimationGroup
   */
  static Parse(parsedAnimationGroup, scene) {
    const animationGroup = new _AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);
    for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {
      const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];
      const animation = Animation.Parse(targetedAnimation.animation);
      const id = targetedAnimation.targetId;
      if (targetedAnimation.animation.property === "influence") {
        const morphTarget = scene.getMorphTargetById(id);
        if (morphTarget) {
          animationGroup.addTargetedAnimation(animation, morphTarget);
        }
      } else {
        const targetNode = scene.getNodeById(id);
        if (targetNode != null) {
          animationGroup.addTargetedAnimation(animation, targetNode);
        }
      }
    }
    if (Tags) {
      Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);
    }
    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {
      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);
    }
    if (parsedAnimationGroup.speedRatio !== void 0) {
      animationGroup._speedRatio = parsedAnimationGroup.speedRatio;
    }
    if (parsedAnimationGroup.loopAnimation !== void 0) {
      animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;
    }
    if (parsedAnimationGroup.isAdditive !== void 0) {
      animationGroup._isAdditive = parsedAnimationGroup.isAdditive;
    }
    if (parsedAnimationGroup.weight !== void 0) {
      animationGroup._weight = parsedAnimationGroup.weight;
    }
    if (parsedAnimationGroup.playOrder !== void 0) {
      animationGroup._playOrder = parsedAnimationGroup.playOrder;
    }
    if (parsedAnimationGroup.enableBlending !== void 0) {
      animationGroup._enableBlending = parsedAnimationGroup.enableBlending;
    }
    if (parsedAnimationGroup.blendingSpeed !== void 0) {
      animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;
    }
    if (parsedAnimationGroup.metadata !== void 0) {
      animationGroup.metadata = parsedAnimationGroup.metadata;
    }
    return animationGroup;
  }
  /** @internal */
  static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {
    let options;
    if (typeof referenceFrameOrOptions === "object") {
      options = referenceFrameOrOptions;
    } else {
      options = {
        referenceFrame: referenceFrameOrOptions,
        range,
        cloneOriginalAnimationGroup: cloneOriginal,
        clonedAnimationName: clonedName
      };
    }
    let animationGroup = sourceAnimationGroup;
    if (options.cloneOriginalAnimationGroup) {
      animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);
    }
    const targetedAnimations = animationGroup.targetedAnimations;
    for (let index = 0; index < targetedAnimations.length; index++) {
      const targetedAnimation = targetedAnimations[index];
      targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);
    }
    animationGroup.isAdditive = true;
    if (options.clipKeys) {
      let from = Number.MAX_VALUE;
      let to = -Number.MAX_VALUE;
      const targetedAnimations2 = animationGroup.targetedAnimations;
      for (let index = 0; index < targetedAnimations2.length; index++) {
        const targetedAnimation = targetedAnimations2[index];
        const animation = targetedAnimation.animation;
        const keys = animation.getKeys();
        if (from > keys[0].frame) {
          from = keys[0].frame;
        }
        if (to < keys[keys.length - 1].frame) {
          to = keys[keys.length - 1].frame;
        }
      }
      animationGroup._from = from;
      animationGroup._to = to;
    }
    return animationGroup;
  }
  /**
   * Creates a new animation, keeping only the keys that are inside a given key range
   * @param sourceAnimationGroup defines the animation group on which to operate
   * @param fromKey defines the lower bound of the range
   * @param toKey defines the upper bound of the range
   * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup
   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned
   * @returns a new animation group stripped from all the keys outside the given range
   */
  static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {
    const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);
    return _AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);
  }
  /**
   * Updates an existing animation, keeping only the keys that are inside a given key range
   * @param animationGroup defines the animation group on which to operate
   * @param fromKey defines the lower bound of the range
   * @param toKey defines the upper bound of the range
   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned
   * @returns the animationGroup stripped from all the keys outside the given range
   */
  static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {
    return _AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);
  }
  /**
   * Creates a new animation, keeping only the frames that are inside a given frame range
   * @param sourceAnimationGroup defines the animation group on which to operate
   * @param fromFrame defines the lower bound of the range
   * @param toFrame defines the upper bound of the range
   * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup
   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned
   * @returns a new animation group stripped from all the frames outside the given range
   */
  static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {
    const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);
    return _AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);
  }
  /**
   * Updates an existing animation, keeping only the frames that are inside a given frame range
   * @param animationGroup defines the animation group on which to operate
   * @param fromFrame defines the lower bound of the range
   * @param toFrame defines the upper bound of the range
   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned
   * @returns the animationGroup stripped from all the frames outside the given range
   */
  static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {
    return _AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);
  }
  /**
   * Updates an existing animation, keeping only the keys that are inside a given key or frame range
   * @param animationGroup defines the animation group on which to operate
   * @param start defines the lower bound of the range
   * @param end defines the upper bound of the range
   * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned
   * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)
   * @returns the animationGroup stripped from all the keys outside the given range
   */
  static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {
    let from = Number.MAX_VALUE;
    let to = -Number.MAX_VALUE;
    const targetedAnimations = animationGroup.targetedAnimations;
    for (let index = 0; index < targetedAnimations.length; index++) {
      const targetedAnimation = targetedAnimations[index];
      const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();
      if (useFrame) {
        animation.createKeyForFrame(start);
        animation.createKeyForFrame(end);
      }
      const keys = animation.getKeys();
      const newKeys = [];
      let startFrame = Number.MAX_VALUE;
      for (let k = 0; k < keys.length; k++) {
        const key = keys[k];
        if (!useFrame && k >= start && k <= end || useFrame && key.frame >= start && key.frame <= end) {
          const newKey = {
            frame: key.frame,
            value: key.value.clone ? key.value.clone() : key.value,
            inTangent: key.inTangent,
            outTangent: key.outTangent,
            interpolation: key.interpolation,
            lockedTangent: key.lockedTangent
          };
          if (startFrame === Number.MAX_VALUE) {
            startFrame = newKey.frame;
          }
          newKey.frame -= startFrame;
          newKeys.push(newKey);
        }
      }
      if (newKeys.length === 0) {
        targetedAnimations.splice(index, 1);
        index--;
        continue;
      }
      if (from > newKeys[0].frame) {
        from = newKeys[0].frame;
      }
      if (to < newKeys[newKeys.length - 1].frame) {
        to = newKeys[newKeys.length - 1].frame;
      }
      animation.setKeys(newKeys, true);
      targetedAnimation.animation = animation;
    }
    animationGroup._from = from;
    animationGroup._to = to;
    return animationGroup;
  }
  /**
   * Returns the string "AnimationGroup"
   * @returns "AnimationGroup"
   */
  getClassName() {
    return "AnimationGroup";
  }
  /**
   * Creates a detailed string about the object
   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading
   * @returns a string representing the object
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (fullDetails) {
      ret += ", from: " + this._from;
      ret += ", to: " + this._to;
      ret += ", isStarted: " + this._isStarted;
      ret += ", speedRatio: " + this._speedRatio;
      ret += ", targetedAnimations length: " + this._targetedAnimations.length;
      ret += ", animatables length: " + this._animatables;
    }
    return ret;
  }
};

// node_modules/@babylonjs/core/Lights/light.js
var Light = class _Light extends Node {
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  get range() {
    return this._range;
  }
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  set range(value) {
    this._range = value;
    this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  /**
   * Gets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  get intensityMode() {
    return this._intensityMode;
  }
  /**
   * Sets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  set intensityMode(value) {
    this._intensityMode = value;
    this._computePhotometricScale();
  }
  /**
   * Gets the light radius used by PBR Materials to simulate soft area lights.
   */
  get radius() {
    return this._radius;
  }
  /**
   * sets the light radius used by PBR Materials to simulate soft area lights.
   */
  set radius(value) {
    this._radius = value;
    this._computePhotometricScale();
  }
  /**
   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  /**
   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  set shadowEnabled(value) {
    if (this._shadowEnabled === value) {
      return;
    }
    this._shadowEnabled = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Gets the only meshes impacted by this light.
   */
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  /**
   * Sets the only meshes impacted by this light.
   */
  set includedOnlyMeshes(value) {
    this._includedOnlyMeshes = value;
    this._hookArrayForIncludedOnly(value);
  }
  /**
   * Gets the meshes not impacted by this light.
   */
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  /**
   * Sets the meshes not impacted by this light.
   */
  set excludedMeshes(value) {
    this._excludedMeshes = value;
    this._hookArrayForExcluded(value);
  }
  /**
   * Gets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  set excludeWithLayerMask(value) {
    this._excludeWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  set includeOnlyWithLayerMask(value) {
    this._includeOnlyWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  get lightmapMode() {
    return this._lightmapMode;
  }
  /**
   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  set lightmapMode(value) {
    if (this._lightmapMode === value) {
      return;
    }
    this._lightmapMode = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Returns the view matrix.
   * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(_faceIndex) {
    return null;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param _viewMatrix The view transform matrix of the light (optional).
   * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(_viewMatrix, _renderList) {
    return null;
  }
  /**
   * Creates a Light object in the scene.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param scene The scene the light belongs too
   */
  constructor(name, scene) {
    super(name, scene);
    this.diffuse = new Color3(1, 1, 1);
    this.specular = new Color3(1, 1, 1);
    this.falloffType = _Light.FALLOFF_DEFAULT;
    this.intensity = 1;
    this._range = Number.MAX_VALUE;
    this._inverseSquaredRange = 0;
    this._photometricScale = 1;
    this._intensityMode = _Light.INTENSITYMODE_AUTOMATIC;
    this._radius = 1e-5;
    this.renderPriority = 0;
    this._shadowEnabled = true;
    this._excludeWithLayerMask = 0;
    this._includeOnlyWithLayerMask = 0;
    this._lightmapMode = 0;
    this._shadowGenerators = null;
    this._excludedMeshesIds = new Array();
    this._includedOnlyMeshesIds = new Array();
    this._isLight = true;
    this.getScene().addLight(this);
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name);
    this._buildUniformLayout();
    this.includedOnlyMeshes = [];
    this.excludedMeshes = [];
    this._resyncMeshes();
  }
  /**
   * Sets the passed Effect "effect" with the Light textures.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The light
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transferTexturesToEffect(effect, lightIndex) {
    return this;
  }
  /**
   * Binds the lights information from the scene to the effect for the given mesh.
   * @param lightIndex Light index
   * @param scene The scene where the light belongs to
   * @param effect The effect we are binding the data to
   * @param useSpecular Defines if specular is supported
   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows
   */
  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    const iAsString = lightIndex.toString();
    let needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      const scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  }
  /**
   * Returns the string "Light".
   * @returns the class name
   */
  getClassName() {
    return "Light";
  }
  /**
   * Converts the light information to a readable string for debug purpose.
   * @param fullDetails Supports for multiple levels of logging within scene loading
   * @returns the human readable light info
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  }
  /**
   * Set the enabled state of this node.
   * @param value - the new enabled state
   */
  setEnabled(value) {
    super.setEnabled(value);
    this._resyncMeshes();
  }
  /**
   * Returns the Light associated shadow generator if any.
   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator
   * @returns the associated shadow generator.
   */
  getShadowGenerator(camera = null) {
    if (this._shadowGenerators === null) {
      return null;
    }
    return this._shadowGenerators.get(camera) ?? null;
  }
  /**
   * Returns all the shadow generators associated to this light
   * @returns
   */
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  /**
   * Returns a Vector3, the absolute light position in the World.
   * @returns the world space position of the light
   */
  getAbsolutePosition() {
    return Vector3.Zero();
  }
  /**
   * Specifies if the light will affect the passed mesh.
   * @param mesh The mesh to test against the light
   * @returns true the mesh is affected otherwise, false.
   */
  canAffectMesh(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    if (this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.dispose();
      }
      this._shadowGenerators = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      const index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (const mesh of this.getScene().meshes) {
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Returns the light type ID (integer).
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return 0;
  }
  /**
   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
   * @returns the scaled intensity in intensity mode unit
   */
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  /**
   * Returns a new Light object, named "name", from the current one.
   * @param name The name of the cloned light
   * @param newParent The parent of this light, if it has one
   * @returns the new created light
   */
  clone(name, newParent = null) {
    const constructor = _Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());
    if (!constructor) {
      return null;
    }
    const clonedLight = SerializationHelper.Clone(constructor, this);
    if (name) {
      clonedLight.name = name;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  }
  /**
   * Serializes the current light into a Serialization object.
   * @returns the serialized object.
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach((mesh) => {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach((mesh) => {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
   * This new light is named "name" and added to the passed scene.
   * @param type Type according to the types available in Light.LIGHTTYPEID_x
   * @param name The friendly name of the light
   * @param scene The scene the new light will belong to
   * @returns the constructor function
   */
  static GetConstructorFromName(type, name, scene) {
    const constructorFunc = Node.Construct("Light_Type_" + type, name, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  }
  /**
   * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
   * @param parsedLight The JSON representation of the light
   * @param scene The scene to create the parsed light in
   * @returns the created light after parsing
   */
  static Parse(parsedLight, scene) {
    const constructor = _Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    const light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.parentInstanceIndex !== void 0) {
      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        const parsedAnimation = parsedLight.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  }
  _hookArrayForExcluded(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      for (const item of items) {
        item._resyncLightSource(this);
      }
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      for (const item of deleted) {
        item._resyncLightSource(this);
      }
      return deleted;
    };
    for (const item of array) {
      item._resyncLightSource(this);
    }
  }
  _hookArrayForIncludedOnly(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._resyncMeshes();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const mesh of this.getScene().meshes) {
      mesh._resyncLightSource(this);
    }
  }
  /**
   * Forces the meshes to update their light related information in their rendering used effects
   * @internal Internal Use Only
   */
  _markMeshesAsLightDirty() {
    for (const mesh of this.getScene().meshes) {
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  }
  /**
   * Recomputes the cached photometric scale if needed.
   */
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  }
  /**
   * @returns the Photometric Scale according to the light type and intensity mode.
   */
  _getPhotometricScale() {
    let photometricScale = 0;
    const lightTypeID = this.getTypeID();
    let photometricMode = this.intensityMode;
    if (photometricMode === _Light.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === _Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = _Light.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = _Light.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case _Light.LIGHTTYPEID_POINTLIGHT:
      case _Light.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case _Light.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case _Light.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE: {
            let apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case _Light.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  }
  /**
   * Reorder the light in the scene according to their defined priority.
   * @internal Internal Use Only
   */
  _reorderLightsInScene() {
    const scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  }
};
Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
__decorate([
  serializeAsColor3()
], Light.prototype, "diffuse", void 0);
__decorate([
  serializeAsColor3()
], Light.prototype, "specular", void 0);
__decorate([
  serialize()
], Light.prototype, "falloffType", void 0);
__decorate([
  serialize()
], Light.prototype, "intensity", void 0);
__decorate([
  serialize()
], Light.prototype, "range", null);
__decorate([
  serialize()
], Light.prototype, "intensityMode", null);
__decorate([
  serialize()
], Light.prototype, "radius", null);
__decorate([
  serialize()
], Light.prototype, "_renderPriority", void 0);
__decorate([
  expandToProperty("_reorderLightsInScene")
], Light.prototype, "renderPriority", void 0);
__decorate([
  serialize("shadowEnabled")
], Light.prototype, "_shadowEnabled", void 0);
__decorate([
  serialize("excludeWithLayerMask")
], Light.prototype, "_excludeWithLayerMask", void 0);
__decorate([
  serialize("includeOnlyWithLayerMask")
], Light.prototype, "_includeOnlyWithLayerMask", void 0);
__decorate([
  serialize("lightmapMode")
], Light.prototype, "_lightmapMode", void 0);

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode;
(function(SceneLoaderAnimationGroupLoadingMode2) {
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
var SceneLoader = class _SceneLoader {
  /**
   * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
   */
  static get ForceFullSceneLoadingForIncremental() {
    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(value) {
    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
  }
  /**
   * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
   */
  static get ShowLoadingScreen() {
    return SceneLoaderFlags.ShowLoadingScreen;
  }
  static set ShowLoadingScreen(value) {
    SceneLoaderFlags.ShowLoadingScreen = value;
  }
  /**
   * Defines the current logging level (while loading the scene)
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get loggingLevel() {
    return SceneLoaderFlags.loggingLevel;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static set loggingLevel(value) {
    SceneLoaderFlags.loggingLevel = value;
  }
  /**
   * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
   */
  static get CleanBoneMatrixWeights() {
    return SceneLoaderFlags.CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(value) {
    SceneLoaderFlags.CleanBoneMatrixWeights = value;
  }
  /**
   * Gets the default plugin (used to load Babylon files)
   * @returns the .babylon plugin
   */
  static GetDefaultPlugin() {
    return _SceneLoader._RegisteredPlugins[".babylon"];
  }
  static _GetPluginForExtension(extension) {
    const registeredPlugin = _SceneLoader._RegisteredPlugins[extension];
    if (registeredPlugin) {
      return registeredPlugin;
    }
    Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes");
    return _SceneLoader.GetDefaultPlugin();
  }
  static _GetPluginForDirectLoad(data) {
    for (const extension in _SceneLoader._RegisteredPlugins) {
      const plugin = _SceneLoader._RegisteredPlugins[extension].plugin;
      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
        return _SceneLoader._RegisteredPlugins[extension];
      }
    }
    return _SceneLoader.GetDefaultPlugin();
  }
  static _GetPluginForFilename(sceneFilename) {
    const queryStringPosition = sceneFilename.indexOf("?");
    if (queryStringPosition !== -1) {
      sceneFilename = sceneFilename.substring(0, queryStringPosition);
    }
    const dotPosition = sceneFilename.lastIndexOf(".");
    const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
    return _SceneLoader._GetPluginForExtension(extension);
  }
  static _GetDirectLoad(sceneFilename) {
    if (sceneFilename.substr(0, 5) === "data:") {
      return sceneFilename.substr(5);
    }
    return null;
  }
  static _FormatErrorMessage(fileInfo, message, exception) {
    const fromLoad = fileInfo.rawData ? "binary data" : fileInfo.url;
    let errorMessage = "Unable to load from " + fromLoad;
    if (message) {
      errorMessage += `: ${message}`;
    } else if (exception) {
      errorMessage += `: ${exception}`;
    }
    return errorMessage;
  }
  static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name) {
    const directLoad = _SceneLoader._GetDirectLoad(fileInfo.url);
    if (fileInfo.rawData && !pluginExtension) {
      throw "When using ArrayBufferView to load data the file extension must be provided.";
    }
    const registeredPlugin = pluginExtension ? _SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? _SceneLoader._GetPluginForDirectLoad(fileInfo.url) : _SceneLoader._GetPluginForFilename(fileInfo.url);
    if (fileInfo.rawData && !registeredPlugin.isBinary) {
      throw "Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";
    }
    let plugin;
    if (registeredPlugin.plugin.createPlugin !== void 0) {
      plugin = registeredPlugin.plugin.createPlugin();
    } else {
      plugin = registeredPlugin.plugin;
    }
    if (!plugin) {
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    }
    _SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
      if (plugin.directLoad) {
        const result = plugin.directLoad(scene, directLoad);
        if (result.then) {
          result.then((data) => {
            onSuccess(plugin, data);
          }).catch((error) => {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return plugin;
    }
    const useArrayBuffer = registeredPlugin.isBinary;
    const dataCallback = (data, responseURL) => {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    let request = null;
    let pluginDisposed = false;
    const onDisposeObservable = plugin.onDisposeObservable;
    if (onDisposeObservable) {
      onDisposeObservable.add(() => {
        pluginDisposed = true;
        if (request) {
          request.abort();
          request = null;
        }
        onDispose();
      });
    }
    const manifestChecked = () => {
      if (pluginDisposed) {
        return;
      }
      const errorCallback = (request2, exception) => {
        onError(request2 == null ? void 0 : request2.statusText, exception);
      };
      if (!plugin.loadFile && fileInfo.rawData) {
        throw "Plugin does not support loading ArrayBufferView.";
      }
      request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
    };
    const engine = scene.getEngine();
    let canUseOfflineSupport = engine.enableOfflineSupport;
    if (canUseOfflineSupport) {
      let exceptionFound = false;
      for (const regex of scene.disableOfflineSupportExceptionRules) {
        if (regex.test(fileInfo.url)) {
          exceptionFound = true;
          break;
        }
      }
      canUseOfflineSupport = !exceptionFound;
    }
    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
    } else {
      manifestChecked();
    }
    return plugin;
  }
  static _GetFileInfo(rootUrl, sceneFilename) {
    let url;
    let name;
    let file = null;
    let rawData = null;
    if (!sceneFilename) {
      url = rootUrl;
      name = Tools.GetFilename(rootUrl);
      rootUrl = Tools.GetFolderPath(rootUrl);
    } else if (sceneFilename.name) {
      const sceneFile = sceneFilename;
      url = `file:${sceneFile.name}`;
      name = sceneFile.name;
      file = sceneFile;
    } else if (ArrayBuffer.isView(sceneFilename)) {
      url = "";
      name = RandomGUID();
      rawData = sceneFilename;
    } else if (typeof sceneFilename === "string" && sceneFilename.startsWith("data:")) {
      url = sceneFilename;
      name = "";
    } else {
      const filename = sceneFilename;
      if (filename.substr(0, 1) === "/") {
        Tools.Error("Wrong sceneFilename parameter");
        return null;
      }
      url = rootUrl + filename;
      name = filename;
    }
    return {
      url,
      rootUrl,
      name,
      file,
      rawData
    };
  }
  // Public functions
  /**
   * Gets a plugin that can load the given extension
   * @param extension defines the extension to load
   * @returns a plugin or null if none works
   */
  static GetPluginForExtension(extension) {
    return _SceneLoader._GetPluginForExtension(extension).plugin;
  }
  /**
   * Gets a boolean indicating that the given extension can be loaded
   * @param extension defines the extension to load
   * @returns true if the extension is supported
   */
  static IsPluginForExtensionAvailable(extension) {
    return !!_SceneLoader._RegisteredPlugins[extension];
  }
  /**
   * Adds a new plugin to the list of registered plugins
   * @param plugin defines the plugin to add
   */
  static RegisterPlugin(plugin) {
    if (typeof plugin.extensions === "string") {
      const extension = plugin.extensions;
      _SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: false
      };
    } else {
      const extensions = plugin.extensions;
      Object.keys(extensions).forEach((extension) => {
        _SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
          plugin,
          isBinary: extensions[extension].isBinary
        };
      });
    }
  }
  /**
   * Import meshes into a scene
   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene the instance of BABYLON.Scene to append to
   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @returns The loaded plugin
   */
  static ImportMesh(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "") {
    if (!scene) {
      Logger.Error("No scene available to import mesh to");
      return null;
    }
    const fileInfo = _SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    const errorHandler = (message, exception) => {
      const errorMessage = _SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback: " + e, e);
      }
    } : void 0;
    const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
      scene.importedMeshesFiles.push(fileInfo.url);
      if (onSuccess) {
        try {
          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);
        } catch (e) {
          errorHandler("Error in onSuccess callback: " + e, e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return _SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {
      if (plugin.rewriteRootURL) {
        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
      }
      if (plugin.importMesh) {
        const syncedPlugin = plugin;
        const meshes = [];
        const particleSystems = [];
        const skeletons = [];
        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);
      } else {
        const asyncedPlugin = plugin;
        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {
          scene.loadingPluginName = plugin.name;
          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights, result.spriteManagers);
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);
  }
  /**
   * Import meshes into a scene
   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene the instance of BABYLON.Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file
   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
   */
  static ImportMeshAsync(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = "") {
    return new Promise((resolve, reject) => {
      _SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
        resolve({
          meshes,
          particleSystems,
          skeletons,
          animationGroups,
          transformNodes,
          geometries,
          lights,
          spriteManagers
        });
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension, name);
    });
  }
  /**
   * Load a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param engine is the instance of BABYLON.Engine to use to create the scene
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns The loaded plugin
   */
  static Load(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "") {
    if (!engine) {
      Tools.Error("No engine available");
      return null;
    }
    return _SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name);
  }
  /**
   * Load a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param engine is the instance of BABYLON.Engine to use to create the scene
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns The loaded scene
   */
  static LoadAsync(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null, name = "") {
    return new Promise((resolve, reject) => {
      _SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {
        resolve(scene);
      }, onProgress, (scene, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension, name);
    });
  }
  /**
   * Append a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @returns The loaded plugin
   */
  static Append(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "") {
    if (!scene) {
      Logger.Error("No scene available to append to");
      return null;
    }
    const fileInfo = _SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    if (_SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {
      this._ShowingLoadingScreen = true;
      scene.getEngine().displayLoadingUI();
      scene.executeWhenReady(() => {
        scene.getEngine().hideLoadingUI();
        this._ShowingLoadingScreen = false;
      });
    }
    const errorHandler = (message, exception) => {
      const errorMessage = _SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    const successHandler = () => {
      if (onSuccess) {
        try {
          onSuccess(scene);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return _SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
      if (plugin.load) {
        const syncedPlugin = plugin;
        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler();
      } else {
        const asyncedPlugin = plugin;
        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {
          scene.loadingPluginName = plugin.name;
          successHandler();
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);
  }
  /**
   * Append a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @returns The given scene
   */
  static AppendAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = "") {
    return new Promise((resolve, reject) => {
      _SceneLoader.Append(rootUrl, sceneFilename, scene, (scene2) => {
        resolve(scene2);
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension, name);
    });
  }
  /**
   * Load a scene into an asset container
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns The loaded plugin
   */
  static LoadAssetContainer(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "") {
    if (!scene) {
      Logger.Error("No scene available to load asset container to");
      return null;
    }
    const fileInfo = _SceneLoader._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    const loadingToken = {};
    scene.addPendingData(loadingToken);
    const disposeHandler = () => {
      scene.removePendingData(loadingToken);
    };
    const errorHandler = (message, exception) => {
      const errorMessage = _SceneLoader._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    const progressHandler = onProgress ? (event) => {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    const successHandler = (assets) => {
      if (onSuccess) {
        try {
          onSuccess(assets);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene.removePendingData(loadingToken);
    };
    return _SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
      if (plugin.loadAssetContainer) {
        const syncedPlugin = plugin;
        const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
        if (!assetContainer) {
          return;
        }
        assetContainer.populateRootNodes();
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      } else if (plugin.loadAssetContainerAsync) {
        const asyncedPlugin = plugin;
        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {
          assetContainer.populateRootNodes();
          scene.loadingPluginName = plugin.name;
          successHandler(assetContainer);
        }).catch((error) => {
          errorHandler(error.message, error);
        });
      } else {
        errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);
  }
  /**
   * Load a scene into an asset container
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)
   * @param scene is the instance of Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @returns The loaded asset container
   */
  static LoadAssetContainerAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      _SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {
        resolve(assetContainer);
      }, onProgress, (scene2, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
  /**
   * Import animations from a file into a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   */
  static ImportAnimations(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    if (!scene) {
      Logger.Error("No scene available to load animations to");
      return;
    }
    if (overwriteAnimations) {
      for (const animatable of scene.animatables) {
        animatable.reset();
      }
      scene.stopAllAnimations();
      scene.animationGroups.slice().forEach((animationGroup) => {
        animationGroup.dispose();
      });
      const nodes = scene.getNodes();
      nodes.forEach((node) => {
        if (node.animations) {
          node.animations = [];
        }
      });
    } else {
      switch (animationGroupLoadingMode) {
        case SceneLoaderAnimationGroupLoadingMode.Clean:
          scene.animationGroups.slice().forEach((animationGroup) => {
            animationGroup.dispose();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Stop:
          scene.animationGroups.forEach((animationGroup) => {
            animationGroup.stop();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Sync:
          scene.animationGroups.forEach((animationGroup) => {
            animationGroup.reset();
            animationGroup.restart();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.NoSync:
          break;
        default:
          Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
          return;
      }
    }
    const startingIndexForNewAnimatables = scene.animatables.length;
    const onAssetContainerLoaded = (container) => {
      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
      container.dispose();
      scene.onAnimationFileImportedObservable.notifyObservers(scene);
      if (onSuccess) {
        onSuccess(scene);
      }
    };
    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
  }
  /**
   * Import animations from a file into a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @returns the updated scene with imported animations
   */
  static ImportAnimationsAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
    return new Promise((resolve, reject) => {
      _SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, (_scene) => {
        resolve(_scene);
      }, onProgress, (_scene, message, exception) => {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  }
};
SceneLoader.NO_LOGGING = 0;
SceneLoader.MINIMAL_LOGGING = 1;
SceneLoader.SUMMARY_LOGGING = 2;
SceneLoader.DETAILED_LOGGING = 3;
SceneLoader.OnPluginActivatedObservable = new Observable();
SceneLoader._RegisteredPlugins = {};
SceneLoader._ShowingLoadingScreen = false;

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
Node.AddNodeConstructor("Light_Type_3", (name, scene) => {
  return () => new HemisphericLight(name, Vector3.Zero(), scene);
});
var HemisphericLight = class extends Light {
  /**
   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
   * The HemisphericLight can't cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param direction The direction of the light reflection
   * @param scene The scene the light belongs to
   */
  constructor(name, direction, scene) {
    super(name, scene);
    this.groundColor = new Color3(0, 0, 0);
    this.direction = direction || Vector3.Up();
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightGround", 3);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Returns the string "HemisphericLight".
   * @returns The class name
   */
  getClassName() {
    return "HemisphericLight";
  }
  /**
   * Sets the HemisphericLight direction towards the passed target (Vector3).
   * Returns the updated direction.
   * @param target The target the direction should point to
   * @returns The computed direction
   */
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
    return this.direction;
  }
  /**
   * Returns the shadow generator associated to the light.
   * @returns Always null for hemispheric lights because it does not support shadows.
   */
  getShadowGenerator() {
    return null;
  }
  /**
   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
   * @param _effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The hemispheric light
   */
  transferToEffect(_effect, lightIndex) {
    const normalizeDirection = Vector3.Normalize(this.direction);
    this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
    this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    const normalizeDirection = Vector3.Normalize(this.direction);
    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    return this;
  }
  /**
   * Computes the world matrix of the node
   * @returns the world matrix
   */
  computeWorldMatrix() {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  }
  /**
   * Returns the integer 3.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["HEMILIGHT" + lightIndex] = true;
  }
};
__decorate([
  serializeAsColor3()
], HemisphericLight.prototype, "groundColor", void 0);
__decorate([
  serializeAsVector3()
], HemisphericLight.prototype, "direction", void 0);

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var ShaderMaterial = class _ShaderMaterial extends PushMaterial {
  /**
   * Instantiate a new shader material.
   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
   * This returned material effects how the mesh will look based on the code in the shaders.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial
   * @param name Define the name of the material in the scene
   * @param scene Define the scene the material belongs to
   * @param shaderPath Defines  the route to the shader code in one of three ways:
   *  * object: \{ vertex: "custom", fragment: "custom" \}, used with Effect.ShadersStore["customVertexShader"] and Effect.ShadersStore["customFragmentShader"]
   *  * object: \{ vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ vertexSource: "vertex shader code string", fragmentSource: "fragment shader code string" \} using with strings containing the shaders code
   *  * string: "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.
   * @param options Define the options used to create the shader
   * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.
   */
  constructor(name, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
    super(name, scene, storeEffectOnSubMeshes);
    this._textures = {};
    this._textureArrays = {};
    this._externalTextures = {};
    this._floats = {};
    this._ints = {};
    this._uints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors3Arrays = {};
    this._colors4 = {};
    this._colors4Arrays = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._quaternions = {};
    this._quaternionsArrays = {};
    this._matrices = {};
    this._matrixArrays = {};
    this._matrices3x3 = {};
    this._matrices2x2 = {};
    this._vectors2Arrays = {};
    this._vectors3Arrays = {};
    this._vectors4Arrays = {};
    this._uniformBuffers = {};
    this._textureSamplers = {};
    this._storageBuffers = {};
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._multiview = false;
    this._materialHelperNeedsPreviousMatrices = false;
    this._shaderPath = shaderPath;
    this._options = {
      needAlphaBlending: false,
      needAlphaTesting: false,
      attributes: ["position", "normal", "uv"],
      uniforms: ["worldViewProjection"],
      uniformBuffers: [],
      samplers: [],
      externalTextures: [],
      samplerObjects: [],
      storageBuffers: [],
      defines: [],
      useClipPlane: false,
      ...options
    };
  }
  /**
   * Gets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  get shaderPath() {
    return this._shaderPath;
  }
  /**
   * Sets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  set shaderPath(shaderPath) {
    this._shaderPath = shaderPath;
  }
  /**
   * Gets the options used to compile the shader.
   * They can be modified to trigger a new compilation
   */
  get options() {
    return this._options;
  }
  /**
   * is multiview set to true?
   */
  get isMultiview() {
    return this._multiview;
  }
  /**
   * Gets the current class name of the material e.g. "ShaderMaterial"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "ShaderMaterial";
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    return this.alpha < 1 || this._options.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._options.needAlphaTesting;
  }
  _checkUniform(uniformName) {
    if (this._options.uniforms.indexOf(uniformName) === -1) {
      this._options.uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTexture(name, texture) {
    if (this._options.samplers.indexOf(name) === -1) {
      this._options.samplers.push(name);
    }
    this._textures[name] = texture;
    return this;
  }
  /**
   * Set a texture array in the shader.
   * @param name Define the name of the uniform sampler array as defined in the shader
   * @param textures Define the list of textures to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureArray(name, textures) {
    if (this._options.samplers.indexOf(name) === -1) {
      this._options.samplers.push(name);
    }
    this._checkUniform(name);
    this._textureArrays[name] = textures;
    return this;
  }
  /**
   * Set an internal texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setExternalTexture(name, texture) {
    if (this._options.externalTextures.indexOf(name) === -1) {
      this._options.externalTextures.push(name);
    }
    this._externalTextures[name] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloat(name, value) {
    this._checkUniform(name);
    this._floats[name] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setInt(name, value) {
    this._checkUniform(name);
    this._ints[name] = value;
    return this;
  }
  /**
   * Set a unsigned int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUInt(name, value) {
    this._checkUniform(name);
    this._uints[name] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloats(name, value) {
    this._checkUniform(name);
    this._floatsArrays[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3(name, value) {
    this._checkUniform(name);
    this._colors3[name] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a Color3 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3Array(name, value) {
    this._checkUniform(name);
    this._colors3Arrays[name] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4(name, value) {
    this._checkUniform(name);
    this._colors4[name] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Color4 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4Array(name, value) {
    this._checkUniform(name);
    this._colors4Arrays[name] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector2(name, value) {
    this._checkUniform(name);
    this._vectors2[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector3(name, value) {
    this._checkUniform(name);
    this._vectors3[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector4(name, value) {
    this._checkUniform(name);
    this._vectors4[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Quaternion.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternion(name, value) {
    this._checkUniform(name);
    this._quaternions[name] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Quaternion array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternionArray(name, value) {
    this._checkUniform(name);
    this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {
      quaternion.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a mat4 in the shader from a Matrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix(name, value) {
    this._checkUniform(name);
    this._matrices[name] = value;
    return this;
  }
  /**
   * Set a float32Array in the shader from a matrix array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrices(name, value) {
    this._checkUniform(name);
    const float32Array = new Float32Array(value.length * 16);
    for (let index = 0; index < value.length; index++) {
      const matrix = value[index];
      matrix.copyToArray(float32Array, index * 16);
    }
    this._matrixArrays[name] = float32Array;
    return this;
  }
  /**
   * Set a mat3 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix3x3(name, value) {
    this._checkUniform(name);
    this._matrices3x3[name] = value;
    return this;
  }
  /**
   * Set a mat2 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix2x2(name, value) {
    this._checkUniform(name);
    this._matrices2x2[name] = value;
    return this;
  }
  /**
   * Set a vec2 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray2(name, value) {
    this._checkUniform(name);
    this._vectors2Arrays[name] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray3(name, value) {
    this._checkUniform(name);
    this._vectors3Arrays[name] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray4(name, value) {
    this._checkUniform(name);
    this._vectors4Arrays[name] = value;
    return this;
  }
  /**
   * Set a uniform buffer in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUniformBuffer(name, buffer) {
    if (this._options.uniformBuffers.indexOf(name) === -1) {
      this._options.uniformBuffers.push(name);
    }
    this._uniformBuffers[name] = buffer;
    return this;
  }
  /**
   * Set a texture sampler in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param sampler Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureSampler(name, sampler) {
    if (this._options.samplerObjects.indexOf(name) === -1) {
      this._options.samplerObjects.push(name);
    }
    this._textureSamplers[name] = sampler;
    return this;
  }
  /**
   * Set a storage buffer in the shader
   * @param name Define the name of the storage buffer as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setStorageBuffer(name, buffer) {
    if (this._options.storageBuffers.indexOf(name) === -1) {
      this._options.storageBuffers.push(name);
    }
    this._storageBuffers[name] = buffer;
    return this;
  }
  /**
   * Adds, removes, or replaces the specified shader define and value.
   * * setDefine("MY_DEFINE", true); // enables a boolean define
   * * setDefine("MY_DEFINE", "0.5"); // adds "#define MY_DEFINE 0.5" to the shader (or sets and replaces the value of any existing define with that name)
   * * setDefine("MY_DEFINE", false); // disables and removes the define
   * Note if the active defines do change, the shader will be recompiled and this can be expensive.
   * @param define the define name e.g., "OUTPUT_TO_SRGB" or "#define OUTPUT_TO_SRGB". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.
   * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setDefine(define, value) {
    const defineName = define.trimEnd() + " ";
    const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));
    if (existingDefineIdx >= 0) {
      this.options.defines.splice(existingDefineIdx, 1);
    }
    if (typeof value !== "boolean" || value) {
      this.options.defines.push(defineName + value);
    }
    return this;
  }
  /**
   * Specifies that the submesh is ready to be used
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    return this.isReady(mesh, useInstances, subMesh);
  }
  /**
   * Checks if the material is ready to render the requested mesh
   * @param mesh Define the mesh to render
   * @param useInstances Define whether or not the material is used with instances
   * @param subMesh defines which submesh to render
   * @returns true if ready, otherwise false
   */
  isReady(mesh, useInstances, subMesh) {
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    if (this.isFrozen) {
      const drawWrapper2 = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
      if (drawWrapper2.effect && drawWrapper2._wasPreviouslyReady && drawWrapper2._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    const defines = [];
    const attribs = [];
    const fallbacks = new EffectFallbacks();
    let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
      this._multiview = true;
      defines.push("#define MULTIVIEW");
      if (uniforms.indexOf("viewProjection") !== -1 && uniforms.indexOf("viewProjectionR") === -1) {
        uniforms.push("viewProjectionR");
      }
    }
    for (let index = 0; index < this._options.defines.length; index++) {
      const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
      defines.push(defineToAdd);
    }
    for (let index = 0; index < this._options.attributes.length; index++) {
      attribs.push(this._options.attributes[index]);
    }
    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {
        attribs.push(VertexBuffer.ColorKind);
      }
      defines.push("#define VERTEXCOLOR");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);
      if (mesh == null ? void 0 : mesh.hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
          attribs.push(VertexBuffer.ColorInstanceKind);
          defines.push("#define INSTANCESCOLOR");
        }
      }
    }
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      const skeleton = mesh.skeleton;
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      fallbacks.addCPUSkinningFallback(0, mesh);
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
        if (uniforms.indexOf("boneTextureWidth") === -1) {
          uniforms.push("boneTextureWidth");
        }
        if (this._options.samplers.indexOf("boneSampler") === -1) {
          this._options.samplers.push("boneSampler");
        }
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        if (uniforms.indexOf("mBones") === -1) {
          uniforms.push("mBones");
        }
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    let numInfluencers = 0;
    const manager = mesh ? mesh.morphTargetManager : null;
    if (manager) {
      const uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
      const tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
      const normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
      numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;
      if (uv) {
        defines.push("#define MORPHTARGETS_UV");
      }
      if (tangent) {
        defines.push("#define MORPHTARGETS_TANGENT");
      }
      if (normal) {
        defines.push("#define MORPHTARGETS_NORMAL");
      }
      if (numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
      }
      if (manager.isUsingTextureForTargets) {
        defines.push("#define MORPHTARGETS_TEXTURE");
        if (uniforms.indexOf("morphTargetTextureIndices") === -1) {
          uniforms.push("morphTargetTextureIndices");
        }
        if (this._options.samplers.indexOf("morphTargets") === -1) {
          this._options.samplers.push("morphTargets");
        }
      }
      defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
      for (let index = 0; index < numInfluencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
      }
      if (numInfluencers > 0) {
        uniforms = uniforms.slice();
        uniforms.push("morphTargetInfluences");
        uniforms.push("morphTargetCount");
        uniforms.push("morphTargetTextureInfo");
        uniforms.push("morphTargetTextureIndices");
      }
    } else {
      defines.push("#define NUM_MORPH_INFLUENCERS 0");
    }
    if (mesh) {
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
          uniforms.push("bakedVertexAnimationSettings");
        }
        if (uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
          uniforms.push("bakedVertexAnimationTextureSizeInverted");
        }
        if (uniforms.indexOf("bakedVertexAnimationTime") === -1) {
          uniforms.push("bakedVertexAnimationTime");
        }
        if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
          this._options.samplers.push("bakedVertexAnimationTexture");
        }
      }
      PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    }
    for (const name in this._textures) {
      if (!this._textures[name].isReady()) {
        return false;
      }
    }
    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
      defines.push("#define ALPHATEST");
    }
    if (this._options.useClipPlane !== false) {
      addClipPlaneUniforms(uniforms);
      prepareStringDefinesForClipPlanes(this, scene, defines);
    }
    if (scene.fogEnabled && (mesh == null ? void 0 : mesh.applyFog) && scene.fogMode !== Scene.FOGMODE_NONE) {
      defines.push("#define FOG");
      if (uniforms.indexOf("view") === -1) {
        uniforms.push("view");
      }
      if (uniforms.indexOf("vFogInfos") === -1) {
        uniforms.push("vFogInfos");
      }
      if (uniforms.indexOf("vFogColor") === -1) {
        uniforms.push("vFogColor");
      }
    }
    if (this._useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
      if (uniforms.indexOf("logarithmicDepthConstant") === -1) {
        uniforms.push("logarithmicDepthConstant");
      }
    }
    if (this.customShaderNameResolve) {
      uniforms = uniforms.slice();
      uniformBuffers = uniformBuffers.slice();
      samplers = samplers.slice();
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
    }
    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(void 0, true) : this._drawWrapper;
    const previousEffect = (drawWrapper == null ? void 0 : drawWrapper.effect) ?? null;
    const previousDefines = (drawWrapper == null ? void 0 : drawWrapper.defines) ?? null;
    const join = defines.join("\n");
    let effect = previousEffect;
    if (previousDefines !== join) {
      effect = engine.createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
        shaderLanguage: this._options.shaderLanguage
      }, engine);
      if (storeEffectOnSubMeshes) {
        subMesh.setEffect(effect, join, this._materialContext);
      } else if (drawWrapper) {
        drawWrapper.setEffect(effect, join);
      }
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = subMesh ?? (mesh == null ? void 0 : mesh.subMeshes[0]) ?? null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
    }
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    if (!(effect == null ? void 0 : effect.isReady())) {
      return false;
    }
    if (previousEffect !== effect) {
      scene.resetCachedMaterial();
    }
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   * @param effectOverride - If provided, use this effect instead of internal effect
   */
  bindOnlyWorldMatrix(world, effectOverride) {
    const scene = this.getScene();
    const effect = effectOverride ?? this.getEffect();
    if (!effect) {
      return;
    }
    if (this._options.uniforms.indexOf("world") !== -1) {
      effect.setMatrix("world", world);
    }
    if (this._options.uniforms.indexOf("worldView") !== -1) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
      effect.setMatrix("worldView", this._cachedWorldViewMatrix);
    }
    if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
      effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
    }
    if (this._options.uniforms.indexOf("view") !== -1) {
      effect.setMatrix("view", scene.getViewMatrix());
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) == null ? void 0 : _a.effect, subMesh);
  }
  /**
   * Binds the material to the mesh
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh to bind the material to
   * @param effectOverride - If provided, use this effect instead of internal effect
   * @param subMesh defines the submesh to bind the material to
   */
  bind(world, mesh, effectOverride, subMesh) {
    var _a;
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());
    if (!effect) {
      return;
    }
    const scene = this.getScene();
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world, effectOverride);
    const uniformBuffers = this._options.uniformBuffers;
    let useSceneUBO = false;
    if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {
      for (let i = 0; i < uniformBuffers.length; ++i) {
        const bufferName = uniformBuffers[i];
        switch (bufferName) {
          case "Mesh":
            if (mesh) {
              mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              mesh.transferToEffect(world);
            }
            break;
          case "Scene":
            BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
            scene.finalizeSceneUbo();
            useSceneUBO = true;
            break;
        }
      }
    }
    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;
    if (effect && mustRebind) {
      if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
        effect.setMatrix("view", scene.getViewMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
        effect.setMatrix("projection", scene.getProjectionMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
        effect.setMatrix("viewProjection", scene.getTransformMatrix());
        if (this._multiview) {
          effect.setMatrix("viewProjectionR", scene._transformMatrixR);
        }
      }
      if (scene.activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
        effect.setVector3("cameraPosition", scene.activeCamera.globalPosition);
      }
      BindBonesParameters(mesh, effect);
      bindClipPlane(effect, this, scene);
      if (this._useLogarithmicDepth) {
        BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);
      }
      if (mesh) {
        BindFogParameters(scene, mesh, effect);
      }
      let name;
      for (name in this._textures) {
        effect.setTexture(name, this._textures[name]);
      }
      for (name in this._textureArrays) {
        effect.setTextureArray(name, this._textureArrays[name]);
      }
      for (name in this._externalTextures) {
        effect.setExternalTexture(name, this._externalTextures[name]);
      }
      for (name in this._ints) {
        effect.setInt(name, this._ints[name]);
      }
      for (name in this._uints) {
        effect.setUInt(name, this._uints[name]);
      }
      for (name in this._floats) {
        effect.setFloat(name, this._floats[name]);
      }
      for (name in this._floatsArrays) {
        effect.setArray(name, this._floatsArrays[name]);
      }
      for (name in this._colors3) {
        effect.setColor3(name, this._colors3[name]);
      }
      for (name in this._colors3Arrays) {
        effect.setArray3(name, this._colors3Arrays[name]);
      }
      for (name in this._colors4) {
        const color = this._colors4[name];
        effect.setFloat4(name, color.r, color.g, color.b, color.a);
      }
      for (name in this._colors4Arrays) {
        effect.setArray4(name, this._colors4Arrays[name]);
      }
      for (name in this._vectors2) {
        effect.setVector2(name, this._vectors2[name]);
      }
      for (name in this._vectors3) {
        effect.setVector3(name, this._vectors3[name]);
      }
      for (name in this._vectors4) {
        effect.setVector4(name, this._vectors4[name]);
      }
      for (name in this._quaternions) {
        effect.setQuaternion(name, this._quaternions[name]);
      }
      for (name in this._matrices) {
        effect.setMatrix(name, this._matrices[name]);
      }
      for (name in this._matrixArrays) {
        effect.setMatrices(name, this._matrixArrays[name]);
      }
      for (name in this._matrices3x3) {
        effect.setMatrix3x3(name, this._matrices3x3[name]);
      }
      for (name in this._matrices2x2) {
        effect.setMatrix2x2(name, this._matrices2x2[name]);
      }
      for (name in this._vectors2Arrays) {
        effect.setArray2(name, this._vectors2Arrays[name]);
      }
      for (name in this._vectors3Arrays) {
        effect.setArray3(name, this._vectors3Arrays[name]);
      }
      for (name in this._vectors4Arrays) {
        effect.setArray4(name, this._vectors4Arrays[name]);
      }
      for (name in this._quaternionsArrays) {
        effect.setArray4(name, this._quaternionsArrays[name]);
      }
      for (name in this._uniformBuffers) {
        const buffer = this._uniformBuffers[name].getBuffer();
        if (buffer) {
          effect.bindUniformBuffer(buffer, name);
        }
      }
      for (name in this._textureSamplers) {
        effect.setTextureSampler(name, this._textureSamplers[name]);
      }
      for (name in this._storageBuffers) {
        effect.setStorageBuffer(name, this._storageBuffers[name]);
      }
    }
    if (effect && mesh && (mustRebind || !this.isFrozen)) {
      const manager = mesh.morphTargetManager;
      if (manager && manager.numInfluencers > 0) {
        BindMorphTargetParameters(mesh, effect);
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
        (_a = mesh.bakedVertexAnimationManager) == null ? void 0 : _a.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);
      }
    }
    this._afterBind(mesh, effect, subMesh);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    for (const name in this._textures) {
      activeTextures.push(this._textures[name]);
    }
    for (const name in this._textureArrays) {
      const array = this._textureArrays[name];
      for (let index = 0; index < array.length; index++) {
        activeTextures.push(array[index]);
      }
    }
    return activeTextures;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    for (const name in this._textures) {
      if (this._textures[name] === texture) {
        return true;
      }
    }
    for (const name in this._textureArrays) {
      const array = this._textureArrays[name];
      for (let index = 0; index < array.length; index++) {
        if (array[index] === texture) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @returns the cloned material
   */
  clone(name) {
    const result = SerializationHelper.Clone(() => new _ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
    result.name = name;
    result.id = name;
    if (typeof result._shaderPath === "object") {
      result._shaderPath = { ...result._shaderPath };
    }
    this._options = { ...this._options };
    Object.keys(this._options).forEach((propName) => {
      const propValue = this._options[propName];
      if (Array.isArray(propValue)) {
        this._options[propName] = propValue.slice(0);
      }
    });
    this.stencil.copyTo(result.stencil);
    for (const key in this._textures) {
      result.setTexture(key, this._textures[key]);
    }
    for (const key in this._textureArrays) {
      result.setTextureArray(key, this._textureArrays[key]);
    }
    for (const key in this._externalTextures) {
      result.setExternalTexture(key, this._externalTextures[key]);
    }
    for (const key in this._ints) {
      result.setInt(key, this._ints[key]);
    }
    for (const key in this._uints) {
      result.setUInt(key, this._uints[key]);
    }
    for (const key in this._floats) {
      result.setFloat(key, this._floats[key]);
    }
    for (const key in this._floatsArrays) {
      result.setFloats(key, this._floatsArrays[key]);
    }
    for (const key in this._colors3) {
      result.setColor3(key, this._colors3[key]);
    }
    for (const key in this._colors3Arrays) {
      result._colors3Arrays[key] = this._colors3Arrays[key];
    }
    for (const key in this._colors4) {
      result.setColor4(key, this._colors4[key]);
    }
    for (const key in this._colors4Arrays) {
      result._colors4Arrays[key] = this._colors4Arrays[key];
    }
    for (const key in this._vectors2) {
      result.setVector2(key, this._vectors2[key]);
    }
    for (const key in this._vectors3) {
      result.setVector3(key, this._vectors3[key]);
    }
    for (const key in this._vectors4) {
      result.setVector4(key, this._vectors4[key]);
    }
    for (const key in this._quaternions) {
      result.setQuaternion(key, this._quaternions[key]);
    }
    for (const key in this._quaternionsArrays) {
      result._quaternionsArrays[key] = this._quaternionsArrays[key];
    }
    for (const key in this._matrices) {
      result.setMatrix(key, this._matrices[key]);
    }
    for (const key in this._matrixArrays) {
      result._matrixArrays[key] = this._matrixArrays[key].slice();
    }
    for (const key in this._matrices3x3) {
      result.setMatrix3x3(key, this._matrices3x3[key]);
    }
    for (const key in this._matrices2x2) {
      result.setMatrix2x2(key, this._matrices2x2[key]);
    }
    for (const key in this._vectors2Arrays) {
      result.setArray2(key, this._vectors2Arrays[key]);
    }
    for (const key in this._vectors3Arrays) {
      result.setArray3(key, this._vectors3Arrays[key]);
    }
    for (const key in this._vectors4Arrays) {
      result.setArray4(key, this._vectors4Arrays[key]);
    }
    for (const key in this._uniformBuffers) {
      result.setUniformBuffer(key, this._uniformBuffers[key]);
    }
    for (const key in this._textureSamplers) {
      result.setTextureSampler(key, this._textureSamplers[key]);
    }
    for (const key in this._storageBuffers) {
      result.setStorageBuffer(key, this._storageBuffers[key]);
    }
    return result;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      let name;
      for (name in this._textures) {
        this._textures[name].dispose();
      }
      for (name in this._textureArrays) {
        const array = this._textureArrays[name];
        for (let index = 0; index < array.length; index++) {
          array[index].dispose();
        }
      }
    }
    this._textures = {};
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /**
   * Serializes this material in a JSON representation
   * @returns the serialized material object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.ShaderMaterial";
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
    let name;
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.textures = {};
    for (name in this._textures) {
      serializationObject.textures[name] = this._textures[name].serialize();
    }
    serializationObject.textureArrays = {};
    for (name in this._textureArrays) {
      serializationObject.textureArrays[name] = [];
      const array = this._textureArrays[name];
      for (let index = 0; index < array.length; index++) {
        serializationObject.textureArrays[name].push(array[index].serialize());
      }
    }
    serializationObject.ints = {};
    for (name in this._ints) {
      serializationObject.ints[name] = this._ints[name];
    }
    serializationObject.uints = {};
    for (name in this._uints) {
      serializationObject.uints[name] = this._uints[name];
    }
    serializationObject.floats = {};
    for (name in this._floats) {
      serializationObject.floats[name] = this._floats[name];
    }
    serializationObject.floatsArrays = {};
    for (name in this._floatsArrays) {
      serializationObject.floatsArrays[name] = this._floatsArrays[name];
    }
    serializationObject.colors3 = {};
    for (name in this._colors3) {
      serializationObject.colors3[name] = this._colors3[name].asArray();
    }
    serializationObject.colors3Arrays = {};
    for (name in this._colors3Arrays) {
      serializationObject.colors3Arrays[name] = this._colors3Arrays[name];
    }
    serializationObject.colors4 = {};
    for (name in this._colors4) {
      serializationObject.colors4[name] = this._colors4[name].asArray();
    }
    serializationObject.colors4Arrays = {};
    for (name in this._colors4Arrays) {
      serializationObject.colors4Arrays[name] = this._colors4Arrays[name];
    }
    serializationObject.vectors2 = {};
    for (name in this._vectors2) {
      serializationObject.vectors2[name] = this._vectors2[name].asArray();
    }
    serializationObject.vectors3 = {};
    for (name in this._vectors3) {
      serializationObject.vectors3[name] = this._vectors3[name].asArray();
    }
    serializationObject.vectors4 = {};
    for (name in this._vectors4) {
      serializationObject.vectors4[name] = this._vectors4[name].asArray();
    }
    serializationObject.quaternions = {};
    for (name in this._quaternions) {
      serializationObject.quaternions[name] = this._quaternions[name].asArray();
    }
    serializationObject.matrices = {};
    for (name in this._matrices) {
      serializationObject.matrices[name] = this._matrices[name].asArray();
    }
    serializationObject.matrixArray = {};
    for (name in this._matrixArrays) {
      serializationObject.matrixArray[name] = this._matrixArrays[name];
    }
    serializationObject.matrices3x3 = {};
    for (name in this._matrices3x3) {
      serializationObject.matrices3x3[name] = this._matrices3x3[name];
    }
    serializationObject.matrices2x2 = {};
    for (name in this._matrices2x2) {
      serializationObject.matrices2x2[name] = this._matrices2x2[name];
    }
    serializationObject.vectors2Arrays = {};
    for (name in this._vectors2Arrays) {
      serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];
    }
    serializationObject.vectors3Arrays = {};
    for (name in this._vectors3Arrays) {
      serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];
    }
    serializationObject.vectors4Arrays = {};
    for (name in this._vectors4Arrays) {
      serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];
    }
    serializationObject.quaternionsArrays = {};
    for (name in this._quaternionsArrays) {
      serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];
    }
    return serializationObject;
  }
  /**
   * Creates a shader material from parsed shader material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new material
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
    let name;
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    for (name in source.textures) {
      material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));
    }
    for (name in source.textureArrays) {
      const array = source.textureArrays[name];
      const textureArray = [];
      for (let index = 0; index < array.length; index++) {
        textureArray.push(Texture.Parse(array[index], scene, rootUrl));
      }
      material.setTextureArray(name, textureArray);
    }
    for (name in source.ints) {
      material.setInt(name, source.ints[name]);
    }
    for (name in source.uints) {
      material.setUInt(name, source.uints[name]);
    }
    for (name in source.floats) {
      material.setFloat(name, source.floats[name]);
    }
    for (name in source.floatsArrays) {
      material.setFloats(name, source.floatsArrays[name]);
    }
    for (name in source.colors3) {
      material.setColor3(name, Color3.FromArray(source.colors3[name]));
    }
    for (name in source.colors3Arrays) {
      const colors = source.colors3Arrays[name].reduce((arr, num, i) => {
        if (i % 3 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color3.FromArray(color));
      material.setColor3Array(name, colors);
    }
    for (name in source.colors4) {
      material.setColor4(name, Color4.FromArray(source.colors4[name]));
    }
    for (name in source.colors4Arrays) {
      const colors = source.colors4Arrays[name].reduce((arr, num, i) => {
        if (i % 4 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color4.FromArray(color));
      material.setColor4Array(name, colors);
    }
    for (name in source.vectors2) {
      material.setVector2(name, Vector2.FromArray(source.vectors2[name]));
    }
    for (name in source.vectors3) {
      material.setVector3(name, Vector3.FromArray(source.vectors3[name]));
    }
    for (name in source.vectors4) {
      material.setVector4(name, Vector4.FromArray(source.vectors4[name]));
    }
    for (name in source.quaternions) {
      material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));
    }
    for (name in source.matrices) {
      material.setMatrix(name, Matrix.FromArray(source.matrices[name]));
    }
    for (name in source.matrixArray) {
      material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);
    }
    for (name in source.matrices3x3) {
      material.setMatrix3x3(name, source.matrices3x3[name]);
    }
    for (name in source.matrices2x2) {
      material.setMatrix2x2(name, source.matrices2x2[name]);
    }
    for (name in source.vectors2Arrays) {
      material.setArray2(name, source.vectors2Arrays[name]);
    }
    for (name in source.vectors3Arrays) {
      material.setArray3(name, source.vectors3Arrays[name]);
    }
    for (name in source.vectors4Arrays) {
      material.setArray4(name, source.vectors4Arrays[name]);
    }
    for (name in source.quaternionsArrays) {
      material.setArray4(name, source.quaternionsArrays[name]);
    }
    return material;
  }
  /**
   * Creates a new ShaderMaterial from a snippet saved in a remote file
   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromFileAsync(name, url, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            if (name) {
              output.name = name;
            }
            resolve(output);
          } else {
            reject("Unable to load the ShaderMaterial");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  /**
   * Creates a ShaderMaterial from a snippet saved by the Inspector
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.shaderMaterial);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);

export {
  AnimationKeyInterpolation,
  AnimationRange,
  _staticOffsetValueQuaternion,
  _staticOffsetValueVector3,
  _staticOffsetValueVector2,
  _staticOffsetValueSize,
  _staticOffsetValueColor3,
  _staticOffsetValueColor4,
  Animation,
  TargetedAnimation,
  AnimationGroup,
  Light,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoader,
  HemisphericLight,
  ShaderMaterial
};
//# sourceMappingURL=chunk-X5BA27JI.js.map
