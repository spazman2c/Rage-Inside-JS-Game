{
  "version": 3,
  "sources": ["../../../dev/materials/src/cell/cell.fragment.ts", "../../../dev/materials/src/cell/cell.vertex.ts", "../../../dev/materials/src/cell/cellMaterial.ts", "../../../dev/materials/src/custom/customMaterial.ts", "../../../dev/materials/src/custom/pbrCustomMaterial.ts", "../../../dev/materials/src/fire/fire.fragment.ts", "../../../dev/materials/src/fire/fire.vertex.ts", "../../../dev/materials/src/fire/fireMaterial.ts", "../../../dev/materials/src/fur/fur.fragment.ts", "../../../dev/materials/src/fur/fur.vertex.ts", "../../../dev/materials/src/fur/furMaterial.ts", "../../../dev/materials/src/gradient/gradient.fragment.ts", "../../../dev/materials/src/gradient/gradient.vertex.ts", "../../../dev/materials/src/gradient/gradientMaterial.ts", "../../../dev/materials/src/grid/grid.fragment.ts", "../../../dev/materials/src/grid/grid.vertex.ts", "../../../dev/materials/src/grid/gridMaterial.ts", "../../../dev/materials/src/lava/lava.fragment.ts", "../../../dev/materials/src/lava/lava.vertex.ts", "../../../dev/materials/src/lava/lavaMaterial.ts", "../../../dev/materials/src/mix/mix.fragment.ts", "../../../dev/materials/src/mix/mix.vertex.ts", "../../../dev/materials/src/mix/mixMaterial.ts", "../../../dev/materials/src/normal/normal.fragment.ts", "../../../dev/materials/src/normal/normal.vertex.ts", "../../../dev/materials/src/normal/normalMaterial.ts", "../../../dev/materials/src/shadowOnly/shadowOnly.fragment.ts", "../../../dev/materials/src/shadowOnly/shadowOnly.vertex.ts", "../../../dev/materials/src/shadowOnly/shadowOnlyMaterial.ts", "../../../dev/materials/src/simple/simple.fragment.ts", "../../../dev/materials/src/simple/simple.vertex.ts", "../../../dev/materials/src/simple/simpleMaterial.ts", "../../../dev/materials/src/sky/sky.fragment.ts", "../../../dev/materials/src/sky/sky.vertex.ts", "../../../dev/materials/src/sky/skyMaterial.ts", "../../../dev/materials/src/terrain/terrain.fragment.ts", "../../../dev/materials/src/terrain/terrain.vertex.ts", "../../../dev/materials/src/terrain/terrainMaterial.ts", "../../../dev/materials/src/triPlanar/triplanar.fragment.ts", "../../../dev/materials/src/triPlanar/triplanar.vertex.ts", "../../../dev/materials/src/triPlanar/triPlanarMaterial.ts", "../../../dev/materials/src/water/water.fragment.ts", "../../../dev/materials/src/water/water.vertex.ts", "../../../dev/materials/src/water/waterMaterial.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"cellPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvec3 computeCustomDiffuseLighting(lightingInfo info,vec3 diffuseBase,float shadow)\n{diffuseBase=info.diffuse*shadow;\n#ifdef CELLBASIC\nfloat level=1.0;if (info.ndl<0.5)\nlevel=0.5;diffuseBase.rgb*vec3(level,level,level);\n#else\nfloat ToonThresholds[4];ToonThresholds[0]=0.95;ToonThresholds[1]=0.5;ToonThresholds[2]=0.2;ToonThresholds[3]=0.03;float ToonBrightnessLevels[5];ToonBrightnessLevels[0]=1.0;ToonBrightnessLevels[1]=0.8;ToonBrightnessLevels[2]=0.6;ToonBrightnessLevels[3]=0.35;ToonBrightnessLevels[4]=0.2;if (info.ndl>ToonThresholds[0])\n{diffuseBase.rgb*=ToonBrightnessLevels[0];}\nelse if (info.ndl>ToonThresholds[1])\n{diffuseBase.rgb*=ToonBrightnessLevels[1];}\nelse if (info.ndl>ToonThresholds[2])\n{diffuseBase.rgb*=ToonBrightnessLevels[2];}\nelse if (info.ndl>ToonThresholds[3])\n{diffuseBase.rgb*=ToonBrightnessLevels[3];}\nelse\n{diffuseBase.rgb*=ToonBrightnessLevels[4];}\n#endif\nreturn max(diffuseBase,vec3(0.2));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nlightingInfo info;vec3 diffuseBase=vec3(0.,0.,0.);float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const cellPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"cellVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const cellVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./cell.fragment\";\r\nimport \"./cell.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass CellMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public NDOTL = true;\r\n    public CUSTOMUSERLIGHTING = true;\r\n    public CELLBASIC = true;\r\n    public DEPTHPREPASS = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class CellMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"computeHighLevel\")\r\n    public _computeHighLevel: boolean = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public computeHighLevel: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new CellMaterialDefines();\r\n        }\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        defines.CELLBASIC = !this.computeHighLevel;\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"cell\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        return this._diffuseTexture === texture;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"CellMaterial\";\r\n    }\r\n\r\n    public clone(name: string): CellMaterial {\r\n        return SerializationHelper.Clone<CellMaterial>(() => new CellMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.CellMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): CellMaterial {\r\n        return SerializationHelper.Parse(() => new CellMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CellMaterial\", CellMaterial);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\n\r\n/**\r\n * Structure of a custom shader\r\n */\r\nexport class CustomShaderStructure {\r\n    /**\r\n     * Fragment store\r\n     */\r\n    public FragmentStore: string;\r\n    /**\r\n     * Vertex store\r\n     */\r\n    public VertexStore: string;\r\n\r\n    constructor() {}\r\n}\r\n\r\n/**\r\n * Parts of a shader\r\n */\r\nexport class ShaderSpecialParts {\r\n    constructor() {}\r\n\r\n    /**\r\n     * Beginning of the fragment shader\r\n     */\r\n    public Fragment_Begin: string;\r\n    /**\r\n     * Variable definitions of the fragment shader\r\n     */\r\n    public Fragment_Definitions: string;\r\n    /**\r\n     * Beginning of the fragment main function\r\n     */\r\n    public Fragment_MainBegin: string;\r\n    /**\r\n     * End of the fragment main function\r\n     */\r\n    public Fragment_MainEnd: string;\r\n\r\n    /**\r\n     * Diffuse color calculation\r\n     */\r\n    public Fragment_Custom_Diffuse: string;\r\n    /**\r\n     * Before lightning computations\r\n     */\r\n    public Fragment_Before_Lights: string;\r\n    /**\r\n     * Before fog computations\r\n     */\r\n    public Fragment_Before_Fog: string;\r\n    /**\r\n     * Alpha calculations\r\n     */\r\n    public Fragment_Custom_Alpha: string;\r\n    /**\r\n     * Before frag color is assigned\r\n     */\r\n    public Fragment_Before_FragColor: string;\r\n    /**\r\n     * Beginning of the vertex shader\r\n     */\r\n    public Vertex_Begin: string;\r\n    /**\r\n     * Variable definitions of the vertex shader\r\n     */\r\n    public Vertex_Definitions: string;\r\n    /**\r\n     * Start of the main function of the vertex shader\r\n     */\r\n    public Vertex_MainBegin: string;\r\n\r\n    /**\r\n     * Before the world position computation\r\n     */\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    /**\r\n     * Before the normal computation\r\n     */\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    /**\r\n     * After the world position has been computed\r\n     */\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    /**\r\n     * Main end of the vertex shader\r\n     */\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\n/**\r\n * Customized material\r\n */\r\nexport class CustomMaterial extends StandardMaterial {\r\n    /**\r\n     * Index for each created shader\r\n     */\r\n    public static ShaderIndexer = 1;\r\n    /**\r\n     * Custom shader structure\r\n     */\r\n    public CustomParts: ShaderSpecialParts;\r\n    /**\r\n     * Name of the shader\r\n     */\r\n    public _createdShaderName: string;\r\n    /**\r\n     * List of custom uniforms\r\n     */\r\n    public _customUniform: string[];\r\n    /**\r\n     * Names of the new uniforms\r\n     */\r\n    public _newUniforms: string[];\r\n    /**\r\n     * Instances of the new uniform objects\r\n     */\r\n    public _newUniformInstances: { [name: string]: any };\r\n    /**\r\n     * Instances of the new sampler objects\r\n     */\r\n    public _newSamplerInstances: { [name: string]: Texture };\r\n    /**\r\n     * List of the custom attributes\r\n     */\r\n    public _customAttributes: string[];\r\n\r\n    /**\r\n     * Fragment shader string\r\n     */\r\n    public FragmentShader: string;\r\n    /**\r\n     * Vertex shader string\r\n     */\r\n    public VertexShader: string;\r\n\r\n    /**\r\n     * Runs after the material is bound to a mesh\r\n     * @param mesh mesh bound\r\n     * @param effect bound effect used to render\r\n     */\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    if (this._newUniformInstances[el] instanceof Color3) {\r\n                        effect.setColor3(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                } else if (ea[0] == \"vec4\") {\r\n                    if (this._newUniformInstances[el] instanceof Color4) {\r\n                        effect.setDirectColor4(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Builds the material\r\n     * @param shaderName name of the shader\r\n     * @param uniforms list of uniforms\r\n     * @param uniformBuffers list of uniform buffers\r\n     * @param samplers list of samplers\r\n     * @param defines list of defines\r\n     * @param attributes list of attributes\r\n     * @returns the shader name\r\n     */\r\n    public Builder(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: MaterialDefines | string[], attributes?: string[]): string {\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        const name = this._createdShaderName;\r\n\r\n        if (Effect.ShadersStore[name + \"VertexShader\"] && Effect.ShadersStore[name + \"PixelShader\"]) {\r\n            return name;\r\n        }\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this._injectCustomCode(this.VertexShader, \"vertex\");\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this._injectCustomCode(this.FragmentShader, \"fragment\");\r\n\r\n        return name;\r\n    }\r\n\r\n    protected _injectCustomCode(code: string, shaderType: string): string {\r\n        const customCode = this._getCustomCode(shaderType);\r\n\r\n        for (const point in customCode) {\r\n            const injectedCode = customCode[point];\r\n\r\n            if (injectedCode && injectedCode.length > 0) {\r\n                const fullPointName = \"#define \" + point;\r\n                code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _getCustomCode(shaderType: string): { [pointName: string]: string } {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,\r\n                CUSTOM_VERTEX_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Vertex_Definitions || \"\"),\r\n                CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,\r\n                CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,\r\n                CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,\r\n                CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,\r\n                CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed,\r\n            };\r\n        }\r\n        return {\r\n            CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,\r\n            CUSTOM_FRAGMENT_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Fragment_Definitions || \"\"),\r\n            CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,\r\n            CUSTOM_FRAGMENT_UPDATE_DIFFUSE: this.CustomParts.Fragment_Custom_Diffuse,\r\n            CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,\r\n            CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,\r\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,\r\n            CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog,\r\n        };\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.CustomParts = new ShaderSpecialParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"defaultPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"defaultVertexShader\"];\r\n\r\n        CustomMaterial.ShaderIndexer++;\r\n        this._createdShaderName = \"custom_\" + CustomMaterial.ShaderIndexer;\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this.AttachAfterBind(mesh, effect);\r\n        try {\r\n            super._afterBind(mesh, effect, subMesh);\r\n        } catch (e) {}\r\n    }\r\n\r\n    /**\r\n     * Adds a new uniform to the shader\r\n     * @param name the name of the uniform to add\r\n     * @param kind the type of the uniform to add\r\n     * @param param the value of the uniform to add\r\n     * @returns the current material\r\n     */\r\n    public AddUniform(name: string, kind: string, param: any): CustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = new Array();\r\n            this._newUniforms = new Array();\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a custom attribute\r\n     * @param name the name of the attribute\r\n     * @returns the current material\r\n     */\r\n    public AddAttribute(name: string): CustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Diffuse portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Diffuse(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace(\"result\", \"diffuseColor\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Alpha portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Alpha(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Lights portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Lights(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Fog portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Fog(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FragColor portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FragColor(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_PositionUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_NormalUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_After_WorldPosComputed portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CustomMaterial\", CustomMaterial);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { ShaderCodeInliner } from \"core/Engines/Processors/shaderCodeInliner\";\r\nimport type { ICustomShaderNameResolveOptions } from \"core/Materials/material\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\n\r\n/**\r\n * Albedo parts of the shader\r\n */\r\nexport class ShaderAlbedoParts {\r\n    constructor() {}\r\n\r\n    /**\r\n     * Beginning of the fragment shader\r\n     */\r\n    public Fragment_Begin: string;\r\n    /**\r\n     * Fragment definitions\r\n     */\r\n    public Fragment_Definitions: string;\r\n    /**\r\n     * Beginning of the main function\r\n     */\r\n    public Fragment_MainBegin: string;\r\n    /**\r\n     * End of main function\r\n     */\r\n    public Fragment_MainEnd: string;\r\n\r\n    /**\r\n     * Albedo color\r\n     */\r\n    public Fragment_Custom_Albedo: string;\r\n    /**\r\n     * Lights\r\n     */\r\n    public Fragment_Before_Lights: string;\r\n    /**\r\n     * Metallic and roughness\r\n     */\r\n    public Fragment_Custom_MetallicRoughness: string;\r\n    /**\r\n     * Microsurface\r\n     */\r\n    public Fragment_Custom_MicroSurface: string;\r\n    /**\r\n     * Fog computations\r\n     */\r\n    public Fragment_Before_Fog: string;\r\n    /**\r\n     * Alpha\r\n     */\r\n    public Fragment_Custom_Alpha: string;\r\n    /**\r\n     * Color composition\r\n     */\r\n    public Fragment_Before_FinalColorComposition: string;\r\n    /**\r\n     * Fragment color\r\n     */\r\n    public Fragment_Before_FragColor: string;\r\n\r\n    /**\r\n     * Beginning of vertex shader\r\n     */\r\n    public Vertex_Begin: string;\r\n    /**\r\n     * Vertex definitions\r\n     */\r\n    public Vertex_Definitions: string;\r\n    /**\r\n     * Vertex main begin\r\n     */\r\n    public Vertex_MainBegin: string;\r\n\r\n    /**\r\n     * Vertex before position updated\r\n     */\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    /**\r\n     * Vertex before normal updated\r\n     */\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    /**\r\n     * Vertex after world pos computed\r\n     */\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    /**\r\n     * Vertex main end\r\n     */\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\n/**\r\n * @deprecated use ShaderAlbedoParts instead.\r\n */\r\nexport const ShaderAlebdoParts = ShaderAlbedoParts;\r\n\r\nexport class PBRCustomMaterial extends PBRMaterial {\r\n    /**\r\n     * Index for each created shader\r\n     */\r\n    public static ShaderIndexer = 1;\r\n    /**\r\n     * Custom shader structure\r\n     */\r\n    public CustomParts: ShaderAlbedoParts;\r\n    /**\r\n     * Name of the shader\r\n     */\r\n    _createdShaderName: string;\r\n    /**\r\n     * List of custom uniforms\r\n     */\r\n    _customUniform: string[];\r\n    /**\r\n     * Names of the new uniforms\r\n     */\r\n    _newUniforms: string[];\r\n    /**\r\n     * Instances of the new uniform objects\r\n     */\r\n    _newUniformInstances: { [name: string]: any };\r\n    /**\r\n     * Instances of the new sampler objects\r\n     */\r\n    _newSamplerInstances: { [name: string]: Texture };\r\n    /**\r\n     * List of the custom attributes\r\n     */\r\n    _customAttributes: string[];\r\n\r\n    /**\r\n     * Fragment shader string\r\n     */\r\n    public FragmentShader: string;\r\n    /**\r\n     * Vertex shader string\r\n     */\r\n    public VertexShader: string;\r\n\r\n    /**\r\n     * Runs after the material is bound to a mesh\r\n     * @param mesh mesh bound\r\n     * @param effect bound effect used to render\r\n     */\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    if (this._newUniformInstances[el] instanceof Color3) {\r\n                        effect.setColor3(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                } else if (ea[0] == \"vec4\") {\r\n                    if (this._newUniformInstances[el] instanceof Color4) {\r\n                        effect.setDirectColor4(ea[1], this._newUniformInstances[el]);\r\n                    } else {\r\n                        effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                    }\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Builds the material\r\n     * @param shaderName name of the shader\r\n     * @param uniforms list of uniforms\r\n     * @param uniformBuffers list of uniform buffers\r\n     * @param samplers list of samplers\r\n     * @param defines list of defines\r\n     * @param attributes list of attributes\r\n     * @param options options to compile the shader\r\n     * @returns the shader name\r\n     */\r\n    public Builder(\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ): string {\r\n        if (options) {\r\n            const currentProcessing = options.processFinalCode;\r\n            options.processFinalCode = (type: string, code: string) => {\r\n                if (type === \"vertex\") {\r\n                    return currentProcessing ? currentProcessing(type, code) : code;\r\n                }\r\n                const sci = new ShaderCodeInliner(code);\r\n                sci.inlineToken = \"#define pbr_inline\";\r\n                sci.processCode();\r\n                return currentProcessing ? currentProcessing(type, sci.code) : sci.code;\r\n            };\r\n        }\r\n\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        const name = this._createdShaderName;\r\n\r\n        if (Effect.ShadersStore[name + \"VertexShader\"] && Effect.ShadersStore[name + \"PixelShader\"]) {\r\n            return name;\r\n        }\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this._injectCustomCode(this.VertexShader, \"vertex\");\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this._injectCustomCode(this.FragmentShader, \"fragment\");\r\n\r\n        return name;\r\n    }\r\n\r\n    protected _injectCustomCode(code: string, shaderType: string): string {\r\n        const customCode = this._getCustomCode(shaderType);\r\n\r\n        for (const point in customCode) {\r\n            const injectedCode = customCode[point];\r\n\r\n            if (injectedCode && injectedCode.length > 0) {\r\n                const fullPointName = \"#define \" + point;\r\n                code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _getCustomCode(shaderType: string): { [pointName: string]: string } {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_BEGIN: this.CustomParts.Vertex_Begin,\r\n                CUSTOM_VERTEX_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Vertex_Definitions || \"\"),\r\n                CUSTOM_VERTEX_MAIN_BEGIN: this.CustomParts.Vertex_MainBegin,\r\n                CUSTOM_VERTEX_UPDATE_POSITION: this.CustomParts.Vertex_Before_PositionUpdated,\r\n                CUSTOM_VERTEX_UPDATE_NORMAL: this.CustomParts.Vertex_Before_NormalUpdated,\r\n                CUSTOM_VERTEX_MAIN_END: this.CustomParts.Vertex_MainEnd,\r\n                CUSTOM_VERTEX_UPDATE_WORLDPOS: this.CustomParts.Vertex_After_WorldPosComputed,\r\n            };\r\n        }\r\n        return {\r\n            CUSTOM_FRAGMENT_BEGIN: this.CustomParts.Fragment_Begin,\r\n            CUSTOM_FRAGMENT_MAIN_BEGIN: this.CustomParts.Fragment_MainBegin,\r\n            CUSTOM_FRAGMENT_DEFINITIONS: (this._customUniform?.join(\"\\n\") || \"\") + (this.CustomParts.Fragment_Definitions || \"\"),\r\n            CUSTOM_FRAGMENT_UPDATE_ALBEDO: this.CustomParts.Fragment_Custom_Albedo,\r\n            CUSTOM_FRAGMENT_UPDATE_ALPHA: this.CustomParts.Fragment_Custom_Alpha,\r\n            CUSTOM_FRAGMENT_BEFORE_LIGHTS: this.CustomParts.Fragment_Before_Lights,\r\n            CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS: this.CustomParts.Fragment_Custom_MetallicRoughness,\r\n            CUSTOM_FRAGMENT_UPDATE_MICROSURFACE: this.CustomParts.Fragment_Custom_MicroSurface,\r\n            CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION: this.CustomParts.Fragment_Before_FinalColorComposition,\r\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: this.CustomParts.Fragment_Before_FragColor,\r\n            CUSTOM_FRAGMENT_MAIN_END: this.CustomParts.Fragment_MainEnd,\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: this.CustomParts.Fragment_Before_Fog,\r\n        };\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.CustomParts = new ShaderAlbedoParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"pbrPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"pbrVertexShader\"];\r\n\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockAlbedoOpacity>/g, Effect.IncludesShadersStore[\"pbrBlockAlbedoOpacity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockReflectivity>/g, Effect.IncludesShadersStore[\"pbrBlockReflectivity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockFinalColorComposition>/g, Effect.IncludesShadersStore[\"pbrBlockFinalColorComposition\"]);\r\n\r\n        PBRCustomMaterial.ShaderIndexer++;\r\n        this._createdShaderName = \"custompbr_\" + PBRCustomMaterial.ShaderIndexer;\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this.AttachAfterBind(mesh, effect);\r\n        try {\r\n            super._afterBind(mesh, effect, subMesh);\r\n        } catch (e) {}\r\n    }\r\n\r\n    /**\r\n     * Adds a new uniform to the shader\r\n     * @param name the name of the uniform to add\r\n     * @param kind the type of the uniform to add\r\n     * @param param the value of the uniform to add\r\n     * @returns the current material\r\n     */\r\n    public AddUniform(name: string, kind: string, param: any): PBRCustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = new Array();\r\n            this._newUniforms = new Array();\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a custom attribute\r\n     * @param name the name of the attribute\r\n     * @returns the current material\r\n     */\r\n    public AddAttribute(name: string): PBRCustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Albedo portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Albedo(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Albedo = shaderPart.replace(\"result\", \"surfaceAlbedo\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_Alpha portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_Alpha(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Lights portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Lights(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_MetallicRoughness portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_MetallicRoughness(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MetallicRoughness = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Custom_MicroSurface portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Custom_MicroSurface(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MicroSurface = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_Fog portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_Fog(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FinalColorComposition portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FinalColorComposition(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FinalColorComposition = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_Before_FragColor portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_Before_FragColor(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Fragment_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Fragment_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Begin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Definitions portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainBegin portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_PositionUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_Before_NormalUpdated portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_After_WorldPosComputed portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the code on Vertex_MainEnd portion\r\n     * @param shaderPart the code string\r\n     * @returns the current material\r\n     */\r\n    public Vertex_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRCustomMaterial\", PBRCustomMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"firePixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;varying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\nuniform sampler2D distortionSampler;uniform sampler2D opacitySampler;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvec4 bx2(vec4 x)\n{return vec4(2.0)*x-vec4(1.0);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);float alpha=1.0;\n#ifdef DIFFUSE\nconst float distortionAmount0 =0.092;const float distortionAmount1 =0.092;const float distortionAmount2 =0.092;vec2 heightAttenuation=vec2(0.3,0.39);vec4 noise0=texture2D(distortionSampler,vDistortionCoords1);vec4 noise1=texture2D(distortionSampler,vDistortionCoords2);vec4 noise2=texture2D(distortionSampler,vDistortionCoords3);vec4 noiseSum=bx2(noise0)*distortionAmount0+bx2(noise1)*distortionAmount1+bx2(noise2)*distortionAmount2;vec4 perturbedBaseCoords=vec4(vDiffuseUV,0.0,1.0)+noiseSum*(vDiffuseUV.y*heightAttenuation.x+heightAttenuation.y);vec4 opacityColor=texture2D(opacitySampler,perturbedBaseCoords.xy);\n#ifdef ALPHATEST\nif (opacityColor.r<0.1)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor=texture2D(diffuseSampler,perturbedBaseCoords.xy)*2.0;baseColor*=opacityColor;baseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(1.0,1.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec4 color=vec4(baseColor.rgb,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const firePixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"fireVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\nuniform float time;uniform float speed;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef DIFFUSE\nvDiffuseUV=uv;vDiffuseUV.y-=0.2;\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#ifdef DIFFUSE\nvec3 layerSpeed=vec3(-0.2,-0.52,-0.1)*speed;vDistortionCoords1.x=uv.x;vDistortionCoords1.y=uv.y+layerSpeed.x*time/1000.0;vDistortionCoords2.x=uv.x;vDistortionCoords2.y=uv.y+layerSpeed.y*time/1000.0;vDistortionCoords3.x=uv.x;vDistortionCoords3.y=uv.y+layerSpeed.z*time/1000.0;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fireVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./fire.fragment\";\r\nimport \"./fire.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass FireMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public UV1 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public BonesPerMesh = 0;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FireMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"distortionTexture\")\r\n    private _distortionTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public distortionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public speed = 1.0;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n    private _lastTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FireMaterialDefines();\r\n        }\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture.isReady()) {\r\n                    return false;\r\n                } else {\r\n                    defines._needUVs = true;\r\n                    defines.DIFFUSE = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines.ALPHATEST = this._opacityTexture ? true : false;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            defines.POINTSIZE = this.pointsCloud || scene.forcePointsCloud;\r\n            defines.FOG = scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled;\r\n            defines.LOGARITHMICDEPTH = this._useLogarithmicDepth;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fire\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                // Fire\r\n                \"time\",\r\n                \"speed\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [],\r\n                        samplers: [\r\n                            \"diffuseSampler\",\r\n                            // Fire\r\n                            \"distortionSampler\",\r\n                            \"opacitySampler\",\r\n                        ],\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: null,\r\n                        maxSimultaneousLights: 4,\r\n                        transformFeedbackVaryings: null,\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n\r\n                this._activeEffect.setTexture(\"distortionSampler\", this._distortionTexture);\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Time\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", this._lastTime);\r\n\r\n        // Speed\r\n        this._activeEffect.setFloat(\"speed\", this.speed);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._distortionTexture && this._distortionTexture.animations && this._distortionTexture.animations.length > 0) {\r\n            results.push(this._distortionTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            activeTextures.push(this._distortionTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._distortionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FireMaterial\";\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n        if (this._distortionTexture) {\r\n            this._distortionTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FireMaterial {\r\n        return SerializationHelper.Clone<FireMaterial>(() => new FireMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FireMaterial\";\r\n        serializationObject.diffuseColor = this.diffuseColor.asArray();\r\n        serializationObject.speed = this.speed;\r\n\r\n        if (this._diffuseTexture) {\r\n            serializationObject._diffuseTexture = this._diffuseTexture.serialize();\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            serializationObject._distortionTexture = this._distortionTexture.serialize();\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            serializationObject._opacityTexture = this._opacityTexture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FireMaterial {\r\n        const material = new FireMaterial(source.name, scene);\r\n\r\n        material.diffuseColor = Color3.FromArray(source.diffuseColor);\r\n        material.speed = source.speed;\r\n\r\n        material.alpha = source.alpha;\r\n\r\n        material.id = source.id;\r\n\r\n        Tags.AddTagsTo(material, source.tags);\r\n        material.backFaceCulling = source.backFaceCulling;\r\n        material.wireframe = source.wireframe;\r\n\r\n        if (source._diffuseTexture) {\r\n            material._diffuseTexture = Texture.Parse(source._diffuseTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._distortionTexture) {\r\n            material._distortionTexture = Texture.Parse(source._distortionTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._opacityTexture) {\r\n            material._opacityTexture = Texture.Parse(source._opacityTexture, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FireMaterial\", FireMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"furPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;uniform vec4 furColor;uniform float furLength;varying vec3 vPositionW;varying float vfur_length;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform float furOcclusion;uniform sampler2D furTexture;varying vec2 vFurUV;\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<fogFragmentDeclaration>\n#include<clipPlaneFragmentDeclaration>\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=furColor;vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor*=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef HIGHLEVEL\nvec4 furTextureColor=texture2D(furTexture,vec2(vFurUV.x,vFurUV.y));if (furTextureColor.a<=0.0 || furTextureColor.g<furOffset) {discard;}\nfloat occlusion=mix(0.0,furTextureColor.b*1.2,furOffset);baseColor=vec4(baseColor.xyz*max(occlusion,furOcclusion),1.1-furOffset);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase.rgb*baseColor.rgb,0.0,1.0);\n#ifdef HIGHLEVEL\nvec4 color=vec4(finalDiffuse,alpha);\n#else\nfloat r=vfur_length/furLength*0.5;vec4 color=vec4(finalDiffuse*(0.5+r),alpha);\n#endif\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const furPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"furVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\nuniform float furLength;uniform float furAngle;\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform vec3 furGravity;uniform float furTime;uniform float furSpacing;uniform float furDensity;\n#endif\n#ifdef HEIGHTMAP\nuniform sampler2D heightTexture;\n#endif\n#ifdef HIGHLEVEL\nvarying vec2 vFurUV;\n#endif\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\nvarying float vfur_length;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nfloat r=Rand(position);\n#ifdef HEIGHTMAP\n#if __VERSION__>100\nvfur_length=furLength*texture(heightTexture,uv).x;\n#else\nvfur_length=furLength*texture2D(heightTexture,uv).r;\n#endif\n#else \nvfur_length=(furLength*r);\n#endif\nvec3 tangent1=vec3(normal.y,-normal.x,0);vec3 tangent2=vec3(-normal.z,0,normal.x);r=Rand(tangent1*r);float J=(2.0+4.0*r);r=Rand(tangent2*r);float K=(2.0+2.0*r);tangent1=tangent1*J+tangent2*K;tangent1=normalize(tangent1);vec3 newPosition=position+normal*vfur_length*cos(furAngle)+tangent1*vfur_length*sin(furAngle);\n#ifdef HIGHLEVEL\nvec3 forceDirection=vec3(0.0,0.0,0.0);forceDirection.x=sin(furTime+position.x*0.05)*0.2;forceDirection.y=cos(furTime*0.7+position.y*0.04)*0.2;forceDirection.z=sin(furTime*0.7+position.z*0.04)*0.2;vec3 displacement=vec3(0.0,0.0,0.0);displacement=furGravity+forceDirection;float displacementFactor=pow(furOffset,3.0);vec3 aNormal=normal;aNormal.xyz+=displacement*displacementFactor;newPosition=vec3(newPosition.x,newPosition.y,newPosition.z)+(normalize(aNormal)*furOffset*furSpacing);\n#endif\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\ngl_Position=viewProjection*finalWorld*vec4(newPosition,1.0);vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#ifdef HIGHLEVEL\nvFurUV=vDiffuseUV*furDensity;\n#endif\n#else\n#ifdef HIGHLEVEL\nvFurUV=uv*furDensity;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const furVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\n\r\nimport \"./fur.fragment\";\r\nimport \"./fur.vertex\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass FurMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public HEIGHTMAP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public HIGHLEVEL = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FurMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"heightTexture\")\r\n    private _heightTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public heightTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public furLength: number = 1;\r\n\r\n    @serialize()\r\n    public furAngle: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public furColor = new Color3(0.44, 0.21, 0.02);\r\n\r\n    @serialize()\r\n    public furOffset: number = 0.0;\r\n\r\n    @serialize()\r\n    public furSpacing: number = 12;\r\n\r\n    @serializeAsVector3()\r\n    public furGravity = new Vector3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public furSpeed: number = 100;\r\n\r\n    @serialize()\r\n    public furDensity: number = 20;\r\n\r\n    @serialize()\r\n    public furOcclusion: number = 0.0;\r\n\r\n    public furTexture: DynamicTexture;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize()\r\n    public highLevelFur: boolean = true;\r\n\r\n    public _meshes: AbstractMesh[];\r\n\r\n    private _furTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    @serialize()\r\n    public get furTime() {\r\n        return this._furTime;\r\n    }\r\n\r\n    public set furTime(furTime: number) {\r\n        this._furTime = furTime;\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public updateFur(): void {\r\n        for (let i = 1; i < this._meshes.length; i++) {\r\n            const offsetFur = <FurMaterial>this._meshes[i].material;\r\n\r\n            offsetFur.furLength = this.furLength;\r\n            offsetFur.furAngle = this.furAngle;\r\n            offsetFur.furGravity = this.furGravity;\r\n            offsetFur.furSpacing = this.furSpacing;\r\n            offsetFur.furSpeed = this.furSpeed;\r\n            offsetFur.furColor = this.furColor;\r\n            offsetFur.diffuseTexture = this.diffuseTexture;\r\n            offsetFur.furTexture = this.furTexture;\r\n            offsetFur.highLevelFur = this.highLevelFur;\r\n            offsetFur.furTime = this.furTime;\r\n            offsetFur.furDensity = this.furDensity;\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FurMaterialDefines();\r\n        }\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this.diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n                if (this.heightTexture && engine.getCaps().maxVertexTextureImageUnits) {\r\n                    if (!this.heightTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.HEIGHTMAP = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        if (this.highLevelFur !== defines.HIGHLEVEL) {\r\n            defines.HIGHLEVEL = true;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fur\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"furLength\",\r\n                \"furAngle\",\r\n                \"furColor\",\r\n                \"furOffset\",\r\n                \"furGravity\",\r\n                \"furTime\",\r\n                \"furSpacing\",\r\n                \"furDensity\",\r\n                \"furOcclusion\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers = [\"diffuseSampler\", \"heightTexture\", \"furTexture\"];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this._heightTexture) {\r\n                this._activeEffect.setTexture(\"heightTexture\", this._heightTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"furLength\", this.furLength);\r\n        this._activeEffect.setFloat(\"furAngle\", this.furAngle);\r\n        this._activeEffect.setColor4(\"furColor\", this.furColor, 1.0);\r\n\r\n        if (this.highLevelFur) {\r\n            this._activeEffect.setVector3(\"furGravity\", this.furGravity);\r\n            this._activeEffect.setFloat(\"furOffset\", this.furOffset);\r\n            this._activeEffect.setFloat(\"furSpacing\", this.furSpacing);\r\n            this._activeEffect.setFloat(\"furDensity\", this.furDensity);\r\n            this._activeEffect.setFloat(\"furOcclusion\", this.furOcclusion);\r\n\r\n            this._furTime += this.getScene().getEngine().getDeltaTime() / this.furSpeed;\r\n            this._activeEffect.setFloat(\"furTime\", this._furTime);\r\n\r\n            this._activeEffect.setTexture(\"furTexture\", this.furTexture);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.heightTexture && this.heightTexture.animations && this.heightTexture.animations.length > 0) {\r\n            results.push(this.heightTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._heightTexture) {\r\n            activeTextures.push(this._heightTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._heightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        if (this._meshes) {\r\n            for (let i = 1; i < this._meshes.length; i++) {\r\n                const mat = this._meshes[i].material;\r\n\r\n                if (mat) {\r\n                    mat.dispose(forceDisposeEffect);\r\n                }\r\n                this._meshes[i].dispose();\r\n            }\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FurMaterial {\r\n        return SerializationHelper.Clone(() => new FurMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FurMaterial\";\r\n\r\n        if (this._meshes) {\r\n            serializationObject.sourceMeshName = this._meshes[0].name;\r\n            serializationObject.quality = this._meshes.length;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FurMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FurMaterial {\r\n        const material = SerializationHelper.Parse(() => new FurMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.sourceMeshName && material.highLevelFur) {\r\n            scene.executeWhenReady(() => {\r\n                const sourceMesh = <Mesh>scene.getMeshByName(source.sourceMeshName);\r\n                if (sourceMesh) {\r\n                    const furTexture = FurMaterial.GenerateTexture(\"Fur Texture\", scene);\r\n                    material.furTexture = furTexture;\r\n                    FurMaterial.FurifyMesh(sourceMesh, source.quality);\r\n                }\r\n            });\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    public static GenerateTexture(name: string, scene: Scene): DynamicTexture {\r\n        // Generate fur textures\r\n        const texture = new DynamicTexture(\"FurTexture \" + name, 256, scene, true);\r\n        const context = texture.getContext();\r\n\r\n        for (let i = 0; i < 20000; ++i) {\r\n            context.fillStyle = \"rgba(255, \" + Math.floor(Math.random() * 255) + \", \" + Math.floor(Math.random() * 255) + \", 1)\";\r\n            context.fillRect(Math.random() * texture.getSize().width, Math.random() * texture.getSize().height, 2, 2);\r\n        }\r\n\r\n        texture.update(false);\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n\r\n        return texture;\r\n    }\r\n\r\n    // Creates and returns an array of meshes used as shells for the Fur Material\r\n    // that can be disposed later in your code\r\n    // The quality is in interval [0, 100]\r\n    public static FurifyMesh(sourceMesh: Mesh, quality: number): Mesh[] {\r\n        const meshes = [sourceMesh];\r\n        const mat: FurMaterial = <FurMaterial>sourceMesh.material;\r\n        let i;\r\n\r\n        if (!(mat instanceof FurMaterial)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"The material of the source mesh must be a Fur Material\";\r\n        }\r\n\r\n        for (i = 1; i < quality; i++) {\r\n            const offsetFur = new FurMaterial(mat.name + i, sourceMesh.getScene());\r\n            sourceMesh.getScene().materials.pop();\r\n            Tags.EnableFor(offsetFur);\r\n            Tags.AddTagsTo(offsetFur, \"furShellMaterial\");\r\n\r\n            offsetFur.furLength = mat.furLength;\r\n            offsetFur.furAngle = mat.furAngle;\r\n            offsetFur.furGravity = mat.furGravity;\r\n            offsetFur.furSpacing = mat.furSpacing;\r\n            offsetFur.furSpeed = mat.furSpeed;\r\n            offsetFur.furColor = mat.furColor;\r\n            offsetFur.diffuseTexture = mat.diffuseTexture;\r\n            offsetFur.furOffset = i / quality;\r\n            offsetFur.furTexture = mat.furTexture;\r\n            offsetFur.highLevelFur = mat.highLevelFur;\r\n            offsetFur.furTime = mat.furTime;\r\n            offsetFur.furDensity = mat.furDensity;\r\n\r\n            const offsetMesh = sourceMesh.clone(sourceMesh.name + i) as Mesh;\r\n\r\n            offsetMesh.material = offsetFur;\r\n            offsetMesh.skeleton = sourceMesh.skeleton;\r\n            offsetMesh.position = Vector3.Zero();\r\n            meshes.push(offsetMesh);\r\n        }\r\n\r\n        for (i = 1; i < meshes.length; i++) {\r\n            meshes[i].parent = sourceMesh;\r\n        }\r\n\r\n        (<FurMaterial>sourceMesh.material)._meshes = meshes;\r\n\r\n        return meshes;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FurMaterial\", FurMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gradientPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 topColor;uniform vec4 bottomColor;uniform float offset;uniform float scale;uniform float smoothness;varying vec3 vPositionW;varying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);float h=vPosition.y*scale+offset;float mysmoothness=clamp(smoothness,0.01,max(smoothness,10.));vec4 baseColor=mix(bottomColor,topColor,max(pow(max(h,0.0),mysmoothness),0.0));vec3 diffuseColor=baseColor.rgb;float alpha=baseColor.a;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef EMISSIVE\nvec3 diffuseBase=baseColor.rgb;\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);\n#endif\nlightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gradientPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"gradientVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;varying vec3 vPosition;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);vPosition=position;\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gradientVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./gradient.fragment\";\r\nimport \"./gradient.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass GradientMaterialDefines extends MaterialDefines {\r\n    public EMISSIVE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class GradientMaterial extends PushMaterial {\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    // The gradient top color, red by default\r\n    @serializeAsColor3()\r\n    public topColor = new Color3(1, 0, 0);\r\n\r\n    @serialize()\r\n    public topColorAlpha = 1.0;\r\n\r\n    // The gradient top color, blue by default\r\n    @serializeAsColor3()\r\n    public bottomColor = new Color3(0, 0, 1);\r\n\r\n    @serialize()\r\n    public bottomColorAlpha = 1.0;\r\n\r\n    // Gradient offset\r\n    @serialize()\r\n    public offset = 0;\r\n\r\n    @serialize()\r\n    public scale = 1.0;\r\n\r\n    @serialize()\r\n    public smoothness = 1.0;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this.topColorAlpha < 1.0 || this.bottomColorAlpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GradientMaterialDefines();\r\n        }\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        defines.EMISSIVE = this._disableLighting;\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"gradient\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"logarithmicDepthConstant\",\r\n                \"topColor\",\r\n                \"bottomColor\",\r\n                \"offset\",\r\n                \"smoothness\",\r\n                \"scale\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers: string[] = [];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setColor4(\"topColor\", this.topColor, this.topColorAlpha);\r\n        this._activeEffect.setColor4(\"bottomColor\", this.bottomColor, this.bottomColorAlpha);\r\n        this._activeEffect.setFloat(\"offset\", this.offset);\r\n        this._activeEffect.setFloat(\"scale\", this.scale);\r\n        this._activeEffect.setFloat(\"smoothness\", this.smoothness);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GradientMaterial {\r\n        return SerializationHelper.Clone(() => new GradientMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GradientMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GradientMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GradientMaterial {\r\n        return SerializationHelper.Parse(() => new GradientMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GradientMaterial\", GradientMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;uniform float visibility;uniform vec3 mainColor;uniform vec3 lineColor;uniform vec4 gridControl;uniform vec3 gridOffset;varying vec3 vPosition;varying vec3 vNormal;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;uniform sampler2D opacitySampler;uniform vec2 vOpacityInfos;\n#endif\nfloat getDynamicVisibility(float position) {float majorGridFrequency=gridControl.y;if (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\n{return 1.0;}\nreturn gridControl.z;}\nfloat getAnisotropicAttenuation(float differentialLength) {const float maxNumberOfLines=10.0;return clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);}\nfloat isPointOnLine(float position,float differentialLength) {float fractionPartOfPosition=position-floor(position+0.5); \nfractionPartOfPosition/=differentialLength; \n#ifdef ANTIALIAS\nfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);float result=0.5+0.5*cos(fractionPartOfPosition*PI); \nreturn result;\n#else\nreturn abs(fractionPartOfPosition)<SQRT2/4. ? 1. : 0.;\n#endif\n}\nfloat contributionOnAxis(float position) {float differentialLength=length(vec2(dFdx(position),dFdy(position)));differentialLength*=SQRT2; \nfloat result=isPointOnLine(position,differentialLength);float dynamicVisibility=getDynamicVisibility(position);result*=dynamicVisibility;float anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);result*=anisotropicAttenuation;return result;}\nfloat normalImpactOnAxis(float x) {float normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);return normalImpact;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;vec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;float x=contributionOnAxis(gridPos.x);float y=contributionOnAxis(gridPos.y);float z=contributionOnAxis(gridPos.z);vec3 normal=normalize(vNormal);x*=normalImpactOnAxis(normal.x);y*=normalImpactOnAxis(normal.y);z*=normalImpactOnAxis(normal.z);\n#ifdef MAX_LINE\nfloat grid=clamp(max(max(x,y),z),0.,1.);\n#else\nfloat grid=clamp(x+y+z,0.,1.);\n#endif\nvec3 color=mix(mainColor,lineColor,grid);\n#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\n#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\n#endif\n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\n#endif\ngl_FragColor=vec4(color.rgb,opacity*visibility);\n#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\n#endif\n#else\n#endif\n#include<logDepthFragment>\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"gridVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#include<instancesDeclaration>\nuniform mat4 projection;uniform mat4 view;varying vec3 vPosition;varying vec3 vNormal;\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;gl_Position=projection*cameraSpacePosition;\n#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\nif (vOpacityInfos.x==0.)\n{vOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));}\nelse\n{vOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));}\n#endif \n#include<logDepthVertex>\nvPosition=position;vNormal=normal;\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, serializeAsVector3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector4, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public OPACITY = false;\r\n    public ANTIALIAS = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public MAX_LINE = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsVector3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Whether to antialias the grid\r\n     */\r\n    @serialize()\r\n    public antialias = true;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    /**\r\n     * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\r\n     */\r\n    @serialize()\r\n    public useMaxLine = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    /**\r\n     * Texture to define opacity of the grid\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the grid requires alpha blending.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.MAX_LINE !== this.useMaxLine) {\r\n            defines.MAX_LINE = !defines.MAX_LINE;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.ANTIALIAS !== this.antialias) {\r\n            defines.ANTIALIAS = !defines.ANTIALIAS;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), this, defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Defines\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"grid\",\r\n                        attribs,\r\n                        [\r\n                            \"projection\",\r\n                            \"mainColor\",\r\n                            \"lineColor\",\r\n                            \"gridControl\",\r\n                            \"gridOffset\",\r\n                            \"vFogInfos\",\r\n                            \"vFogColor\",\r\n                            \"world\",\r\n                            \"view\",\r\n                            \"opacityMatrix\",\r\n                            \"vOpacityInfos\",\r\n                            \"visibility\",\r\n                            \"logarithmicDepthConstant\",\r\n                        ],\r\n                        [\"opacitySampler\"],\r\n                        join,\r\n                        undefined,\r\n                        this.onCompiled,\r\n                        this.onError\r\n                    ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n        }\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"lavaPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;uniform float time;uniform float speed;uniform float movingSpeed;uniform vec3 fogColor;uniform sampler2D noiseTexture;uniform float fogDensity;varying float noise;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nfloat random( vec3 scale,float seed ){return fract( sin( dot( gl_FragCoord.xyz+seed,scale ) )*43758.5453+seed ) ;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nvec4 noiseTex=texture2D( noiseTexture,vDiffuseUV );vec2 T1=vDiffuseUV+vec2( 1.5,-1.5 )*time *0.02;vec2 T2=vDiffuseUV+vec2( -0.5,2.0 )*time*0.01*speed;T1.x+=noiseTex.x*2.0;T1.y+=noiseTex.y*2.0;T2.x-=noiseTex.y*0.2+time*0.001*movingSpeed;T2.y+=noiseTex.z*0.2+time*0.002*movingSpeed;float p=texture2D( noiseTexture,T1*3.0 ).a;vec4 lavaColor=texture2D( diffuseSampler,T2*4.0);vec4 temp=lavaColor*( vec4( p,p,p,p )*2. )+( lavaColor*lavaColor-0.1 );baseColor=temp;float depth=gl_FragCoord.z*4.0;const float LOG2=1.442695;float fogFactor=exp2(-fogDensity*fogDensity*depth*depth*LOG2 );fogFactor=1.0-clamp( fogFactor,0.0,1.0 );baseColor=mix( baseColor,vec4( fogColor,baseColor.w ),fogFactor );diffuseColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lavaPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"lavaVertexShader\";\nconst shader = `precision highp float;uniform float time;uniform float lowFrequencySpeed;varying float noise;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n/* NOISE FUNCTIONS */\nvec3 mod289(vec3 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 mod289(vec4 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 permute(vec4 x)\n{return mod289(((x*34.0)+1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{return 1.79284291400159-0.85373472095314*r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat pnoise(vec3 P,vec3 rep)\n{vec3 Pi0=mod(floor(P),rep); \nvec3 Pi1=mod(Pi0+vec3(1.0),rep); \nPi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P); \nvec3 Pf1=Pf0-vec3(1.0); \nvec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}\n/* END FUNCTION */\nfloat turbulence( vec3 p ) {float w=100.0;float t=-.5;for (float f=1.0 ; f<=10.0 ; f++ ){float power=pow( 2.0,f );t+=abs( pnoise( vec3( power*p ),vec3( 10.0,10.0,10.0 ) )/power );}\nreturn t;}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef NORMAL\nnoise=10.0* -.10*turbulence( .5*normal+time*1.15 );float b=lowFrequencySpeed*5.0*pnoise( 0.05*position +vec3(time*1.025),vec3( 100.0 ) );float displacement=- 1.5*noise+b;vec3 newPosition=position+normal*displacement;gl_Position=viewProjection*finalWorld*vec4( newPosition,1.0 );vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lavaVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./lava.fragment\";\r\nimport \"./lava.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass LavaMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public UNLIT = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class LavaMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture()\r\n    public noiseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public fogColor: Color3;\r\n\r\n    @serialize()\r\n    public speed: number = 1;\r\n\r\n    @serialize()\r\n    public movingSpeed: number = 1;\r\n\r\n    @serialize()\r\n    public lowFrequencySpeed: number = 1;\r\n\r\n    @serialize()\r\n    public fogDensity: number = 0.15;\r\n\r\n    private _lastTime: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"unlit\")\r\n    private _unlit = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public unlit: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new LavaMaterialDefines();\r\n        }\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n\r\n        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"lava\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"time\",\r\n                \"speed\",\r\n                \"movingSpeed\",\r\n                \"fogColor\",\r\n                \"fogDensity\",\r\n                \"lowFrequencySpeed\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const samplers = [\"diffuseSampler\", \"noiseTexture\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        defines.UNLIT = this._unlit;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                this._activeEffect.setTexture(\"noiseTexture\", this.noiseTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", (this._lastTime * this.speed) / 1000);\r\n\r\n        if (!this.fogColor) {\r\n            this.fogColor = Color3.Black();\r\n        }\r\n        this._activeEffect.setColor3(\"fogColor\", this.fogColor);\r\n        this._activeEffect.setFloat(\"fogDensity\", this.fogDensity);\r\n\r\n        this._activeEffect.setFloat(\"lowFrequencySpeed\", this.lowFrequencySpeed);\r\n        this._activeEffect.setFloat(\"movingSpeed\", this.movingSpeed);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.noiseTexture && this.noiseTexture.animations && this.noiseTexture.animations.length > 0) {\r\n            results.push(this.noiseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n        if (this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): LavaMaterial {\r\n        return SerializationHelper.Clone(() => new LavaMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.LavaMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"LavaMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): LavaMaterial {\r\n        return SerializationHelper.Parse(() => new LavaMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LavaMaterial\", LavaMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"mixPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform sampler2D mixMap1Sampler;uniform vec2 vTextureInfos;\n#ifdef MIXMAP2\nuniform sampler2D mixMap2Sampler;\n#endif\nuniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform sampler2D diffuse4Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;uniform vec2 diffuse4Infos;\n#ifdef MIXMAP2\nuniform sampler2D diffuse5Sampler;uniform sampler2D diffuse6Sampler;uniform sampler2D diffuse7Sampler;uniform sampler2D diffuse8Sampler;uniform vec2 diffuse5Infos;uniform vec2 diffuse6Infos;uniform vec2 diffuse7Infos;uniform vec2 diffuse8Infos;\n#endif\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 finalMixColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef MIXMAP2\nvec4 mixColor2=vec4(1.,1.,1.,1.);\n#endif\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nvec4 mixColor=texture2D(mixMap1Sampler,vTextureUV);\n#include<depthPrePass>\nmixColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);vec4 diffuse4Color=texture2D(diffuse4Sampler,vTextureUV*diffuse4Infos);diffuse1Color.rgb*=mixColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,mixColor.g);diffuse3Color.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse3Color.rgb,diffuse4Color.rgb,1.0-mixColor.a);\n#ifdef MIXMAP2\nmixColor=texture2D(mixMap2Sampler,vTextureUV);mixColor.rgb*=vTextureInfos.y;vec4 diffuse5Color=texture2D(diffuse5Sampler,vTextureUV*diffuse5Infos);vec4 diffuse6Color=texture2D(diffuse6Sampler,vTextureUV*diffuse6Infos);vec4 diffuse7Color=texture2D(diffuse7Sampler,vTextureUV*diffuse7Infos);vec4 diffuse8Color=texture2D(diffuse8Sampler,vTextureUV*diffuse8Infos);diffuse5Color.rgb=mix(finalMixColor.rgb,diffuse5Color.rgb,mixColor.r);diffuse6Color.rgb=mix(diffuse5Color.rgb,diffuse6Color.rgb,mixColor.g);diffuse7Color.rgb=mix(diffuse6Color.rgb,diffuse7Color.rgb,mixColor.b);finalMixColor.rgb=mix(diffuse7Color.rgb,diffuse8Color.rgb,1.0-mixColor.a);\n#endif\n#endif\n#ifdef VERTEXCOLOR\nfinalMixColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*finalMixColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const mixPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"mixVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const mixVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./mix.fragment\";\r\nimport \"./mix.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass MixMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public MIXMAP2 = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class MixMaterial extends PushMaterial {\r\n    /**\r\n     * Mix textures\r\n     */\r\n\r\n    @serializeAsTexture(\"mixTexture1\")\r\n    private _mixTexture1: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture1: BaseTexture;\r\n\r\n    @serializeAsTexture(\"mixTexture2\")\r\n    private _mixTexture2: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture2: BaseTexture;\r\n\r\n    /**\r\n     * Diffuse textures\r\n     */\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture4: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture4: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture5: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture5: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture6: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture6: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture7: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture7: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture8: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture8: Texture;\r\n\r\n    /**\r\n     * Uniforms\r\n     */\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new MixMaterialDefines();\r\n        }\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this._mixTexture1 || !this._mixTexture1.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture1 || !this._diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n\r\n                if (!this._diffuseTexture2 || !this._diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture3 || !this._diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture4 || !this._diffuseTexture4.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                if (this._mixTexture2) {\r\n                    if (!this._mixTexture2.isReady()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.MIXMAP2 = true;\r\n\r\n                    if (!this._diffuseTexture5 || !this._diffuseTexture5.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture6 || !this._diffuseTexture6.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture7 || !this._diffuseTexture7.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture8 || !this._diffuseTexture8.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"mix\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n                \"diffuse4Infos\",\r\n                \"diffuse5Infos\",\r\n                \"diffuse6Infos\",\r\n                \"diffuse7Infos\",\r\n                \"diffuse8Infos\",\r\n            ];\r\n            const samplers = [\r\n                \"mixMap1Sampler\",\r\n                \"mixMap2Sampler\",\r\n                \"diffuse1Sampler\",\r\n                \"diffuse2Sampler\",\r\n                \"diffuse3Sampler\",\r\n                \"diffuse4Sampler\",\r\n                \"diffuse5Sampler\",\r\n                \"diffuse6Sampler\",\r\n                \"diffuse7Sampler\",\r\n                \"diffuse8Sampler\",\r\n            ];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._mixTexture1) {\r\n                this._activeEffect.setTexture(\"mixMap1Sampler\", this._mixTexture1);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture1.coordinatesIndex, this._mixTexture1.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture1.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                    if (this._diffuseTexture4) {\r\n                        this._activeEffect.setTexture(\"diffuse4Sampler\", this._diffuseTexture4);\r\n                        this._activeEffect.setFloat2(\"diffuse4Infos\", this._diffuseTexture4.uScale, this._diffuseTexture4.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._mixTexture2) {\r\n                this._activeEffect.setTexture(\"mixMap2Sampler\", this._mixTexture2);\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture5) {\r\n                        this._activeEffect.setTexture(\"diffuse5Sampler\", this._diffuseTexture5);\r\n                        this._activeEffect.setFloat2(\"diffuse5Infos\", this._diffuseTexture5.uScale, this._diffuseTexture5.vScale);\r\n                    }\r\n                    if (this._diffuseTexture6) {\r\n                        this._activeEffect.setTexture(\"diffuse6Sampler\", this._diffuseTexture6);\r\n                        this._activeEffect.setFloat2(\"diffuse6Infos\", this._diffuseTexture6.uScale, this._diffuseTexture6.vScale);\r\n                    }\r\n                    if (this._diffuseTexture7) {\r\n                        this._activeEffect.setTexture(\"diffuse7Sampler\", this._diffuseTexture7);\r\n                        this._activeEffect.setFloat2(\"diffuse7Infos\", this._diffuseTexture7.uScale, this._diffuseTexture7.vScale);\r\n                    }\r\n                    if (this._diffuseTexture8) {\r\n                        this._activeEffect.setTexture(\"diffuse8Sampler\", this._diffuseTexture8);\r\n                        this._activeEffect.setFloat2(\"diffuse8Infos\", this._diffuseTexture8.uScale, this._diffuseTexture8.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._mixTexture1 && this._mixTexture1.animations && this._mixTexture1.animations.length > 0) {\r\n            results.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._mixTexture2 && this._mixTexture2.animations && this._mixTexture2.animations.length > 0) {\r\n            results.push(this._mixTexture2);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1) {\r\n            activeTextures.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._diffuseTexture4) {\r\n            activeTextures.push(this._diffuseTexture4);\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2) {\r\n            activeTextures.push(this._mixTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture5) {\r\n            activeTextures.push(this._diffuseTexture5);\r\n        }\r\n\r\n        if (this._diffuseTexture6) {\r\n            activeTextures.push(this._diffuseTexture6);\r\n        }\r\n\r\n        if (this._diffuseTexture7) {\r\n            activeTextures.push(this._diffuseTexture7);\r\n        }\r\n\r\n        if (this._diffuseTexture8) {\r\n            activeTextures.push(this._diffuseTexture8);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture4 === texture) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture5 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture6 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture7 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture8 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._mixTexture1) {\r\n            this._mixTexture1.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): MixMaterial {\r\n        return SerializationHelper.Clone(() => new MixMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.MixMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"MixMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): MixMaterial {\r\n        return SerializationHelper.Parse(() => new MixMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MixMaterial\", MixMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"normalPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef LIGHTING\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef NORMAL\nbaseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef LIGHTING\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse= baseColor.rgb;\n#endif\nvec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const normalPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"normalVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const normalVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./normal.fragment\";\r\nimport \"./normal.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass NormalMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public LIGHTING = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class NormalMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return this.needAlphaBlending() || mesh.visibility < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NormalMaterialDefines();\r\n        }\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n        PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        defines.LIGHTING = !this._disableLighting;\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"normal\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): NormalMaterial {\r\n        return SerializationHelper.Clone(() => new NormalMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.NormalMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"NormalMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): NormalMaterial {\r\n        return SerializationHelper.Parse(() => new NormalMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalMaterial\", NormalMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"shadowOnlyPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform float alpha;uniform vec3 shadowColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"shadowOnlyVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./shadowOnly.fragment\";\r\nimport \"./shadowOnly.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { CascadedShadowGenerator } from \"core/Lights/Shadows/cascadedShadowGenerator\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class ShadowOnlyMaterial extends PushMaterial {\r\n    private _activeLight: IShadowLight;\r\n    private _needAlphaBlending = true;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public shadowColor = Color3.Black();\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this._needAlphaBlending;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public get activeLight(): IShadowLight {\r\n        return this._activeLight;\r\n    }\r\n\r\n    public set activeLight(light: IShadowLight) {\r\n        this._activeLight = light;\r\n    }\r\n\r\n    private _getFirstShadowLightForMesh(mesh: AbstractMesh): Nullable<IShadowLight> {\r\n        for (const light of mesh.lightSources) {\r\n            if (light.shadowEnabled) {\r\n                return light as IShadowLight;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new ShadowOnlyMaterialDefines();\r\n        }\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Ensure that active light is the first shadow light\r\n        if (this._activeLight) {\r\n            for (const light of mesh.lightSources) {\r\n                if (light.shadowEnabled) {\r\n                    if (this._activeLight === light) {\r\n                        break; // We are good\r\n                    }\r\n\r\n                    const lightPosition = mesh.lightSources.indexOf(this._activeLight);\r\n\r\n                    if (lightPosition !== -1) {\r\n                        mesh.lightSources.splice(lightPosition, 1);\r\n                        mesh.lightSources.splice(0, 0, this._activeLight);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, 1);\r\n\r\n        const shadowGenerator = this._getFirstShadowLightForMesh(mesh)?.getShadowGenerator();\r\n\r\n        this._needAlphaBlending = true;\r\n\r\n        if (shadowGenerator && (shadowGenerator as any).getClassName && (shadowGenerator as any).getClassName() === \"CascadedShadowGenerator\") {\r\n            const csg = shadowGenerator as CascadedShadowGenerator;\r\n\r\n            this._needAlphaBlending = !csg.autoCalcDepthBounds;\r\n        }\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, 1);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"shadowOnly\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"alpha\",\r\n                \"shadowColor\",\r\n                \"mBones\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers: string[] = [];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 1,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\r\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, 1);\r\n\r\n            const light = this._getFirstShadowLightForMesh(mesh);\r\n\r\n            if (light) {\r\n                // Make sure the uniforms for this light will be rebound for other materials using this light when rendering the current frame.\r\n                // Indeed, there is an optimization in Light that binds the light uniforms only once per frame for a given light (if using ubo).\r\n                // Doing this way assumes that all uses of this light are the same, meaning all parameters passed to Light._bindLlight\r\n                // are the same, notably useSpecular. However, isReadyForSubMesh (see above) is passing false for this parameter, which may not be\r\n                // the value the other materials may pass.\r\n                light._renderId = -1;\r\n            }\r\n        }\r\n\r\n        // View\r\n        if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || defines[\"SHADOWCSM0\"]) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public clone(name: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Clone<ShadowOnlyMaterial>(() => new ShadowOnlyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"ShadowOnlyMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShadowOnlyMaterial\", ShadowOnlyMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"simplePixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const simplePixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"simpleVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const simpleVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./simple.fragment\";\r\nimport \"./simple.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass SimpleMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class SimpleMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SimpleMaterialDefines();\r\n        }\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"simple\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): SimpleMaterial {\r\n        return SerializationHelper.Clone<SimpleMaterial>(() => new SimpleMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SimpleMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"SimpleMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SimpleMaterial {\r\n        return SerializationHelper.Parse(() => new SimpleMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SimpleMaterial\", SimpleMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"skyPixelShader\";\nconst shader = `precision highp float;varying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneFragmentDeclaration>\nuniform vec3 cameraPosition;uniform vec3 cameraOffset;uniform vec3 up;uniform float luminance;uniform float turbidity;uniform float rayleigh;uniform float mieCoefficient;uniform float mieDirectionalG;uniform vec3 sunPosition;\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nconst float e=2.71828182845904523536028747135266249775724709369995957;const float pi=3.141592653589793238462643383279502884197169;const float n=1.0003;const float N=2.545E25;const float pn=0.035;const vec3 lambda=vec3(680E-9,550E-9,450E-9);const vec3 K=vec3(0.686,0.678,0.666);const float v=4.0;const float rayleighZenithLength=8.4E3;const float mieZenithLength=1.25E3;const float EE=1000.0;const float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;const float cutoffAngle=pi/1.95;const float steepness=1.5;vec3 totalRayleigh(vec3 lambda)\n{return (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));}\nvec3 simplifiedRayleigh()\n{return 0.0005/vec3(94,40,18);}\nfloat rayleighPhase(float cosTheta)\n{ \nreturn (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));}\nvec3 totalMie(vec3 lambda,vec3 K,float T)\n{float c=(0.2*T )*10E-18;return 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;}\nfloat hgPhase(float cosTheta,float g)\n{return (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));}\nfloat sunIntensity(float zenithAngleCos)\n{return EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));}\nfloat A=0.15;float B=0.50;float C=0.10;float D=0.20;float EEE=0.02;float F=0.30;float W=1000.0;vec3 Uncharted2Tonemap(vec3 x)\n{return ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;}\n#if DITHER\n#include<helperFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n/**\n*--------------------------------------------------------------------------------------------------\n* Sky Color\n*--------------------------------------------------------------------------------------------------\n*/\nfloat sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);float rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));vec3 sunDirection=normalize(sunPosition);float sunE=sunIntensity(dot(sunDirection,up));vec3 betaR=simplifiedRayleigh()*rayleighCoefficient;vec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;float zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));float sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));float sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));vec3 Fex=exp(-(betaR*sR+betaM*sM));float cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);float rPhase=rayleighPhase(cosTheta*0.5+0.5);vec3 betaRTheta=betaR*rPhase;float mPhase=hgPhase(cosTheta,mieDirectionalG);vec3 betaMTheta=betaM*mPhase;vec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));Lin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));vec3 direction=normalize(vPositionW-cameraPosition);float theta=acos(direction.y);float phi=atan(direction.z,direction.x);vec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);vec3 L0=vec3(0.1)*Fex;float sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);L0+=(sunE*19000.0*Fex)*sundisk;vec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));vec3 texColor=(Lin+L0);texColor*=0.04 ;texColor+=vec3(0.0,0.001,0.0025)*0.3;float g_fMaxLuminance=1.0;float fLumScaled=0.1/luminance; \nfloat fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled); \nfloat ExposureBias=fLumCompressed;vec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);vec3 retColor=curr*whiteScale;/**\n*--------------------------------------------------------------------------------------------------\n* Sky Color\n*--------------------------------------------------------------------------------------------------\n*/\nfloat alpha=1.0;\n#ifdef VERTEXCOLOR\nretColor.rgb*=vColor.rgb;\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#if DITHER\nretColor.rgb+=dither(gl_FragCoord.xy,0.5);\n#endif\nvec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\n\nconst name = \"skyVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\nuniform mat4 world;uniform mat4 view;uniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<logDepthDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\ngl_Position=viewProjection*world*vec4(position,1.0);vec4 worldPos=world*vec4(position,1.0);vPositionW=vec3(worldPos);\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serialize } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./sky.fragment\";\r\nimport \"./sky.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport { BindFogParameters, BindLogDepth, PrepareDefinesForAttributes, PrepareDefinesForMisc } from \"core/Materials/materialHelper.functions\";\r\n\r\n/** @internal */\r\nclass SkyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public DITHER = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * This is the sky material which allows to create dynamic and texture free effects for skyboxes.\r\n * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n */\r\nexport class SkyMaterial extends PushMaterial {\r\n    /**\r\n     * Defines the overall luminance of sky in interval ]0, 1[.\r\n     */\r\n    @serialize()\r\n    public luminance: number = 1.0;\r\n\r\n    /**\r\n     * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.\r\n     */\r\n    @serialize()\r\n    public turbidity: number = 10.0;\r\n\r\n    /**\r\n     * Defines the sky appearance (light intensity).\r\n     */\r\n    @serialize()\r\n    public rayleigh: number = 2.0;\r\n\r\n    /**\r\n     * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.\r\n     */\r\n    @serialize()\r\n    public mieCoefficient: number = 0.005;\r\n\r\n    /**\r\n     * Defines the amount of haze particles following the Mie scattering theory.\r\n     */\r\n    @serialize()\r\n    public mieDirectionalG: number = 0.8;\r\n\r\n    /**\r\n     * Defines the distance of the sun according to the active scene camera.\r\n     */\r\n    @serialize()\r\n    public distance: number = 500;\r\n\r\n    /**\r\n     * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said\r\n     * \"inclined\".\r\n     */\r\n    @serialize()\r\n    public inclination: number = 0.49;\r\n\r\n    /**\r\n     * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between\r\n     * an object direction and a reference direction.\r\n     */\r\n    @serialize()\r\n    public azimuth: number = 0.25;\r\n\r\n    /**\r\n     * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then\r\n     * the property is overridden by the inclination and the azimuth and can be read at any moment.\r\n     */\r\n    @serializeAsVector3()\r\n    public sunPosition: Vector3 = new Vector3(0, 100, 0);\r\n\r\n    /**\r\n     * Defines if the sun position should be computed (inclination and azimuth) according to the given\r\n     * .sunPosition property.\r\n     */\r\n    @serialize()\r\n    public useSunPosition: boolean = false;\r\n\r\n    /**\r\n     * Defines an offset vector used to get a horizon offset.\r\n     * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis\r\n     */\r\n    @serializeAsVector3()\r\n    public cameraOffset: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     */\r\n    @serializeAsVector3()\r\n    public up: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * Defines if sky should be dithered.\r\n     */\r\n    @serialize()\r\n    public dithering: boolean = false;\r\n\r\n    // Private members\r\n    private _cameraPosition: Vector3 = Vector3.Zero();\r\n    private _skyOrientation: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Instantiates a new sky material.\r\n     * This material allows to create dynamic and texture free\r\n     * effects for skyboxes by taking care of the atmosphere state.\r\n     * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns false as the sky material doesn't need alpha testing.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns null as the sky material has no texture.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SkyMaterialDefines();\r\n        }\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, false);\r\n\r\n        if (defines.IMAGEPROCESSINGPOSTPROCESS !== scene.imageProcessingConfiguration.applyByPostProcess) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        if (defines.DITHER !== this.dithering) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n            defines.DITHER = this.dithering;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            const shaderName = \"sky\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"logarithmicDepthConstant\",\r\n                \"pointSize\",\r\n                \"luminance\",\r\n                \"turbidity\",\r\n                \"rayleigh\",\r\n                \"mieCoefficient\",\r\n                \"mieDirectionalG\",\r\n                \"sunPosition\",\r\n                \"cameraPosition\",\r\n                \"cameraOffset\",\r\n                \"up\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, attribs, uniforms, [], join, fallbacks, this.onCompiled, this.onError), defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Sky\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            const cameraWorldMatrix = camera.getWorldMatrix();\r\n            this._cameraPosition.x = cameraWorldMatrix.m[12];\r\n            this._cameraPosition.y = cameraWorldMatrix.m[13];\r\n            this._cameraPosition.z = cameraWorldMatrix.m[14];\r\n            this._activeEffect.setVector3(\"cameraPosition\", this._cameraPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"cameraOffset\", this.cameraOffset);\r\n\r\n        this._activeEffect.setVector3(\"up\", this.up);\r\n\r\n        if (this.luminance > 0) {\r\n            this._activeEffect.setFloat(\"luminance\", this.luminance);\r\n        }\r\n\r\n        this._activeEffect.setFloat(\"turbidity\", this.turbidity);\r\n        this._activeEffect.setFloat(\"rayleigh\", this.rayleigh);\r\n        this._activeEffect.setFloat(\"mieCoefficient\", this.mieCoefficient);\r\n        this._activeEffect.setFloat(\"mieDirectionalG\", this.mieDirectionalG);\r\n\r\n        if (!this.useSunPosition) {\r\n            const theta = Math.PI * (this.inclination - 0.5);\r\n            const phi = 2 * Math.PI * (this.azimuth - 0.5);\r\n\r\n            this.sunPosition.x = this.distance * Math.cos(phi) * Math.cos(theta);\r\n            this.sunPosition.y = this.distance * Math.sin(-theta);\r\n            this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);\r\n\r\n            Quaternion.FromUnitVectorsToRef(Vector3.UpReadOnly, this.up, this._skyOrientation);\r\n            this.sunPosition.rotateByQuaternionToRef(this._skyOrientation, this.sunPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"sunPosition\", this.sunPosition);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): SkyMaterial {\r\n        return SerializationHelper.Clone<SkyMaterial>(() => new SkyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SkyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"SkyMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SkyMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Creates a sky material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new sky material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SkyMaterial {\r\n        return SerializationHelper.Parse(() => new SkyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SkyMaterial\", SkyMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"terrainPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform sampler2D textureSampler;uniform vec2 vTextureInfos;uniform sampler2D diffuse1Sampler;uniform sampler2D diffuse2Sampler;uniform sampler2D diffuse3Sampler;uniform vec2 diffuse1Infos;uniform vec2 diffuse2Infos;uniform vec2 diffuse3Infos;\n#endif\n#ifdef BUMP\nuniform sampler2D bump1Sampler;uniform sampler2D bump2Sampler;uniform sampler2D bump3Sampler;\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));return mat3(tangent*invmax,binormal*invmax,normal);}\nvec3 perturbNormal(vec3 viewDir,vec3 mixColor)\n{vec3 bump1Color=texture2D(bump1Sampler,vTextureUV*diffuse1Infos).xyz;vec3 bump2Color=texture2D(bump2Sampler,vTextureUV*diffuse2Infos).xyz;vec3 bump3Color=texture2D(bump3Sampler,vTextureUV*diffuse3Infos).xyz;bump1Color.rgb*=mixColor.r;bump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);vec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);map=map*255./127.-128./127.;mat3 TBN=cotangent_frame(vNormalW*vTextureInfos.y,-viewDir,vTextureUV);return normalize(TBN*map);}\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(textureSampler,vTextureUV);\n#if defined(BUMP) && defined(DIFFUSE)\nnormalW=perturbNormal(viewDirectionW,baseColor.rgb);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vTextureInfos.y;vec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);vec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);vec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);diffuse1Color.rgb*=baseColor.r;diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);baseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*baseColor.rgb,0.0,1.0);vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const terrainPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"terrainVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<logDepthDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const terrainVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./terrain.fragment\";\r\nimport \"./terrain.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass TerrainMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public BUMP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TerrainMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"mixTexture\")\r\n    private _mixTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture1\")\r\n    private _bumpTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture2\")\r\n    private _bumpTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture3\")\r\n    private _bumpTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture3: Texture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TerrainMaterialDefines();\r\n        }\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this.mixTexture || !this.mixTexture.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this.diffuseTexture1 || !this.diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture2 || !this.diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture3 || !this.diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n            }\r\n\r\n            if (this.bumpTexture1 && this.bumpTexture2 && this.bumpTexture3 && MaterialFlags.BumpTextureEnabled) {\r\n                if (!this.bumpTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines._needNormals = true;\r\n                defines.BUMP = true;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"terrain\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n            ];\r\n            const samplers = [\r\n                \"textureSampler\",\r\n                \"diffuse1Sampler\",\r\n                \"diffuse2Sampler\",\r\n                \"diffuse3Sampler\",\r\n                \"bump1Sampler\",\r\n                \"bump2Sampler\",\r\n                \"bump3Sampler\",\r\n                \"logarithmicDepthConstant\",\r\n            ];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.mixTexture) {\r\n                this._activeEffect.setTexture(\"textureSampler\", this._mixTexture);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture.coordinatesIndex, this._mixTexture.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.BumpTextureEnabled && scene.getEngine().getCaps().standardDerivatives) {\r\n                    if (this._bumpTexture1) {\r\n                        this._activeEffect.setTexture(\"bump1Sampler\", this._bumpTexture1);\r\n                    }\r\n                    if (this._bumpTexture2) {\r\n                        this._activeEffect.setTexture(\"bump2Sampler\", this._bumpTexture2);\r\n                    }\r\n                    if (this._bumpTexture3) {\r\n                        this._activeEffect.setTexture(\"bump3Sampler\", this._bumpTexture3);\r\n                    }\r\n                }\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._mixTexture) {\r\n            activeTextures.push(this._mixTexture);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._bumpTexture1) {\r\n            activeTextures.push(this._bumpTexture1);\r\n        }\r\n\r\n        if (this._bumpTexture2) {\r\n            activeTextures.push(this._bumpTexture2);\r\n        }\r\n\r\n        if (this._bumpTexture3) {\r\n            activeTextures.push(this._bumpTexture3);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._mixTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TerrainMaterial {\r\n        return SerializationHelper.Clone(() => new TerrainMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TerrainMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TerrainMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TerrainMaterial {\r\n        return SerializationHelper.Parse(() => new TerrainMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TerrainMaterial\", TerrainMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"triplanarPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;uniform sampler2D diffuseSamplerX;\n#ifdef BUMPX\nuniform sampler2D normalSamplerX;\n#endif\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;uniform sampler2D diffuseSamplerY;\n#ifdef BUMPY\nuniform sampler2D normalSamplerY;\n#endif\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;uniform sampler2D diffuseSamplerZ;\n#ifdef BUMPZ\nuniform sampler2D normalSamplerZ;\n#endif\n#endif\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<logDepthDeclaration>\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(0.,0.,0.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=tangentSpace[2];\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec4 baseNormal=vec4(0.0,0.0,0.0,1.0);normalW*=normalW;\n#ifdef DIFFUSEX\nbaseColor+=texture2D(diffuseSamplerX,vTextureUVX)*normalW.x;\n#ifdef BUMPX\nbaseNormal+=texture2D(normalSamplerX,vTextureUVX)*normalW.x;\n#endif\n#endif\n#ifdef DIFFUSEY\nbaseColor+=texture2D(diffuseSamplerY,vTextureUVY)*normalW.y;\n#ifdef BUMPY\nbaseNormal+=texture2D(normalSamplerY,vTextureUVY)*normalW.y;\n#endif\n#endif\n#ifdef DIFFUSEZ\nbaseColor+=texture2D(diffuseSamplerZ,vTextureUVZ)*normalW.z;\n#ifdef BUMPZ\nbaseNormal+=texture2D(normalSamplerZ,vTextureUVZ)*normalW.z;\n#endif\n#endif\n#ifdef NORMAL\nnormalW=normalize((2.0*baseNormal.xyz-1.0)*tangentSpace);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const triplanarPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"triplanarVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\n#endif\nuniform float tileSize;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying mat3 tangentSpace;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<logDepthDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef DIFFUSEX\nvTextureUVX=worldPos.zy/tileSize;\n#endif\n#ifdef DIFFUSEY\nvTextureUVY=worldPos.xz/tileSize;\n#endif\n#ifdef DIFFUSEZ\nvTextureUVZ=worldPos.xy/tileSize;\n#endif\n#ifdef NORMAL\nvec3 xtan=vec3(0,0,1);vec3 xbin=vec3(0,1,0);vec3 ytan=vec3(1,0,0);vec3 ybin=vec3(0,0,1);vec3 ztan=vec3(1,0,0);vec3 zbin=vec3(0,1,0);vec3 normalizedNormal=normalize(normal);normalizedNormal*=normalizedNormal;vec3 worldBinormal=normalize(xbin*normalizedNormal.x+ybin*normalizedNormal.y+zbin*normalizedNormal.z);vec3 worldTangent=normalize(xtan*normalizedNormal.x+ytan*normalizedNormal.y+ztan*normalizedNormal.z);mat3 normalWorld=mat3(finalWorld);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nworldTangent=normalize((normalWorld*worldTangent).xyz);worldBinormal=normalize((normalWorld*worldBinormal).xyz);vec3 worldNormal=normalize((normalWorld*normalize(normal)).xyz);tangentSpace[0]=worldTangent;tangentSpace[1]=worldBinormal;tangentSpace[2]=worldNormal;\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const triplanarVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./triplanar.fragment\";\r\nimport \"./triplanar.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass TriPlanarMaterialDefines extends MaterialDefines {\r\n    public DIFFUSEX = false;\r\n    public DIFFUSEY = false;\r\n    public DIFFUSEZ = false;\r\n\r\n    public BUMPX = false;\r\n    public BUMPY = false;\r\n    public BUMPZ = false;\r\n\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public NONUNIFORMSCALING = false;\r\n    public LOGARITHMICDEPTH = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TriPlanarMaterial extends PushMaterial {\r\n    @serializeAsTexture()\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureX\")\r\n    private _diffuseTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexturY\")\r\n    private _diffuseTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureZ\")\r\n    private _diffuseTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureZ: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureX\")\r\n    private _normalTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureY\")\r\n    private _normalTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureZ\")\r\n    private _normalTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureZ: BaseTexture;\r\n\r\n    @serialize()\r\n    public tileSize: number = 1;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0.2, 0.2, 0.2);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TriPlanarMaterialDefines();\r\n        }\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    const textures = [this.diffuseTextureX, this.diffuseTextureY, this.diffuseTextureZ];\r\n                    const textureDefines = [\"DIFFUSEX\", \"DIFFUSEY\", \"DIFFUSEZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (MaterialFlags.BumpTextureEnabled) {\r\n                    const textures = [this.normalTextureX, this.normalTextureY, this.normalTextureZ];\r\n                    const textureDefines = [\"BUMPX\", \"BUMPY\", \"BUMPZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"triplanar\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"tileSize\",\r\n            ];\r\n            const samplers = [\"diffuseSamplerX\", \"diffuseSamplerY\", \"diffuseSamplerZ\", \"normalSamplerX\", \"normalSamplerY\", \"normalSamplerZ\", \"logarithmicDepthConstant\"];\r\n\r\n            const uniformBuffers: string[] = [];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"tileSize\", this.tileSize);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.diffuseTextureX) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerX\", this.diffuseTextureX);\r\n            }\r\n            if (this.diffuseTextureY) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerY\", this.diffuseTextureY);\r\n            }\r\n            if (this.diffuseTextureZ) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerZ\", this.diffuseTextureZ);\r\n            }\r\n            if (this.normalTextureX) {\r\n                this._activeEffect.setTexture(\"normalSamplerX\", this.normalTextureX);\r\n            }\r\n            if (this.normalTextureY) {\r\n                this._activeEffect.setTexture(\"normalSamplerY\", this.normalTextureY);\r\n            }\r\n            if (this.normalTextureZ) {\r\n                this._activeEffect.setTexture(\"normalSamplerZ\", this.normalTextureZ);\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTextureX) {\r\n            activeTextures.push(this._diffuseTextureX);\r\n        }\r\n\r\n        if (this._diffuseTextureY) {\r\n            activeTextures.push(this._diffuseTextureY);\r\n        }\r\n\r\n        if (this._diffuseTextureZ) {\r\n            activeTextures.push(this._diffuseTextureZ);\r\n        }\r\n\r\n        if (this._normalTextureX) {\r\n            activeTextures.push(this._normalTextureX);\r\n        }\r\n\r\n        if (this._normalTextureY) {\r\n            activeTextures.push(this._normalTextureY);\r\n        }\r\n\r\n        if (this._normalTextureZ) {\r\n            activeTextures.push(this._normalTextureZ);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureZ === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureZ === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TriPlanarMaterial {\r\n        return SerializationHelper.Clone(() => new TriPlanarMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TriPlanarMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TriPlanarMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TriPlanarMaterial {\r\n        return SerializationHelper.Parse(() => new TriPlanarMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarMaterial\", TriPlanarMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/imageProcessingDeclaration\";\nimport \"core/Shaders/ShadersInclude/imageProcessingFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\n\nconst name = \"waterPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef BUMP\nvarying vec2 vNormalUV;\n#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\n#endif\nuniform sampler2D normalSampler;uniform vec2 vNormalInfos;\n#endif\nuniform sampler2D refractionSampler;uniform sampler2D reflectionSampler;const float LOG2=1.442695;uniform vec3 cameraPosition;uniform vec4 waterColor;uniform float colorBlendFactor;uniform vec4 waterColor2;uniform float colorBlendFactor2;uniform float bumpHeight;uniform float time;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\n#else\nbaseColor=texture2D(normalSampler,vNormalUV);\n#endif\nvec3 bumpColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\nbaseColor.rgb*=vNormalInfos.y;\n#else\nvec3 bumpColor=vec3(1.0);\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\n#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));if (normalW.y<0.0) {normalW.y=-normalW.y;}\n#else\nvec3 normalW=normalize(vNormalW);\n#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);vec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\n#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\nvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\nvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\n),0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);float IfresnelTerm=1.0-fresnelTerm;refractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;reflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;baseColor=combinedColor;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#else \n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);vec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\n#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\n#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);vec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\n#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\n#endif\nvec3 upVector=vec3(0.0,1.0,0.0);float fresnelTerm=max(dot(viewDirectionW,upVector),0.0);vec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);baseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularBase=vec3(0.,0.,0.);vec3 specularColor=vSpecularColor.rgb;\n#else\nfloat glossiness=0.;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#endif\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\ngl_FragColor=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"waterVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef BUMP\nvarying vec2 vNormalUV;\n#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\n#endif\nuniform mat4 normalMatrix;uniform vec2 vNormalInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<logDepthDeclaration>\nuniform mat4 reflectionViewProjection;uniform vec2 windDirection;uniform float waveLength;uniform float time;uniform float windForce;uniform float waveHeight;uniform float waveSpeed;uniform float waveCount;varying vec3 vRefractionMapTexCoord;varying vec3 vReflectionMapTexCoord;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef BUMP\nif (vNormalInfos.x==0.)\n{vNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));\n#endif\n}\nelse\n{vNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));\n#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));\n#endif\n}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\nfloat finalWaveCount=1.0/(waveCount*0.5);\n#ifdef USE_WORLD_COORDINATES\nvec3 p=worldPos.xyz;\n#else\nvec3 p=position;\n#endif\nfloat newY=(sin(((p.x/finalWaveCount)+time*waveSpeed))*waveHeight*windDirection.x*5.0)\n+ (cos(((p.z/finalWaveCount)+ time*waveSpeed))*waveHeight*windDirection.y*5.0);p.y+=abs(newY);\n#ifdef USE_WORLD_COORDINATES\ngl_Position=viewProjection*vec4(p,1.0);\n#else\ngl_Position=viewProjection*finalWorld*vec4(p,1.0);\n#endif\n#ifdef REFLECTION\nvRefractionMapTexCoord.x=0.5*(gl_Position.w+gl_Position.x);vRefractionMapTexCoord.y=0.5*(gl_Position.w+gl_Position.y);vRefractionMapTexCoord.z=gl_Position.w;worldPos=reflectionViewProjection*finalWorld*vec4(position,1.0);vReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);vReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);vReflectionMapTexCoord.z=worldPos.w;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterVertexShader = { name, shader };\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector2, serializeAsTexture, serialize, expandToProperty, serializeAsColor3 } from \"core/Misc/decorators\";\r\nimport { SerializationHelper } from \"core/Misc/decorators.serialization\";\r\nimport { Matrix, Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Plane } from \"core/Maths/math.plane\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { SmartArray } from \"core/Misc/smartArray\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IImageProcessingConfigurationDefines } from \"core/Materials/imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"core/Materials/imageProcessingConfiguration\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./water.fragment\";\r\nimport \"./water.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { CreateGround } from \"core/Meshes/Builders/groundBuilder\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"core/Materials/materialHelper.functions\";\r\n\r\nclass WaterMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public BUMP = false;\r\n    public REFLECTION = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public SPECULARTERM = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public USE_REVERSE_DEPTHBUFFER = false;\r\n    public FRESNELSEPARATE = false;\r\n    public BUMPSUPERIMPOSE = false;\r\n    public BUMPAFFECTSREFLECTION = false;\r\n    public USE_WORLD_COORDINATES = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class WaterMaterial extends PushMaterial {\r\n    /*\r\n     * Public members\r\n     */\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    /**\r\n     * Defines the wind force.\r\n     */\r\n    @serialize()\r\n    public windForce: number = 6;\r\n    /**\r\n     * Defines the direction of the wind in the plane (X, Z).\r\n     */\r\n    @serializeAsVector2()\r\n    public windDirection: Vector2 = new Vector2(0, 1);\r\n    /**\r\n     * Defines the height of the waves.\r\n     */\r\n    @serialize()\r\n    public waveHeight: number = 0.4;\r\n    /**\r\n     * Defines the bump height related to the bump map.\r\n     */\r\n    @serialize()\r\n    public bumpHeight: number = 0.4;\r\n    /**\r\n     * Defines wether or not: to add a smaller moving bump to less steady waves.\r\n     */\r\n    @serialize(\"bumpSuperimpose\")\r\n    private _bumpSuperimpose = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpSuperimpose: boolean;\r\n\r\n    /**\r\n     * Defines wether or not color refraction and reflection differently with .waterColor2 and .colorBlendFactor2. Non-linear (physically correct) fresnel.\r\n     */\r\n    @serialize(\"fresnelSeparate\")\r\n    private _fresnelSeparate = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public fresnelSeparate: boolean;\r\n\r\n    /**\r\n     * Defines wether or not bump Wwves modify the reflection.\r\n     */\r\n    @serialize(\"bumpAffectsReflection\")\r\n    private _bumpAffectsReflection = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpAffectsReflection: boolean;\r\n\r\n    /**\r\n     * Defines the water color blended with the refraction (near).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color.\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor: number = 0.2;\r\n    /**\r\n     * Defines the water color blended with the reflection (far).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor2: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color (reflection, far).\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor2: number = 0.2;\r\n    /**\r\n     * Defines the maximum length of a wave.\r\n     */\r\n    @serialize()\r\n    public waveLength: number = 0.1;\r\n\r\n    /**\r\n     * Defines the waves speed.\r\n     */\r\n    @serialize()\r\n    public waveSpeed: number = 1.0;\r\n\r\n    /**\r\n     * Defines the number of times waves are repeated. This is typically used to adjust waves count according to the ground's size where the material is applied on.\r\n     */\r\n    @serialize()\r\n    public waveCount: number = 20;\r\n    /**\r\n     * Sets or gets whether or not automatic clipping should be enabled or not. Setting to true will save performances and\r\n     * will avoid calculating useless pixels in the pixel shader of the water material.\r\n     */\r\n    @serialize()\r\n    public disableClipPlane: boolean = false;\r\n\r\n    /**\r\n     * Defines whether or not to use world coordinates for wave deformations.\r\n     * The default value is false, meaning that the deformation is applied in object (local) space.\r\n     * You will probably need to set it to true if you are using instances or thin instances for your water objects.\r\n     */\r\n    @serialize(\"useWorldCoordinatesForWaveDeformation\")\r\n    private _useWorldCoordinatesForWaveDeformation = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useWorldCoordinatesForWaveDeformation: boolean;\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /*\r\n     * Private members\r\n     */\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    private _refractionRTT: Nullable<RenderTargetTexture>;\r\n    private _reflectionRTT: Nullable<RenderTargetTexture>;\r\n\r\n    private _reflectionTransform: Matrix = Matrix.Zero();\r\n    private _lastTime: number = 0;\r\n    private _lastDeltaTime: number = 0;\r\n\r\n    private _waitingRenderList: Nullable<string[]>;\r\n\r\n    private _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param name\r\n     * @param scene\r\n     * @param renderTargetSize\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene?: Scene,\r\n        public renderTargetSize: Vector2 = new Vector2(512, 512)\r\n    ) {\r\n        super(name, scene);\r\n\r\n        this._createRenderTargets(this.getScene(), renderTargetSize);\r\n\r\n        // Create render targets\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n            this._renderTargets.push(<RenderTargetTexture>this._reflectionRTT);\r\n            this._renderTargets.push(<RenderTargetTexture>this._refractionRTT);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    // Get / Set\r\n    public get refractionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._refractionRTT;\r\n    }\r\n\r\n    public get reflectionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._reflectionRTT;\r\n    }\r\n\r\n    // Methods\r\n    public addToRenderList(node: any): void {\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            this._refractionRTT.renderList.push(node);\r\n        }\r\n\r\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\r\n            this._reflectionRTT.renderList.push(node);\r\n        }\r\n    }\r\n\r\n    public removeFromRenderList(node: any): void {\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            const idx = this._refractionRTT.renderList.indexOf(node);\r\n            if (idx !== -1) {\r\n                this._refractionRTT.renderList.splice(idx, 1);\r\n            }\r\n        }\r\n\r\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\r\n            const idx = this._reflectionRTT.renderList.indexOf(node);\r\n            if (idx !== -1) {\r\n                this._reflectionRTT.renderList.splice(idx, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    public enableRenderTargets(enable: boolean): void {\r\n        const refreshRate = enable ? 1 : 0;\r\n\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.refreshRate = refreshRate;\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.refreshRate = refreshRate;\r\n        }\r\n    }\r\n\r\n    public getRenderList(): Nullable<AbstractMesh[]> {\r\n        return this._refractionRTT ? this._refractionRTT.renderList : [];\r\n    }\r\n\r\n    public get renderTargetsEnabled(): boolean {\r\n        return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (this.isFrozen) {\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new WaterMaterialDefines();\r\n        }\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                    if (!this.bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.BUMP = true;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.REFLECTION = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        if (defines._areMiscDirty) {\r\n            defines.FRESNELSEPARATE = this._fresnelSeparate;\r\n            defines.BUMPSUPERIMPOSE = this._bumpSuperimpose;\r\n            defines.BUMPAFFECTSREFLECTION = this._bumpAffectsReflection;\r\n            defines.USE_WORLD_COORDINATES = this._useWorldCoordinatesForWaveDeformation;\r\n        }\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Image processing\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\r\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\r\n        }\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Configure this\r\n        this._mesh = mesh;\r\n\r\n        if (this._waitingRenderList) {\r\n            for (let i = 0; i < this._waitingRenderList.length; i++) {\r\n                this.addToRenderList(scene.getNodeById(this._waitingRenderList[i]));\r\n            }\r\n\r\n            this._waitingRenderList = null;\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"water\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vNormalInfos\",\r\n                \"mBones\",\r\n                \"normalMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n\r\n                // Water\r\n                \"reflectionViewProjection\",\r\n                \"windDirection\",\r\n                \"waveLength\",\r\n                \"time\",\r\n                \"windForce\",\r\n                \"cameraPosition\",\r\n                \"bumpHeight\",\r\n                \"waveHeight\",\r\n                \"waterColor\",\r\n                \"waterColor2\",\r\n                \"colorBlendFactor\",\r\n                \"colorBlendFactor2\",\r\n                \"waveSpeed\",\r\n                \"waveCount\",\r\n            ];\r\n            const samplers = [\r\n                \"normalSampler\",\r\n                // Water\r\n                \"refractionSampler\",\r\n                \"reflectionSampler\",\r\n            ];\r\n            const uniformBuffers: string[] = [];\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect || !this._mesh) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect, subMesh)) {\r\n            // Textures\r\n            if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                this._activeEffect.setTexture(\"normalSampler\", this.bumpTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vNormalInfos\", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);\r\n                this._activeEffect.setMatrix(\"normalMatrix\", this.bumpTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Log. depth\r\n        BindLogDepth(defines, this._activeEffect, scene);\r\n\r\n        // Water\r\n        if (MaterialFlags.ReflectionTextureEnabled) {\r\n            this._activeEffect.setTexture(\"refractionSampler\", this._refractionRTT);\r\n            this._activeEffect.setTexture(\"reflectionSampler\", this._reflectionRTT);\r\n        }\r\n\r\n        const wrvp = this._reflectionTransform.multiply(scene.getProjectionMatrix());\r\n\r\n        // Add delta time. Prevent adding delta time if it hasn't changed.\r\n        const deltaTime = scene.getEngine().getDeltaTime();\r\n        if (deltaTime !== this._lastDeltaTime) {\r\n            this._lastDeltaTime = deltaTime;\r\n            this._lastTime += this._lastDeltaTime;\r\n        }\r\n\r\n        this._activeEffect.setMatrix(\"reflectionViewProjection\", wrvp);\r\n        this._activeEffect.setVector2(\"windDirection\", this.windDirection);\r\n        this._activeEffect.setFloat(\"waveLength\", this.waveLength);\r\n        this._activeEffect.setFloat(\"time\", this._lastTime / 100000);\r\n        this._activeEffect.setFloat(\"windForce\", this.windForce);\r\n        this._activeEffect.setFloat(\"waveHeight\", this.waveHeight);\r\n        this._activeEffect.setFloat(\"bumpHeight\", this.bumpHeight);\r\n        this._activeEffect.setColor4(\"waterColor\", this.waterColor, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor\", this.colorBlendFactor);\r\n        this._activeEffect.setColor4(\"waterColor2\", this.waterColor2, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor2\", this.colorBlendFactor2);\r\n        this._activeEffect.setFloat(\"waveSpeed\", this.waveSpeed);\r\n        this._activeEffect.setFloat(\"waveCount\", this.waveCount);\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    private _createRenderTargets(scene: Scene, renderTargetSize: Vector2): void {\r\n        // Render targets\r\n        this._refractionRTT = new RenderTargetTexture(name + \"_refraction\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.ignoreCameraViewport = true;\r\n\r\n        this._reflectionRTT = new RenderTargetTexture(name + \"_reflection\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.ignoreCameraViewport = true;\r\n\r\n        let isVisible: boolean;\r\n        let clipPlane: Nullable<Plane> = null;\r\n        let savedViewMatrix: Matrix;\r\n        const mirrorMatrix = Matrix.Zero();\r\n\r\n        this._refractionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));\r\n            }\r\n        };\r\n\r\n        this._refractionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                scene.clipPlane = clipPlane;\r\n            }\r\n        };\r\n\r\n        this._reflectionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));\r\n\r\n                Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);\r\n            }\r\n\r\n            // Transform\r\n            savedViewMatrix = scene.getViewMatrix();\r\n\r\n            mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);\r\n            scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene.activeCamera).position, mirrorMatrix);\r\n        };\r\n\r\n        this._reflectionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            scene.clipPlane = clipPlane;\r\n\r\n            // Transform\r\n            scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = null;\r\n        };\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {\r\n            results.push(this.bumpTexture);\r\n        }\r\n        if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {\r\n            results.push(this._reflectionRTT);\r\n        }\r\n        if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {\r\n            results.push(this._refractionRTT);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.bumpTexture) {\r\n            this.bumpTexture.dispose();\r\n        }\r\n\r\n        let index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._refractionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n        index = -1;\r\n        index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._reflectionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.dispose();\r\n        }\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.dispose();\r\n        }\r\n\r\n        // Remove image-processing observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): WaterMaterial {\r\n        return SerializationHelper.Clone(() => new WaterMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.WaterMaterial\";\r\n\r\n        serializationObject.renderList = [];\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            for (let i = 0; i < this._refractionRTT.renderList.length; i++) {\r\n                serializationObject.renderList.push(this._refractionRTT.renderList[i].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"WaterMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): WaterMaterial {\r\n        const mat = SerializationHelper.Parse(() => new WaterMaterial(source.name, scene), source, scene, rootUrl);\r\n        mat._waitingRenderList = source.renderList;\r\n\r\n        return mat;\r\n    }\r\n\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreateGround(name, { width: 512, height: 512, subdivisions: 32, updatable: false }, scene);\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WaterMaterial\", WaterMaterial);\r\n"],
  "mappings": "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",
  "names": ["name", "name", "shader", "name", "name", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name", "name", "shader", "name", "shader", "name"]
}
