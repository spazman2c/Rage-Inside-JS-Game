import {
  HemisphericLight,
  Light,
  SceneLoader
} from "./chunk-X5BA27JI.js";
import {
  CreateGroundVertexData
} from "./chunk-MX7WAJUU.js";
import {
  AbstractMesh,
  ArrayTools,
  Axis,
  BindLogDepth,
  Camera,
  Color3,
  Color4,
  CompatibilityOptions,
  DrawWrapper,
  Effect,
  EffectFallbacks,
  Engine,
  EngineStore,
  Epsilon,
  GetClass,
  IntersectionInfo,
  Logger,
  Material,
  MaterialDefines,
  Matrix,
  Mesh,
  Observable,
  PickingInfo,
  PointerEventTypes,
  PointerInfo,
  PostProcess,
  PrecisionDate,
  PrepareDefinesForCamera,
  PrepareDefinesForPrePass,
  PushMaterial,
  Quaternion,
  RegisterClass,
  RenderTargetTexture,
  Scalar,
  Scene,
  SceneComponentConstants,
  SerializationHelper,
  ShaderStore,
  Space,
  Texture,
  TimingTools,
  TmpColors,
  TmpVectors,
  Tools,
  TransformNode,
  UniqueIdGenerator,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  WebRequest,
  __decorate,
  serialize
} from "./chunk-5XB6PROF.js";

// node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js
var FadeInOutBehavior = class {
  /**
   * Time in milliseconds to delay before fading in (Default: 0)
   * Will set both fade in and out delay to the same value
   */
  get delay() {
    return this.fadeInDelay;
  }
  set delay(value) {
    this.fadeInDelay = value;
    this.fadeOutDelay = value;
  }
  /**
   * Instantiates the FadeInOutBehavior
   */
  constructor() {
    this.fadeInDelay = 0;
    this.fadeOutDelay = 0;
    this.fadeInTime = 300;
    this.fadeOutTime = 300;
    this._millisecondsPerFrame = 1e3 / 60;
    this._hovered = false;
    this._hoverValue = 0;
    this._ownerNode = null;
    this._delay = 0;
    this._time = 300;
    this._update = () => {
      if (this._ownerNode) {
        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;
        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);
        if (this._ownerNode.visibility > 1) {
          this._setAllVisibility(this._ownerNode, 1);
          if (this._hoverValue > this._time) {
            this._hoverValue = this._time;
            this._detachObserver();
            return;
          }
        } else if (this._ownerNode.visibility < 0) {
          this._setAllVisibility(this._ownerNode, 0);
          if (this._hoverValue < 0) {
            this._hoverValue = 0;
            this._detachObserver();
            return;
          }
        }
        this._attachObserver();
      }
    };
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "FadeInOut";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the fade behavior on the passed in mesh
   * @param ownerNode The mesh that will be faded in/out once attached
   */
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._setAllVisibility(this._ownerNode, 0);
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this._ownerNode = null;
  }
  /**
   * Triggers the mesh to begin fading in (or out)
   * @param fadeIn if the object should fade in or out (true to fade in)
   */
  fadeIn(fadeIn = true) {
    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;
    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;
    this._detachObserver();
    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {
      return;
    }
    this._hovered = fadeIn;
    if (!this._hovered) {
      this._delay *= -1;
    }
    if (this._ownerNode.visibility >= 1) {
      this._hoverValue = this._time;
    } else if (this._ownerNode.visibility <= 0) {
      this._hoverValue = 0;
    }
    this._update();
  }
  /**
   * Triggers the mesh to begin fading out
   */
  fadeOut() {
    this.fadeIn(false);
  }
  _setAllVisibility(mesh, value) {
    mesh.visibility = value;
    mesh.getChildMeshes().forEach((c) => {
      this._setAllVisibility(c, value);
    });
  }
  _attachObserver() {
    var _a;
    if (!this._onBeforeRenderObserver) {
      this._onBeforeRenderObserver = (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);
    }
  }
  _detachObserver() {
    var _a;
    if (this._onBeforeRenderObserver) {
      (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      this._onBeforeRenderObserver = null;
    }
  }
};

// node_modules/@babylonjs/core/Culling/ray.js
var Ray = class _Ray {
  /**
   * Creates a new ray
   * @param origin origin point
   * @param direction direction
   * @param length length of the ray
   * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)
   */
  constructor(origin, direction, length = Number.MAX_VALUE, epsilon = Epsilon) {
    this.origin = origin;
    this.direction = direction;
    this.length = length;
    this.epsilon = epsilon;
  }
  // Methods
  /**
   * Clone the current ray
   * @returns a new ray
   */
  clone() {
    return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray length by design to improve perfs.
   * @param minimum bound of the box
   * @param maximum bound of the box
   * @param intersectionTreshold extra extend to be added to the box in all direction
   * @returns if the box was hit
   */
  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
    const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    let d = 0;
    let maxValue = Number.MAX_VALUE;
    let inv;
    let min;
    let max;
    let temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray lenght by design to improve perfs.
   * @param box the bounding box to check
   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
   * @returns if the box was hit
   */
  intersectsBox(box, intersectionTreshold = 0) {
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  }
  /**
   * If the ray hits a sphere
   * @param sphere the bounding sphere to check
   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
   * @returns true if it hits the sphere
   */
  intersectsSphere(sphere, intersectionTreshold = 0) {
    const x = sphere.center.x - this.origin.x;
    const y = sphere.center.y - this.origin.y;
    const z = sphere.center.z - this.origin.z;
    const pyth = x * x + y * y + z * z;
    const radius = sphere.radius + intersectionTreshold;
    const rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    const temp = pyth - dot * dot;
    return temp <= rr;
  }
  /**
   * If the ray hits a triange
   * @param vertex0 triangle vertex
   * @param vertex1 triangle vertex
   * @param vertex2 triangle vertex
   * @returns intersection information if hit
   */
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const edge1 = _Ray._TmpVector3[0];
    const edge2 = _Ray._TmpVector3[1];
    const pvec = _Ray._TmpVector3[2];
    const tvec = _Ray._TmpVector3[3];
    const qvec = _Ray._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    const det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    const invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    const bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < -this.epsilon || bv > 1 + this.epsilon) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    const bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
      return null;
    }
    const distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  }
  /**
   * Checks if ray intersects a plane
   * @param plane the plane to check
   * @returns the distance away it was hit
   */
  intersectsPlane(plane) {
    let distance;
    const result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      const result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  }
  /**
   * Calculate the intercept of a ray on a given axis
   * @param axis to check 'x' | 'y' | 'z'
   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
   */
  intersectsAxis(axis, offset = 0) {
    switch (axis) {
      case "y": {
        const t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      }
      case "x": {
        const t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      }
      case "z": {
        const t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      }
      default:
        return null;
    }
  }
  /**
   * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param mesh the mesh to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns picking info of the intersection
   */
  intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      _Ray.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = _Ray.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
  }
  /**
   * Checks if ray intersects a mesh
   * @param meshes the meshes to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param results array to store result in
   * @returns Array of picking infos
   */
  intersectsMeshes(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (let i = 0; i < meshes.length; i++) {
      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  }
  _comparePickingInfo(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  }
  /**
   * Intersection test between the ray and a given segment within a given tolerance (threshold)
   * @param sega the first point of the segment to test the intersection against
   * @param segb the second point of the segment to test the intersection against
   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
   */
  intersectionSegment(sega, segb, threshold) {
    const o = this.origin;
    const u = TmpVectors.Vector3[0];
    const rsegb = TmpVectors.Vector3[1];
    const v = TmpVectors.Vector3[2];
    const w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(_Ray._Rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    const a = Vector3.Dot(u, u);
    const b = Vector3.Dot(u, v);
    const c = Vector3.Dot(v, v);
    const d = Vector3.Dot(u, w);
    const e = Vector3.Dot(v, w);
    const D = a * c - b * b;
    let sN, sD = D;
    let tN, tD = D;
    if (D < _Ray._Smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
    const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
    const qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    const qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    const dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  }
  /**
   * Update the ray from viewport position
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns this ray updated
   */
  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
    if (enableDistantPicking) {
      if (!_Ray._RayDistant) {
        _Ray._RayDistant = _Ray.Zero();
      }
      _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      const tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      _Ray.TransformToRef(_Ray._RayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  }
  // Statics
  /**
   * Creates a ray with origin and direction of 0,0,0
   * @returns the new ray
   */
  static Zero() {
    return new _Ray(Vector3.Zero(), Vector3.Zero());
  }
  /**
   * Creates a new ray from screen space and viewport
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @returns new ray
   */
  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
    const result = _Ray.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  }
  /**
   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the new ray
   */
  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    return _Ray.CreateFromToToRef(origin, end, result, world);
  }
  /**
   * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param result the object to store the result
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the ref ray
   */
  static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
    result.origin.copyFrom(origin);
    const direction = end.subtractToRef(origin, result.direction);
    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    result.length = length;
    result.direction.normalize();
    return _Ray.TransformToRef(result, world, result);
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @returns the resulting new ray
   */
  static Transform(ray, matrix) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    _Ray.TransformToRef(ray, matrix, result);
    return result;
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @param result ray to store result in
   * @returns the updated result ray
   */
  static TransformToRef(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    result.epsilon = ray.epsilon;
    const dir = result.direction;
    const len = dir.length();
    if (!(len === 0 || len === 1)) {
      const num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
    return result;
  }
  /**
   * Unproject a ray from screen space to object space
   * @param sourceX defines the screen space x coordinate to use
   * @param sourceY defines the screen space y coordinate to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   */
  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    const matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const engine = EngineStore.LastCreatedEngine;
    const nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = (engine == null ? void 0 : engine.useReverseDepthBuffer) ? 1 : (engine == null ? void 0 : engine.isNDCHalfZRange) ? 0 : -1;
    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    const nearVec3 = TmpVectors.Vector3[2];
    const farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  }
};
Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
Ray._RayDistant = Ray.Zero();
Ray._Smallnum = 1e-8;
Ray._Rayl = 1e9;
Scene.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
  return result;
};
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = this.getEngine();
  if (!camera && !(camera = this.activeCamera)) {
    return this;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return this;
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  const result = Ray.Zero();
  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
  return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  if (!PickingInfo) {
    return this;
  }
  const engine = this.getEngine();
  if (!camera && !(camera = this.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return this;
};
Scene.prototype._internalPickForMesh = function(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
};
Scene.prototype._internalPick = function(rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);
  const currentCamera = this.cameraToUseForPointers || this.activeCamera;
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function(rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);
  const currentCamera = this.cameraToUseForPointers || this.activeCamera;
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = this._internalPick((world) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);
    return this._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Object.defineProperty(Scene.prototype, "_pickingAvailable", {
  get: () => true,
  enumerable: false,
  configurable: false
});
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = this._internalPick((world, enableDistantPicking) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);
    return this._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  const result = this._internalPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  return this._internalMultiPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function(length = 100, transform, origin) {
  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
};
Camera.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = this.getWorldMatrix();
  }
  refRay.length = length;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(this.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
};

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools = class _PivotTools {
  /**
   * @internal
   */
  static _RemoveAndStorePivotPoint(mesh) {
    if (mesh && _PivotTools._PivotCached === 0) {
      mesh.getPivotPointToRef(_PivotTools._OldPivotPoint);
      _PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
      if (!_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
        mesh.setPivotMatrix(Matrix.IdentityReadOnly);
        _PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), _PivotTools._PivotTranslation);
        _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
        _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
        _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
        mesh.position.addInPlace(_PivotTools._PivotTmpVector);
      }
    }
    _PivotTools._PivotCached++;
  }
  /**
   * @internal
   */
  static _RestorePivotPoint(mesh) {
    if (mesh && !_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && _PivotTools._PivotCached === 1) {
      mesh.setPivotPoint(_PivotTools._OldPivotPoint);
      mesh._postMultiplyPivotMatrix = _PivotTools._PivotPostMultiplyPivotMatrix;
      _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
      _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
      _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
      mesh.position.subtractInPlace(_PivotTools._PivotTmpVector);
    }
    this._PivotCached--;
  }
};
PivotTools._PivotCached = 0;
PivotTools._OldPivotPoint = new Vector3();
PivotTools._PivotTranslation = new Vector3();
PivotTools._PivotTmpVector = new Vector3();
PivotTools._PivotPostMultiplyPivotMatrix = false;

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name4, options = {}, scene = null) {
  const plane = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
var PlaneBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreatePlane
};
VertexData.CreatePlane = CreatePlaneVertexData;
Mesh.CreatePlane = (name4, size, scene, updatable, sideOrientation) => {
  const options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return CreatePlane(name4, options, scene);
};

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior = class _PointerDragBehavior {
  /**
   * Get or set the currentDraggingPointerId
   * @deprecated Please use currentDraggingPointerId instead
   */
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  /**
   *  If the drag behavior will react to drag events (Default: true)
   */
  set enabled(value) {
    if (value != this._enabled) {
      this.onEnabledObservable.notifyObservers(value);
    }
    this._enabled = value;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Gets the options used by the behavior
   */
  get options() {
    return this._options;
  }
  /**
   * Sets the options used by the behavior
   */
  set options(options) {
    this._options = options;
  }
  /**
   * Creates a pointer drag behavior that can be attached to a mesh
   * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
   * @param options.dragAxis
   * @param options.dragPlaneNormal
   */
  constructor(options) {
    this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
    this._activeDragButton = -1;
    this.maxDragAngle = 0;
    this.dragButtons = [0, 1, 2];
    this._useAlternatePickedPointAboveMaxDragAngle = false;
    this.currentDraggingPointerId = -1;
    this.dragging = false;
    this.dragDeltaRatio = 0.2;
    this.updateDragPlane = true;
    this._debugMode = false;
    this._moving = false;
    this.onDragObservable = new Observable();
    this.onDragStartObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.onEnabledObservable = new Observable();
    this.moveAttached = true;
    this._enabled = true;
    this.startAndReleaseDragOnPointerEvents = true;
    this.detachCameraControls = true;
    this.useObjectOrientationForDragging = true;
    this.validateDrag = (target) => {
      return true;
    };
    this._tmpVector = new Vector3(0, 0, 0);
    this._alternatePickedPoint = new Vector3(0, 0, 0);
    this._worldDragAxis = new Vector3(0, 0, 0);
    this._targetPosition = new Vector3(0, 0, 0);
    this._attachedToElement = false;
    this._startDragRay = new Ray(new Vector3(), new Vector3());
    this._lastPointerRay = {};
    this._dragDelta = new Vector3();
    this._pointA = new Vector3(0, 0, 0);
    this._pointC = new Vector3(0, 0, 0);
    this._localAxis = new Vector3(0, 0, 0);
    this._lookAt = new Vector3(0, 0, 0);
    this._options = options ? options : {};
    let optionCount = 0;
    if (this._options.dragAxis) {
      optionCount++;
    }
    if (this._options.dragPlaneNormal) {
      optionCount++;
    }
    if (optionCount > 1) {
      throw "Multiple drag modes specified in dragBehavior options. Only one expected";
    }
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "PointerDrag";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the drag behavior the passed in mesh
   * @param ownerNode The mesh that will be dragged around once attached
   * @param predicate Predicate to use for pick filtering
   */
  attach(ownerNode, predicate) {
    this._scene = ownerNode.getScene();
    ownerNode.isNearGrabbable = true;
    this.attachedNode = ownerNode;
    if (!_PointerDragBehavior._PlaneScene) {
      if (this._debugMode) {
        _PointerDragBehavior._PlaneScene = this._scene;
      } else {
        _PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });
        _PointerDragBehavior._PlaneScene.detachControl();
        this._scene.onDisposeObservable.addOnce(() => {
          _PointerDragBehavior._PlaneScene.dispose();
          _PointerDragBehavior._PlaneScene = null;
        });
      }
    }
    this._dragPlane = CreatePlane("pointerDragPlane", { size: this._debugMode ? 1 : 1e4, updatable: false, sideOrientation: Mesh.DOUBLESIDE }, _PointerDragBehavior._PlaneScene);
    this.lastDragPosition = new Vector3(0, 0, 0);
    const pickPredicate = predicate ? predicate : (m) => {
      return this.attachedNode == m || m.isDescendantOf(this.attachedNode);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (!this.enabled) {
        if (this._attachedToElement) {
          this.releaseDrag();
        }
        return;
      }
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {
            this._activeDragButton = pointerInfo.event.button;
            this._activePointerInfo = pointerInfo;
            this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
          }
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
        if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerId == pointerInfo.event.pointerId && (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)) {
          this.releaseDrag();
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const pointerId = pointerInfo.event.pointerId;
        if (this.currentDraggingPointerId === _PointerDragBehavior._AnyMouseId && pointerId !== _PointerDragBehavior._AnyMouseId) {
          const evt = pointerInfo.event;
          const isMouseEvent = evt.pointerType === "mouse" || !this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
          if (isMouseEvent) {
            if (this._lastPointerRay[this.currentDraggingPointerId]) {
              this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];
              delete this._lastPointerRay[this.currentDraggingPointerId];
            }
            this.currentDraggingPointerId = pointerId;
          }
        }
        if (!this._lastPointerRay[pointerId]) {
          this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
        }
        if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
          this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
          this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
          if (this.currentDraggingPointerId == pointerId && this.dragging) {
            this._moveDrag(pointerInfo.pickInfo.ray);
          }
        }
      }
    });
    this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      if (this._moving && this.moveAttached) {
        let needMatrixUpdate = false;
        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
        this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);
        this._tmpVector.scaleInPlace(this.dragDeltaRatio);
        this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);
        if (this.validateDrag(this._tmpVector)) {
          this.attachedNode.setAbsolutePosition(this._tmpVector);
          needMatrixUpdate = true;
        }
        PivotTools._RestorePivotPoint(this.attachedNode);
        if (needMatrixUpdate) {
          this.attachedNode.computeWorldMatrix();
        }
      }
    });
  }
  /**
   * Force release the drag action by code.
   */
  releaseDrag() {
    if (this.dragging) {
      this.dragging = false;
      this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
    }
    this.currentDraggingPointerId = -1;
    this._activeDragButton = -1;
    this._activePointerInfo = null;
    this._moving = false;
    if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
      if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._scene.activeCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
      }
      this._attachedToElement = false;
    }
  }
  /**
   * Simulates the start of a pointer drag event on the behavior
   * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
   * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
   * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
   */
  startDrag(pointerId = _PointerDragBehavior._AnyMouseId, fromRay, startPickedPoint) {
    this._startDrag(pointerId, fromRay, startPickedPoint);
    let lastRay = this._lastPointerRay[pointerId];
    if (pointerId === _PointerDragBehavior._AnyMouseId) {
      lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
    }
    if (lastRay) {
      this._moveDrag(lastRay);
    }
  }
  _startDrag(pointerId, fromRay, startPickedPoint) {
    if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
      return;
    }
    PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
    if (fromRay) {
      this._startDragRay.direction.copyFrom(fromRay.direction);
      this._startDragRay.origin.copyFrom(fromRay.origin);
    } else {
      this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
      this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
      this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
    }
    this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
    const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
    if (pickedPoint) {
      this.dragging = true;
      this.currentDraggingPointerId = pointerId;
      this.lastDragPosition.copyFrom(pickedPoint);
      this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
      this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());
      if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
        if (this._scene.activeCamera.inputs.attachedToElement) {
          this._scene.activeCamera.detachControl();
          this._attachedToElement = true;
        } else {
          this._attachedToElement = false;
        }
      }
    } else {
      this.releaseDrag();
    }
    PivotTools._RestorePivotPoint(this.attachedNode);
  }
  _moveDrag(ray) {
    this._moving = true;
    const pickedPoint = this._pickWithRayOnDragPlane(ray);
    if (pickedPoint) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
      if (this.updateDragPlane) {
        this._updateDragPlanePosition(ray, pickedPoint);
      }
      let dragLength = 0;
      if (this._options.dragAxis) {
        this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
        pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
        dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
        this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
      } else {
        dragLength = this._dragDelta.length();
        pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
      }
      this._targetPosition.addInPlace(this._dragDelta);
      this.onDragObservable.notifyObservers({
        dragDistance: dragLength,
        delta: this._dragDelta,
        dragPlanePoint: pickedPoint,
        dragPlaneNormal: this._dragPlane.forward,
        pointerId: this.currentDraggingPointerId,
        pointerInfo: this._activePointerInfo
      });
      this.lastDragPosition.copyFrom(pickedPoint);
      PivotTools._RestorePivotPoint(this.attachedNode);
    }
  }
  _pickWithRayOnDragPlane(ray) {
    if (!ray) {
      return null;
    }
    let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
    if (angle > Math.PI / 2) {
      angle = Math.PI - angle;
    }
    if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
      if (this._useAlternatePickedPointAboveMaxDragAngle) {
        this._tmpVector.copyFrom(ray.direction);
        this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
        this._alternatePickedPoint.normalize();
        this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
        this._tmpVector.addInPlace(this._alternatePickedPoint);
        const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
        this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
        this._alternatePickedPoint.addInPlace(this._tmpVector);
        this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
        return this._alternatePickedPoint;
      } else {
        return null;
      }
    }
    const planeNormal = this._dragPlane.forward;
    const planePosition = this._dragPlane.position;
    const dotProduct = ray.direction.dot(planeNormal);
    if (Math.abs(dotProduct) < Epsilon) {
      return null;
    }
    planePosition.subtractToRef(ray.origin, TmpVectors.Vector3[0]);
    const t = TmpVectors.Vector3[0].dot(planeNormal) / dotProduct;
    if (t < 0) {
      return null;
    }
    ray.direction.scaleToRef(t, TmpVectors.Vector3[0]);
    const intersectionPoint = ray.origin.add(TmpVectors.Vector3[0]);
    return intersectionPoint;
  }
  // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera
  _updateDragPlanePosition(ray, dragPlanePosition) {
    this._pointA.copyFrom(dragPlanePosition);
    if (this._options.dragAxis) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
      ray.origin.subtractToRef(this._pointA, this._pointC);
      this._pointC.normalize();
      if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
        if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
          this._lookAt.copyFrom(Vector3.Right());
        } else {
          this._lookAt.copyFrom(Vector3.UpReadOnly);
        }
      } else {
        Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
        Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
        this._lookAt.normalize();
      }
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._lookAt, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else if (this._options.dragPlaneNormal) {
      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
      this._dragPlane.position.copyFrom(this._pointA);
      this._pointA.addToRef(this._localAxis, this._lookAt);
      this._dragPlane.lookAt(this._lookAt);
    } else {
      this._dragPlane.position.copyFrom(this._pointA);
      this._dragPlane.lookAt(ray.origin);
    }
    this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());
    this._dragPlane.computeWorldMatrix(true);
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this._lastPointerRay = {};
    if (this.attachedNode) {
      this.attachedNode.isNearGrabbable = false;
    }
    if (this._pointerObserver) {
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    if (this._beforeRenderObserver) {
      this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
    if (this._dragPlane) {
      this._dragPlane.dispose();
    }
    this.releaseDrag();
  }
};
PointerDragBehavior._AnyMouseId = -2;

// node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js
var BaseSixDofDragBehavior = class _BaseSixDofDragBehavior {
  constructor() {
    this._attachedToElement = false;
    this._virtualMeshesInfo = {};
    this._tmpVector = new Vector3();
    this._tmpQuaternion = new Quaternion();
    this._dragType = {
      NONE: 0,
      DRAG: 1,
      DRAG_WITH_CONTROLLER: 2,
      NEAR_DRAG: 3
    };
    this._moving = false;
    this._dragging = this._dragType.NONE;
    this.draggableMeshes = null;
    this.zDragFactor = 3;
    this.currentDraggingPointerIds = [];
    this.detachCameraControls = true;
    this.onDragStartObservable = new Observable();
    this.onDragObservable = new Observable();
    this.onDragEndObservable = new Observable();
    this.allowMultiPointer = true;
  }
  /**
   * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
   */
  get currentDraggingPointerId() {
    if (this.currentDraggingPointerIds[0] !== void 0) {
      return this.currentDraggingPointerIds[0];
    }
    return -1;
  }
  set currentDraggingPointerId(value) {
    this.currentDraggingPointerIds[0] = value;
  }
  /**
   * Get or set the currentDraggingPointerId
   * @deprecated Please use currentDraggingPointerId instead
   */
  get currentDraggingPointerID() {
    return this.currentDraggingPointerId;
  }
  set currentDraggingPointerID(currentDraggingPointerID) {
    this.currentDraggingPointerId = currentDraggingPointerID;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "BaseSixDofDrag";
  }
  /**
   *  Returns true if the attached mesh is currently moving with this behavior
   */
  get isMoving() {
    return this._moving;
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera
   */
  get _pointerCamera() {
    if (this._scene.cameraToUseForPointers) {
      return this._scene.cameraToUseForPointers;
    } else {
      return this._scene.activeCamera;
    }
  }
  _createVirtualMeshInfo() {
    const dragMesh = new AbstractMesh("", _BaseSixDofDragBehavior._virtualScene);
    dragMesh.rotationQuaternion = new Quaternion();
    const originMesh = new AbstractMesh("", _BaseSixDofDragBehavior._virtualScene);
    originMesh.rotationQuaternion = new Quaternion();
    const pivotMesh = new AbstractMesh("", _BaseSixDofDragBehavior._virtualScene);
    pivotMesh.rotationQuaternion = new Quaternion();
    return {
      dragging: false,
      moving: false,
      dragMesh,
      originMesh,
      pivotMesh,
      startingPivotPosition: new Vector3(),
      startingPivotOrientation: new Quaternion(),
      startingPosition: new Vector3(),
      startingOrientation: new Quaternion(),
      lastOriginPosition: new Vector3(),
      lastDragPosition: new Vector3()
    };
  }
  _resetVirtualMeshesPosition() {
    for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);
      this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);
    }
  }
  _pointerUpdate2D(ray, pointerId, zDragFactor) {
    if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
      ray.origin.copyFrom(this._pointerCamera.globalPosition);
      zDragFactor = 0;
    }
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    const originDragDifference = TmpVectors.Vector3[0];
    ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);
    virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);
    const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);
    this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);
    this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);
    virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);
    const lookAt = TmpVectors.Vector3[0];
    ray.origin.addToRef(ray.direction, lookAt);
    virtualMeshesInfo.originMesh.lookAt(lookAt);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
  }
  _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {
    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
    virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);
    if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);
    } else {
      virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);
    }
    virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);
    virtualMeshesInfo.dragMesh.computeWorldMatrix(true);
    if (zDragFactor !== 0) {
      const cameraForwardVec = TmpVectors.Vector3[0];
      const originDragDirection = TmpVectors.Vector3[1];
      cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);
      virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);
      virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);
      const controllerDragDistance = originDragDirection.length();
      originDragDirection.normalize();
      const cameraToDrag = TmpVectors.Vector3[2];
      const controllerToDrag = TmpVectors.Vector3[3];
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);
      virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);
      const controllerToDragDistance = controllerToDrag.length();
      cameraToDrag.normalize();
      controllerToDrag.normalize();
      const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);
      let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;
      const minDistanceFromControllerToDragMesh = 0.01;
      if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {
        zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);
      }
      controllerToDrag.scaleInPlace(zOffsetScaling);
      controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);
      controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);
      virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);
    }
  }
  /**
   * Attaches the scale behavior the passed in mesh
   * @param ownerNode The mesh that will be scaled around once attached
   */
  attach(ownerNode) {
    this._ownerNode = ownerNode;
    this._scene = this._ownerNode.getScene();
    if (!_BaseSixDofDragBehavior._virtualScene) {
      _BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });
      _BaseSixDofDragBehavior._virtualScene.detachControl();
    }
    const pickPredicate = (m) => {
      return this._ownerNode === m || m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1);
    };
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      const pointerId = pointerInfo.event.pointerId;
      if (!this._virtualMeshesInfo[pointerId]) {
        this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();
      }
      const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
      const isXRPointer = pointerInfo.event.pointerType === "xr-near" || pointerInfo.event.pointerType === "xr";
      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
        if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isXRPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
          if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {
            return;
          }
          if (this._pointerCamera && this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
            pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);
          }
          this._ownerNode.computeWorldMatrix(true);
          const virtualMeshesInfo2 = this._virtualMeshesInfo[pointerId];
          if (isXRPointer) {
            this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);
            if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);
            } else {
              virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);
            }
          } else {
            this._dragging = this._dragType.DRAG;
            virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
          }
          virtualMeshesInfo2.lastOriginPosition.copyFrom(virtualMeshesInfo2.originMesh.position);
          virtualMeshesInfo2.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);
          virtualMeshesInfo2.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
          virtualMeshesInfo2.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
          virtualMeshesInfo2.startingPosition.copyFrom(virtualMeshesInfo2.dragMesh.position);
          virtualMeshesInfo2.startingPivotPosition.copyFrom(virtualMeshesInfo2.pivotMesh.position);
          virtualMeshesInfo2.startingOrientation.copyFrom(virtualMeshesInfo2.dragMesh.rotationQuaternion);
          virtualMeshesInfo2.startingPivotOrientation.copyFrom(virtualMeshesInfo2.pivotMesh.rotationQuaternion);
          if (isXRPointer) {
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.dragMesh);
            virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.pivotMesh);
          } else {
            virtualMeshesInfo2.originMesh.lookAt(virtualMeshesInfo2.dragMesh.position);
          }
          virtualMeshesInfo2.dragging = true;
          if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {
            this.currentDraggingPointerIds.push(pointerId);
          }
          if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {
            if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {
              this._pointerCamera.detachControl();
              this._attachedToElement = true;
            } else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {
              this._attachedToElement = false;
            }
          }
          this._targetDragStart(virtualMeshesInfo2.pivotMesh.position, virtualMeshesInfo2.pivotMesh.rotationQuaternion, pointerId);
          this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo2.pivotMesh.position });
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        virtualMeshesInfo.dragging = false;
        if (registeredPointerIndex !== -1) {
          this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);
          if (this.currentDraggingPointerIds.length === 0) {
            this._moving = false;
            this._dragging = this._dragType.NONE;
            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
              this._reattachCameraControls();
              this._attachedToElement = false;
            }
          }
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
          virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
          this._targetDragEnd(pointerId);
          this.onDragEndObservable.notifyObservers({});
        }
      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
        const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
        if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {
          let zDragFactor = this.zDragFactor;
          if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {
            zDragFactor = 0;
          }
          this._ownerNode.computeWorldMatrix(true);
          if (!isXRPointer) {
            this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);
          } else {
            this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);
          }
          this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);
          this._tmpQuaternion.x = -this._tmpQuaternion.x;
          this._tmpQuaternion.y = -this._tmpQuaternion.y;
          this._tmpQuaternion.z = -this._tmpQuaternion.z;
          virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);
          virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);
          this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });
          this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);
          virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);
          this._moving = true;
        }
      }
    });
  }
  _applyZOffset(node, localOriginDragDifference, zDragFactor) {
    node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;
    if (node.position.z < 0) {
      node.position.z = 0;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _targetDragStart(worldPosition, worldRotation, pointerId) {
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {
  }
  _targetDragEnd(pointerId) {
  }
  _reattachCameraControls() {
    if (this._pointerCamera) {
      if (this._pointerCamera.getClassName() === "ArcRotateCamera") {
        const arcRotateCamera = this._pointerCamera;
        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
      } else {
        this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);
      }
    }
  }
  /**
   * Detaches the behavior from the mesh
   */
  detach() {
    if (this._scene) {
      if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
        this._reattachCameraControls();
        this._attachedToElement = false;
      }
      this._scene.onPointerObservable.remove(this._pointerObserver);
    }
    for (const pointerId in this._virtualMeshesInfo) {
      this._virtualMeshesInfo[pointerId].originMesh.dispose();
      this._virtualMeshesInfo[pointerId].dragMesh.dispose();
    }
    this.onDragEndObservable.clear();
    this.onDragObservable.clear();
    this.onDragStartObservable.clear();
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior = class extends BaseSixDofDragBehavior {
  constructor() {
    super(...arguments);
    this._sceneRenderObserver = null;
    this._targetPosition = new Vector3(0, 0, 0);
    this._targetOrientation = new Quaternion();
    this._targetScaling = new Vector3(1, 1, 1);
    this._startingPosition = new Vector3(0, 0, 0);
    this._startingOrientation = new Quaternion();
    this._startingScaling = new Vector3(1, 1, 1);
    this.onPositionChangedObservable = new Observable();
    this.dragDeltaRatio = 0.2;
    this.rotateDraggedObject = true;
    this.rotateAroundYOnly = false;
    this.rotateWithMotionController = true;
    this.disableMovement = false;
    this.faceCameraOnDragStart = false;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "SixDofDrag";
  }
  /**
   * Attaches the six DoF drag behavior
   * In XR mode the mesh and its children will have their isNearGrabbable property set to true
   * @param ownerNode The mesh that will be dragged around once attached
   */
  attach(ownerNode) {
    super.attach(ownerNode);
    ownerNode.isNearGrabbable = true;
    ownerNode.getChildMeshes().forEach((m) => {
      m.isNearGrabbable = true;
    });
    this._virtualTransformNode = new TransformNode("virtual_sixDof", BaseSixDofDragBehavior._virtualScene);
    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();
    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {
        const deltaToAdd = TmpVectors.Vector3[0];
        deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);
        const deltaToAddTransformed = TmpVectors.Vector3[1];
        deltaToAddTransformed.copyFrom(deltaToAdd);
        if (ownerNode.parent) {
          const parentRotationMatrixInverse = TmpVectors.Matrix[0];
          ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);
          parentRotationMatrixInverse.invert();
          Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);
        }
        ownerNode.position.addInPlace(deltaToAddTransformed);
        this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });
        if (!ownerNode.parent || ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(1e-3)) {
          const rotationToApply = TmpVectors.Quaternion[0];
          rotationToApply.copyFrom(this._targetOrientation);
          if (ownerNode.parent) {
            const parentRotationInverse = TmpVectors.Quaternion[0];
            parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);
            parentRotationInverse.invertInPlace();
            parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);
          }
          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);
        }
      }
    });
  }
  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const scaleMatrix = TmpVectors.Matrix[3];
    const finalMatrix = TmpVectors.Matrix[4];
    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix);
    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv);
    Matrix.FromQuaternionToRef(rotation, rotationMatrix);
    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    return finalMatrix.getTranslation();
  }
  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {
    const pointerDelta = TmpVectors.Vector3[0];
    pointerDelta.setAll(0);
    if (this._dragging === this._dragType.DRAG) {
      if (this.rotateDraggedObject) {
        if (this.rotateAroundYOnly) {
          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        } else {
          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);
        }
        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);
      }
    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {
      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);
    }
    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);
  }
  _twoPointersPositionUpdated() {
    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;
    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;
    const startingCenter = TmpVectors.Vector3[0];
    startingPosition0.addToRef(startingPosition1, startingCenter);
    startingCenter.scaleInPlace(0.5);
    const startingVector = TmpVectors.Vector3[1];
    startingPosition1.subtractToRef(startingPosition0, startingVector);
    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;
    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;
    const currentCenter = TmpVectors.Vector3[2];
    currentPosition0.addToRef(currentPosition1, currentCenter);
    currentCenter.scaleInPlace(0.5);
    const currentVector = TmpVectors.Vector3[3];
    currentPosition1.subtractToRef(currentPosition0, currentVector);
    const scaling = currentVector.length() / startingVector.length();
    const translation = currentCenter.subtract(startingCenter);
    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);
    const oldParent = this._ownerNode.parent;
    this._ownerNode.setParent(null);
    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);
    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);
    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);
    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);
    this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });
    this._ownerNode.setParent(oldParent);
  }
  _targetDragStart() {
    const pointerCount = this.currentDraggingPointerIds.length;
    if (!this._ownerNode.rotationQuaternion) {
      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);
    }
    const worldPivot = this._ownerNode.getAbsolutePivotPoint();
    if (pointerCount === 1) {
      this._targetPosition.copyFrom(this._ownerNode.absolutePosition);
      this._targetOrientation.copyFrom(this._ownerNode.absoluteRotationQuaternion);
      this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);
      if (this.faceCameraOnDragStart && this._scene.activeCamera) {
        const toCamera = TmpVectors.Vector3[0];
        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);
        toCamera.normalize();
        const quat = TmpVectors.Quaternion[0];
        if (this._scene.useRightHandedSystem) {
          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);
        } else {
          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);
        }
        quat.normalize();
        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);
      }
      this._startingPosition.copyFrom(this._targetPosition);
      this._startingOrientation.copyFrom(this._targetOrientation);
      this._startingScaling.copyFrom(this._targetScaling);
    } else if (pointerCount === 2) {
      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);
      this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);
      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);
      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);
      this._resetVirtualMeshesPosition();
    }
  }
  _targetDrag(worldDeltaPosition, worldDeltaRotation) {
    if (this.currentDraggingPointerIds.length === 1) {
      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);
    } else if (this.currentDraggingPointerIds.length === 2) {
      this._twoPointersPositionUpdated();
    }
  }
  _targetDragEnd() {
    if (this.currentDraggingPointerIds.length === 1) {
      this._resetVirtualMeshesPosition();
      const previousFaceCameraFlag = this.faceCameraOnDragStart;
      this.faceCameraOnDragStart = false;
      this._targetDragStart();
      this.faceCameraOnDragStart = previousFaceCameraFlag;
    }
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    super.detach();
    if (this._ownerNode) {
      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
    }
    if (this._virtualTransformNode) {
      this._virtualTransformNode.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js
var SurfaceMagnetismBehavior = class {
  constructor() {
    this._attachPointLocalOffset = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._hit = false;
    this.hitNormalOffset = 0.05;
    this.meshes = [];
    this.interpolatePose = true;
    this.lerpTime = 250;
    this.keepOrientationVertical = true;
    this.enabled = true;
    this.maxStickingDistance = 0.8;
  }
  /**
   * Name of the behavior
   */
  get name() {
    return "SurfaceMagnetism";
  }
  /**
   * Function called when the behavior needs to be initialized (after attaching it to a target)
   */
  init() {
  }
  /**
   * Attaches the behavior to a transform node
   * @param target defines the target where the behavior is attached to
   * @param scene the scene
   */
  attach(target, scene) {
    this._attachedMesh = target;
    this._scene = scene || target.getScene();
    if (!this._attachedMesh.rotationQuaternion) {
      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);
    }
    this.updateAttachPoint();
    this._workingPosition.copyFrom(this._attachedMesh.position);
    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);
    this._addObservables();
  }
  /**
   * Detaches the behavior
   */
  detach() {
    this._attachedMesh = null;
    this._removeObservables();
  }
  _getTargetPose(pickingInfo) {
    if (!this._attachedMesh) {
      return null;
    }
    if (pickingInfo && pickingInfo.hit) {
      const pickedNormal = pickingInfo.getNormal(true, true);
      const pickedPoint = pickingInfo.pickedPoint;
      if (!pickedNormal || !pickedPoint) {
        return null;
      }
      pickedNormal.normalize();
      const worldTarget = TmpVectors.Vector3[0];
      worldTarget.copyFrom(pickedNormal);
      worldTarget.scaleInPlace(this.hitNormalOffset);
      worldTarget.addInPlace(pickedPoint);
      if (this._attachedMesh.parent) {
        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();
        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);
      }
      return {
        position: worldTarget,
        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)
      };
    }
    return null;
  }
  /**
   * Updates the attach point with the current geometry extents of the attached mesh
   */
  updateAttachPoint() {
    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);
  }
  /**
   * Finds the intersection point of the given ray onto the meshes and updates the target.
   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.
   * If no mesh of `meshes` are hit, this does nothing.
   * @param pickInfo The input pickingInfo that will be used to intersect the meshes
   * @returns a boolean indicating if we found a hit to stick to
   */
  findAndUpdateTarget(pickInfo) {
    this._hit = false;
    if (!pickInfo.ray) {
      return false;
    }
    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];
    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {
      const pose = this._getTargetPose(subPicking);
      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {
        this._workingPosition.copyFrom(pose.position);
        this._workingQuaternion.copyFrom(pose.quaternion);
        this._hit = true;
      }
    }
    return this._hit;
  }
  _getAttachPointOffsetToRef(ref) {
    if (!this._attachedMesh) {
      ref.setAll(0);
      return;
    }
    const storedQuat = TmpVectors.Quaternion[0];
    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);
    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
    this._attachedMesh.computeWorldMatrix();
    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();
    const center = TmpVectors.Vector3[0];
    boundingMinMax.max.addToRef(boundingMinMax.min, center);
    center.scaleInPlace(0.5);
    center.z = boundingMinMax.max.z;
    const invWorld = TmpVectors.Matrix[0];
    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);
    Vector3.TransformCoordinatesToRef(center, invWorld, ref);
    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);
  }
  _updateTransformToGoal(elapsed) {
    if (!this._attachedMesh || !this._hit) {
      return;
    }
    const oldParent = this._attachedMesh.parent;
    this._attachedMesh.setParent(null);
    const worldOffset = TmpVectors.Vector3[0];
    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);
    if (!this.interpolatePose) {
      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);
      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const interpolatedPosition = new Vector3();
    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);
    this._attachedMesh.position.copyFrom(interpolatedPosition);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);
    this._attachedMesh.setParent(oldParent);
  }
  _addObservables() {
    this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {
        this.findAndUpdateTarget(pointerInfo.pickInfo);
      }
    });
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      const tick = Date.now();
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    this._scene.onPointerObservable.remove(this._pointerObserver);
    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    this._pointerObserver = null;
    this._onBeforeRender = null;
  }
};

// node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js
var FollowBehavior = class {
  constructor() {
    this._tmpQuaternion = new Quaternion();
    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
    this._tmpMatrix = new Matrix();
    this._tmpInvertView = new Matrix();
    this._tmpForward = new Vector3();
    this._tmpNodeForward = new Vector3();
    this._tmpPosition = new Vector3();
    this._workingPosition = new Vector3();
    this._workingQuaternion = new Quaternion();
    this._lastTick = -1;
    this._recenterNextUpdate = true;
    this.interpolatePose = true;
    this.lerpTime = 500;
    this.ignoreCameraPitchAndRoll = false;
    this.pitchOffset = 15;
    this.maxViewVerticalDegrees = 30;
    this.maxViewHorizontalDegrees = 30;
    this.orientToCameraDeadzoneDegrees = 60;
    this.ignoreDistanceClamp = false;
    this.ignoreAngleClamp = false;
    this.verticalMaxDistance = 0;
    this.defaultDistance = 0.8;
    this.maximumDistance = 2;
    this.minimumDistance = 0.3;
    this.useFixedVerticalOffset = false;
    this.fixedVerticalOffset = 0;
    this._enabled = true;
  }
  /**
   * The camera that should be followed by this behavior
   */
  get followedCamera() {
    return this._followedCamera || this._scene.activeCamera;
  }
  set followedCamera(camera) {
    this._followedCamera = camera;
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "Follow";
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the follow behavior
   * @param ownerNode The mesh that will be following once attached
   * @param followedCamera The camera that should be followed by the node
   */
  attach(ownerNode, followedCamera) {
    this._scene = ownerNode.getScene();
    this.attachedNode = ownerNode;
    if (followedCamera) {
      this.followedCamera = followedCamera;
    }
    this._addObservables();
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this.attachedNode = null;
    this._removeObservables();
  }
  /**
   * Recenters the attached node in front of the camera on the next update
   */
  recenter() {
    this._recenterNextUpdate = true;
  }
  _angleBetweenVectorAndPlane(vector, normal) {
    this._tmpVectors[0].copyFrom(vector);
    vector = this._tmpVectors[0];
    this._tmpVectors[1].copyFrom(normal);
    normal = this._tmpVectors[1];
    vector.normalize();
    normal.normalize();
    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));
  }
  _length2D(vector) {
    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);
  }
  _distanceClamp(currentToTarget, moveToDefault = false) {
    let minDistance = this.minimumDistance;
    let maxDistance = this.maximumDistance;
    const defaultDistance = this.defaultDistance;
    const direction = this._tmpVectors[0];
    direction.copyFrom(currentToTarget);
    let currentDistance = direction.length();
    direction.normalizeFromLength(currentDistance);
    if (this.ignoreCameraPitchAndRoll) {
      minDistance = this._length2D(direction) * minDistance;
      maxDistance = this._length2D(direction) * maxDistance;
      const currentDistance2D = this._length2D(currentToTarget);
      direction.scaleInPlace(currentDistance / currentDistance2D);
      currentDistance = currentDistance2D;
    }
    let clampedDistance = currentDistance;
    if (moveToDefault) {
      clampedDistance = defaultDistance;
    } else {
      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);
    }
    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);
    return currentDistance !== clampedDistance;
  }
  _applyVerticalClamp(currentToTarget) {
    if (this.verticalMaxDistance !== 0) {
      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);
    }
  }
  _toOrientationQuatToRef(vector, quaternion) {
    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);
  }
  _applyPitchOffset(invertView) {
    const forward = this._tmpVectors[0];
    const right = this._tmpVectors[1];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    forward.y = 0;
    forward.normalize();
    Vector3.TransformNormalToRef(right, invertView, right);
    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);
    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);
    this._toOrientationQuatToRef(forward, this._tmpQuaternion);
    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);
    invertView.copyFrom(this._tmpMatrix);
  }
  _angularClamp(invertView, currentToTarget) {
    const forward = this._tmpVectors[5];
    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
    const right = this._tmpVectors[6];
    right.copyFromFloats(1, 0, 0);
    Vector3.TransformNormalToRef(forward, invertView, forward);
    Vector3.TransformNormalToRef(right, invertView, right);
    const up = Vector3.UpReadOnly;
    const dist = currentToTarget.length();
    if (dist < Epsilon) {
      return false;
    }
    let angularClamped = false;
    const rotationQuat = this._tmpQuaternion;
    if (this.ignoreCameraPitchAndRoll) {
      const angle2 = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      Quaternion.RotationAxisToRef(right, angle2, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
    } else {
      const angle2 = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
      const minMaxAngle2 = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;
      if (angle2 < -minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 - minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      } else if (angle2 > minMaxAngle2) {
        Quaternion.RotationAxisToRef(right, -angle2 + minMaxAngle2, rotationQuat);
        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        angularClamped = true;
      }
    }
    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);
    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;
    if (angle < -minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    } else if (angle > minMaxAngle) {
      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);
      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
      angularClamped = true;
    }
    return angularClamped;
  }
  _orientationClamp(currentToTarget, rotationQuaternion) {
    var _a;
    const toFollowed = this._tmpVectors[0];
    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();
    const up = this._tmpVectors[1];
    const right = this._tmpVectors[2];
    up.copyFromFloats(0, 1, 0);
    Vector3.CrossToRef(toFollowed, up, right);
    const length = right.length();
    if (length < Epsilon) {
      return;
    }
    right.normalizeFromLength(length);
    Vector3.CrossToRef(right, toFollowed, up);
    if ((_a = this.attachedNode) == null ? void 0 : _a.getScene().useRightHandedSystem) {
      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);
    } else {
      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);
    }
  }
  _passedOrientationDeadzone(currentToTarget, forward) {
    const leashToFollow = this._tmpVectors[5];
    leashToFollow.copyFrom(currentToTarget);
    leashToFollow.normalize();
    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));
    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;
  }
  _updateLeashing(camera) {
    if (this.attachedNode && this._enabled) {
      const oldParent = this.attachedNode.parent;
      this.attachedNode.setParent(null);
      const worldMatrix = this.attachedNode.getWorldMatrix();
      const currentToTarget = this._workingPosition;
      const rotationQuaternion = this._workingQuaternion;
      const pivot = this.attachedNode.getPivotPoint();
      const invertView = this._tmpInvertView;
      invertView.copyFrom(camera.getViewMatrix());
      invertView.invert();
      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);
      const position = this._tmpPosition;
      position.copyFromFloats(0, 0, 0);
      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);
      position.scaleInPlace(-1).subtractInPlace(pivot);
      currentToTarget.subtractInPlace(camera.globalPosition);
      if (this.ignoreCameraPitchAndRoll) {
        this._applyPitchOffset(invertView);
      }
      let angularClamped = false;
      const forward = this._tmpForward;
      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(forward, invertView, forward);
      const nodeForward = this._tmpNodeForward;
      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);
      if (this._recenterNextUpdate) {
        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);
      } else {
        if (this.ignoreAngleClamp) {
          const currentDistance = currentToTarget.length();
          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);
        } else {
          angularClamped = this._angularClamp(invertView, currentToTarget);
        }
      }
      let distanceClamped = false;
      if (!this.ignoreDistanceClamp) {
        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);
        this._applyVerticalClamp(currentToTarget);
      }
      if (this.useFixedVerticalOffset) {
        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;
      }
      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {
        this._orientationClamp(currentToTarget, rotationQuaternion);
      }
      this._workingPosition.subtractInPlace(pivot);
      this._recenterNextUpdate = false;
      this.attachedNode.setParent(oldParent);
    }
  }
  _updateTransformToGoal(elapsed) {
    if (!this.attachedNode || !this.followedCamera || !this._enabled) {
      return;
    }
    if (!this.attachedNode.rotationQuaternion) {
      this.attachedNode.rotationQuaternion = Quaternion.Identity();
    }
    const oldParent = this.attachedNode.parent;
    this.attachedNode.setParent(null);
    if (!this.interpolatePose) {
      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);
      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);
      return;
    }
    const currentDirection = new Vector3();
    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);
    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);
    currentDirection.addInPlace(this.followedCamera.globalPosition);
    this.attachedNode.position.copyFrom(currentDirection);
    const currentRotation = new Quaternion();
    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);
    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);
    this.attachedNode.setParent(oldParent);
  }
  _addObservables() {
    this._lastTick = Date.now();
    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
      if (!this.followedCamera) {
        return;
      }
      const tick = Date.now();
      this._updateLeashing(this.followedCamera);
      this._updateTransformToGoal(tick - this._lastTick);
      this._lastTick = tick;
    });
  }
  _removeObservables() {
    if (this._onBeforeRender) {
      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
    }
  }
};

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName = class {
};
WebXRFeatureName.ANCHOR_SYSTEM = "xr-anchor-system";
WebXRFeatureName.BACKGROUND_REMOVER = "xr-background-remover";
WebXRFeatureName.HIT_TEST = "xr-hit-test";
WebXRFeatureName.MESH_DETECTION = "xr-mesh-detection";
WebXRFeatureName.PHYSICS_CONTROLLERS = "xr-physics-controller";
WebXRFeatureName.PLANE_DETECTION = "xr-plane-detection";
WebXRFeatureName.POINTER_SELECTION = "xr-controller-pointer-selection";
WebXRFeatureName.TELEPORTATION = "xr-controller-teleportation";
WebXRFeatureName.FEATURE_POINTS = "xr-feature-points";
WebXRFeatureName.HAND_TRACKING = "xr-hand-tracking";
WebXRFeatureName.IMAGE_TRACKING = "xr-image-tracking";
WebXRFeatureName.NEAR_INTERACTION = "xr-near-interaction";
WebXRFeatureName.DOM_OVERLAY = "xr-dom-overlay";
WebXRFeatureName.MOVEMENT = "xr-controller-movement";
WebXRFeatureName.LIGHT_ESTIMATION = "xr-light-estimation";
WebXRFeatureName.EYE_TRACKING = "xr-eye-tracking";
WebXRFeatureName.WALKING_LOCOMOTION = "xr-walking-locomotion";
WebXRFeatureName.LAYERS = "xr-layers";
WebXRFeatureName.DEPTH_SENSING = "xr-depth-sensing";
WebXRFeatureName.SPACE_WARP = "xr-space-warp";
WebXRFeatureName.RAW_CAMERA_ACCESS = "xr-raw-camera-access";
var WebXRFeaturesManager = class _WebXRFeaturesManager {
  /**
   * constructs a new features manages.
   *
   * @param _xrSessionManager an instance of WebXRSessionManager
   */
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._features = {};
    this._xrSessionManager.onXRSessionInit.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
          this.attachFeature(featureName);
        }
      });
    });
    this._xrSessionManager.onXRSessionEnded.add(() => {
      this.getEnabledFeatures().forEach((featureName) => {
        const feature = this._features[featureName];
        if (feature.enabled && feature.featureImplementation.attached) {
          this.detachFeature(featureName);
        }
      });
    });
  }
  /**
   * Used to register a module. After calling this function a developer can use this feature in the scene.
   * Mainly used internally.
   *
   * @param featureName the name of the feature to register
   * @param constructorFunction the function used to construct the module
   * @param version the (babylon) version of the module
   * @param stable is that a stable version of this module
   */
  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {
    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
    if (version > this._AvailableFeatures[featureName].latest) {
      this._AvailableFeatures[featureName].latest = version;
    }
    if (stable) {
      this._AvailableFeatures[featureName].stable = version;
    }
    this._AvailableFeatures[featureName][version] = constructorFunction;
  }
  /**
   * Returns a constructor of a specific feature.
   *
   * @param featureName the name of the feature to construct
   * @param version the version of the feature to load
   * @param xrSessionManager the xrSessionManager. Used to construct the module
   * @param options optional options provided to the module.
   * @returns a function that, when called, will return a new instance of this feature
   */
  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {
    const constructorFunction = this._AvailableFeatures[featureName][version];
    if (!constructorFunction) {
      throw new Error("feature not found");
    }
    return constructorFunction(xrSessionManager, options);
  }
  /**
   * Can be used to return the list of features currently registered
   *
   * @returns an Array of available features
   */
  static GetAvailableFeatures() {
    return Object.keys(this._AvailableFeatures);
  }
  /**
   * Gets the versions available for a specific feature
   * @param featureName the name of the feature
   * @returns an array with the available versions
   */
  static GetAvailableVersions(featureName) {
    return Object.keys(this._AvailableFeatures[featureName]);
  }
  /**
   * Return the latest unstable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetLatestVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
  }
  /**
   * Return the latest stable version of this feature
   * @param featureName the name of the feature to search
   * @returns the version number. if not found will return -1
   */
  static GetStableVersionOfFeature(featureName) {
    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
  }
  /**
   * Attach a feature to the current session. Mainly used when session started to start the feature effect.
   * Can be used during a session to start a feature
   * @param featureName the name of feature to attach
   */
  attachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.enabled && !feature.featureImplementation.attached) {
      const attached = feature.featureImplementation.attach();
      if (!attached) {
        Tools.Warn(`Feature ${featureName} failed to attach`);
      }
    }
  }
  /**
   * Can be used inside a session or when the session ends to detach a specific feature
   * @param featureName the name of the feature to detach
   */
  detachFeature(featureName) {
    const feature = this._features[featureName];
    if (feature && feature.featureImplementation.attached) {
      const detached = feature.featureImplementation.detach();
      if (!detached) {
        Tools.Warn(`Feature ${featureName} failed to detach`);
      }
    }
  }
  /**
   * Used to disable an already-enabled feature
   * The feature will be disposed and will be recreated once enabled.
   * @param featureName the feature to disable
   * @returns true if disable was successful
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  disableFeature(featureName) {
    const name4 = typeof featureName === "string" ? featureName : featureName.Name;
    const feature = this._features[name4];
    if (feature && feature.enabled) {
      feature.enabled = false;
      this.detachFeature(name4);
      feature.featureImplementation.dispose();
      delete this._features[name4];
      return true;
    }
    return false;
  }
  /**
   * dispose this features manager
   */
  dispose() {
    this.getEnabledFeatures().forEach((feature) => {
      this.disableFeature(feature);
    });
  }
  /**
   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
   *
   * @param featureName the name of the feature to load or the class of the feature
   * @param version optional version to load. if not provided the latest version will be enabled
   * @param moduleOptions options provided to the module. Ses the module documentation / constructor
   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.
   */
  enableFeature(featureName, version = "latest", moduleOptions = {}, attachIfPossible = true, required = true) {
    const name4 = typeof featureName === "string" ? featureName : featureName.Name;
    let versionToLoad = 0;
    if (typeof version === "string") {
      if (!version) {
        throw new Error(`Error in provided version - ${name4} (${version})`);
      }
      if (version === "stable") {
        versionToLoad = _WebXRFeaturesManager.GetStableVersionOfFeature(name4);
      } else if (version === "latest") {
        versionToLoad = _WebXRFeaturesManager.GetLatestVersionOfFeature(name4);
      } else {
        versionToLoad = +version;
      }
      if (versionToLoad === -1 || isNaN(versionToLoad)) {
        throw new Error(`feature not found - ${name4} (${version})`);
      }
    } else {
      versionToLoad = version;
    }
    const conflictingFeature = _WebXRFeaturesManager._ConflictingFeatures[name4];
    if (conflictingFeature !== void 0 && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {
      throw new Error(`Feature ${name4} cannot be enabled while ${conflictingFeature} is enabled.`);
    }
    const feature = this._features[name4];
    const constructFunction = _WebXRFeaturesManager.ConstructFeature(name4, versionToLoad, this._xrSessionManager, moduleOptions);
    if (!constructFunction) {
      throw new Error(`feature not found - ${name4}`);
    }
    if (feature) {
      this.disableFeature(name4);
    }
    const constructed = constructFunction();
    if (constructed.dependsOn) {
      const dependentsFound = constructed.dependsOn.every((featureName2) => !!this._features[featureName2]);
      if (!dependentsFound) {
        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(", ")}`);
      }
    }
    if (constructed.isCompatible()) {
      this._features[name4] = {
        featureImplementation: constructed,
        enabled: true,
        version: versionToLoad,
        required
      };
      if (attachIfPossible) {
        if (this._xrSessionManager.session && !this._features[name4].featureImplementation.attached) {
          this.attachFeature(name4);
        }
      } else {
        this._features[name4].featureImplementation.disableAutoAttach = true;
      }
      return this._features[name4].featureImplementation;
    } else {
      if (required) {
        throw new Error("required feature not compatible");
      } else {
        Tools.Warn(`Feature ${name4} not compatible with the current environment/browser and was not enabled.`);
        return constructed;
      }
    }
  }
  /**
   * get the implementation of an enabled feature.
   * @param featureName the name of the feature to load
   * @returns the feature class, if found
   */
  getEnabledFeature(featureName) {
    return this._features[featureName] && this._features[featureName].featureImplementation;
  }
  /**
   * Get the list of enabled features
   * @returns an array of enabled features
   */
  getEnabledFeatures() {
    return Object.keys(this._features);
  }
  /**
   * This function will extend the session creation configuration object with enabled features.
   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
   * according to the defined "required" variable, provided during enableFeature call
   * @param xrSessionInit the xr Session init object to extend
   *
   * @returns an extended XRSessionInit object
   */
  async _extendXRSessionInitObject(xrSessionInit) {
    const enabledFeatures = this.getEnabledFeatures();
    for (const featureName of enabledFeatures) {
      const feature = this._features[featureName];
      const nativeName = feature.featureImplementation.xrNativeFeatureName;
      if (nativeName) {
        if (feature.required) {
          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.requiredFeatures.push(nativeName);
          }
        } else {
          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
            xrSessionInit.optionalFeatures.push(nativeName);
          }
        }
      }
      if (feature.featureImplementation.getXRSessionInitExtension) {
        const extended = await feature.featureImplementation.getXRSessionInitExtension();
        xrSessionInit = {
          ...xrSessionInit,
          ...extended
        };
      }
    }
    return xrSessionInit;
  }
};
WebXRFeaturesManager._AvailableFeatures = {};
WebXRFeaturesManager._ConflictingFeatures = {
  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,
  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION
};

// node_modules/@babylonjs/core/XR/features/WebXRAbstractFeature.js
var WebXRAbstractFeature = class {
  /**
   * The name of the native xr feature name (like anchor, hit-test, or hand-tracking)
   */
  get xrNativeFeatureName() {
    return this._xrNativeFeatureName;
  }
  set xrNativeFeatureName(name4) {
    var _a;
    if (!this._xrSessionManager.isNative && name4 && this._xrSessionManager.inXRSession && ((_a = this._xrSessionManager.enabledFeatures) == null ? void 0 : _a.indexOf(name4)) === -1) {
      Logger.Warn(`The feature ${name4} needs to be enabled before starting the XR session. Note - It is still possible it is not supported.`);
    }
    this._xrNativeFeatureName = name4;
  }
  /**
   * Construct a new (abstract) WebXR feature
   * @param _xrSessionManager the xr session manager for this feature
   */
  constructor(_xrSessionManager) {
    this._xrSessionManager = _xrSessionManager;
    this._attached = false;
    this._removeOnDetach = [];
    this.isDisposed = false;
    this.disableAutoAttach = false;
    this._xrNativeFeatureName = "";
    this.onFeatureAttachObservable = new Observable();
    this.onFeatureDetachObservable = new Observable();
  }
  /**
   * Is this feature attached
   */
  get attached() {
    return this._attached;
  }
  /**
   * attach this feature
   *
   * @param force should attachment be forced (even when already attached)
   * @returns true if successful, false is failed or already attached
   */
  attach(force) {
    if (this.isDisposed) {
      return false;
    }
    if (!force) {
      if (this.attached) {
        return false;
      }
    } else {
      if (this.attached) {
        this.detach();
      }
    }
    if (!this._xrSessionManager.enabledFeatures) {
      Logger.Warn("session.enabledFeatures is not available on this device. It is possible that this feature is not supported.");
    } else if (!this._xrSessionManager.isNative && this.xrNativeFeatureName && this._xrSessionManager.enabledFeatures.indexOf(this.xrNativeFeatureName) === -1) {
      return false;
    }
    this._attached = true;
    this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable, (frame) => this._onXRFrame(frame));
    this.onFeatureAttachObservable.notifyObservers(this);
    return true;
  }
  /**
   * detach this feature.
   *
   * @returns true if successful, false if failed or already detached
   */
  detach() {
    if (!this._attached) {
      this.disableAutoAttach = true;
      return false;
    }
    this._attached = false;
    this._removeOnDetach.forEach((toRemove) => {
      toRemove.observable.remove(toRemove.observer);
    });
    this.onFeatureDetachObservable.notifyObservers(this);
    return true;
  }
  /**
   * Dispose this feature and all of the resources attached
   */
  dispose() {
    this.detach();
    this.isDisposed = true;
    this.onFeatureAttachObservable.clear();
    this.onFeatureDetachObservable.clear();
  }
  /**
   * This function will be executed during before enabling the feature and can be used to not-allow enabling it.
   * Note that at this point the session has NOT started, so this is purely checking if the browser supports it
   *
   * @returns whether or not the feature is compatible in this environment
   */
  isCompatible() {
    return true;
  }
  /**
   * This is used to register callbacks that will automatically be removed when detach is called.
   * @param observable the observable to which the observer will be attached
   * @param callback the callback to register
   * @param insertFirst should the callback be executed as soon as it is registered
   */
  _addNewAttachObserver(observable, callback, insertFirst) {
    this._removeOnDetach.push({
      observable,
      observer: observable.add(callback, void 0, insertFirst)
    });
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsJoint.js
var PhysicsJoint = class {
  /**
   * Initializes the physics joint
   * @param type The type of the physics joint
   * @param jointData The data for the physics joint
   */
  constructor(type, jointData) {
    this.type = type;
    this.jointData = jointData;
    jointData.nativeParams = jointData.nativeParams || {};
  }
  /**
   * Gets the physics joint
   */
  get physicsJoint() {
    return this._physicsJoint;
  }
  /**
   * Sets the physics joint
   */
  set physicsJoint(newJoint) {
    if (this._physicsJoint) {
    }
    this._physicsJoint = newJoint;
  }
  /**
   * Sets the physics plugin
   */
  set physicsPlugin(physicsPlugin) {
    this._physicsPlugin = physicsPlugin;
  }
  /**
   * Execute a function that is physics-plugin specific.
   * @param {Function} func the function that will be executed.
   *                        It accepts two parameters: the physics world and the physics joint
   */
  executeNativeFunction(func) {
    func(this._physicsPlugin.world, this._physicsJoint);
  }
};
PhysicsJoint.DistanceJoint = 0;
PhysicsJoint.HingeJoint = 1;
PhysicsJoint.BallAndSocketJoint = 2;
PhysicsJoint.WheelJoint = 3;
PhysicsJoint.SliderJoint = 4;
PhysicsJoint.PrismaticJoint = 5;
PhysicsJoint.UniversalJoint = 6;
PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
PhysicsJoint.PointToPointJoint = 8;
PhysicsJoint.SpringJoint = 9;
PhysicsJoint.LockJoint = 10;
var DistanceJoint = class extends PhysicsJoint {
  /**
   *
   * @param jointData The data for the Distance-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.DistanceJoint, jointData);
  }
  /**
   * Update the predefined distance.
   * @param maxDistance The maximum preferred distance
   * @param minDistance The minimum preferred distance
   */
  updateDistance(maxDistance, minDistance) {
    this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
  }
};
var MotorEnabledJoint = class extends PhysicsJoint {
  /**
   * Initializes the Motor-Enabled Joint
   * @param type The type of the joint
   * @param jointData The physical joint data for the joint
   */
  constructor(type, jointData) {
    super(type, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param force the force to apply
   * @param maxForce max force for this motor.
   */
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  /**
   * Set the motor's limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit The upper limit of the motor
   * @param lowerLimit The lower limit of the motor
   */
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var HingeJoint = class extends MotorEnabledJoint {
  /**
   * Initializes the Hinge-Joint
   * @param jointData The joint data for the Hinge-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.HingeJoint, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param {number} force the force to apply
   * @param {number} maxForce max force for this motor.
   */
  setMotor(force, maxForce) {
    this._physicsPlugin.setMotor(this, force || 0, maxForce);
  }
  /**
   * Set the motor's limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit The upper limit of the motor
   * @param lowerLimit The lower limit of the motor
   */
  setLimit(upperLimit, lowerLimit) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
  }
};
var Hinge2Joint = class extends MotorEnabledJoint {
  /**
   * Initializes the Hinge2-Joint
   * @param jointData The joint data for the Hinge2-Joint
   */
  constructor(jointData) {
    super(PhysicsJoint.Hinge2Joint, jointData);
  }
  /**
   * Set the motor values.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param targetSpeed the speed the motor is to reach
   * @param maxForce max force for this motor.
   * @param motorIndex motor's index, 0 or 1.
   */
  setMotor(targetSpeed, maxForce, motorIndex = 0) {
    this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
  }
  /**
   * Set the motor limits.
   * Attention, this function is plugin specific. Engines won't react 100% the same.
   * @param upperLimit the upper limit
   * @param lowerLimit lower limit
   * @param motorIndex the motor's index, 0 or 1.
   */
  setLimit(upperLimit, lowerLimit, motorIndex = 0) {
    this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
  }
};

// node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js
Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
    mass: jsonObject.physicsMass,
    friction: jsonObject.physicsFriction,
    restitution: jsonObject.physicsRestitution
  }, scene);
};
var PhysicsImpostor = class _PhysicsImpostor {
  /**
   * Specifies if the physics imposter is disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets the mass of the physics imposter
   */
  get mass() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
  }
  set mass(value) {
    this.setMass(value);
  }
  /**
   * Gets the coefficient of friction
   */
  get friction() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
  }
  /**
   * Sets the coefficient of friction
   */
  set friction(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
  }
  /**
   * Gets the coefficient of restitution
   */
  get restitution() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
  }
  /**
   * Sets the coefficient of restitution
   */
  set restitution(value) {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
  }
  /**
   * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  get pressure() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return 0;
    }
    return plugin.getBodyPressure(this);
  }
  /**
   * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
   */
  set pressure(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPressure) {
      return;
    }
    plugin.setBodyPressure(this, value);
  }
  /**
   * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  get stiffness() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyStiffness) {
      return 0;
    }
    return plugin.getBodyStiffness(this);
  }
  /**
   * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
   */
  set stiffness(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyStiffness) {
      return;
    }
    plugin.setBodyStiffness(this, value);
  }
  /**
   * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get velocityIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyVelocityIterations) {
      return 0;
    }
    return plugin.getBodyVelocityIterations(this);
  }
  /**
   * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set velocityIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyVelocityIterations) {
      return;
    }
    plugin.setBodyVelocityIterations(this, value);
  }
  /**
   * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  get positionIterations() {
    if (!this._physicsEngine) {
      return 0;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.getBodyPositionIterations) {
      return 0;
    }
    return plugin.getBodyPositionIterations(this);
  }
  /**
   * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
   */
  set positionIterations(value) {
    if (!this._physicsEngine) {
      return;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.setBodyPositionIterations) {
      return;
    }
    plugin.setBodyPositionIterations(this, value);
  }
  /**
   * Initializes the physics imposter
   * @param object The physics-enabled object used as the physics imposter
   * @param type The type of the physics imposter. Types are available as static members of this class.
   * @param _options The options for the physics imposter
   * @param _scene The Babylon scene
   */
  constructor(object, type, _options = { mass: 0 }, _scene) {
    this.object = object;
    this.type = type;
    this._options = _options;
    this._scene = _scene;
    this._pluginData = {};
    this._bodyUpdateRequired = false;
    this._onBeforePhysicsStepCallbacks = new Array();
    this._onAfterPhysicsStepCallbacks = new Array();
    this._onPhysicsCollideCallbacks = [];
    this._deltaPosition = Vector3.Zero();
    this._isDisposed = false;
    this.soft = false;
    this.segments = 0;
    this._tmpQuat = new Quaternion();
    this._tmpQuat2 = new Quaternion();
    this.beforeStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this.object.translate(this._deltaPosition, -1);
      this._deltaRotationConjugated && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
      this.object.computeWorldMatrix(false);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
      } else {
        this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
      }
      if (!this._options.disableBidirectionalTransformation) {
        this.object.rotationQuaternion && this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(
          this,
          /*bInfo.boundingBox.centerWorld*/
          this.object.getAbsolutePosition(),
          this._tmpQuat
        );
      }
      this._onBeforePhysicsStepCallbacks.forEach((func) => {
        func(this);
      });
    };
    this.afterStep = () => {
      if (!this._physicsEngine) {
        return;
      }
      this._onAfterPhysicsStepCallbacks.forEach((func) => {
        func(this);
      });
      this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);
      if (this.object.parent && this.object.rotationQuaternion) {
        this.getParentsRotation();
        this._tmpQuat.conjugateInPlace();
        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
      }
      this.object.setAbsolutePosition(this.object.position);
      if (this._deltaRotation) {
        this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
        this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, _PhysicsImpostor._TmpVecs[0]);
        this.object.translate(_PhysicsImpostor._TmpVecs[0], 1);
      } else {
        this.object.translate(this._deltaPosition, 1);
      }
      this.object.computeWorldMatrix(true);
    };
    this.onCollideEvent = null;
    this.onCollide = (e) => {
      if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {
        return;
      }
      if (!this._physicsEngine) {
        return;
      }
      const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);
      if (otherImpostor) {
        if (this.onCollideEvent) {
          this.onCollideEvent(this, otherImpostor);
        }
        this._onPhysicsCollideCallbacks.filter((obj) => {
          return obj.otherImpostors.indexOf(otherImpostor) !== -1;
        }).forEach((obj) => {
          obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);
        });
      }
    };
    if (!this.object) {
      Logger.Error("No object was provided. A physics object is obligatory");
      return;
    }
    if (this.object.parent && _options.mass !== 0) {
      Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
    }
    if (!this._scene && object.getScene) {
      this._scene = object.getScene();
    }
    if (!this._scene) {
      return;
    }
    if (this.type > 100) {
      this.soft = true;
    }
    this._physicsEngine = this._scene.getPhysicsEngine();
    if (!this._physicsEngine) {
      Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
    } else {
      if (!this.object.rotationQuaternion) {
        if (this.object.rotation) {
          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
        } else {
          this.object.rotationQuaternion = new Quaternion();
        }
      }
      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
      if (this.soft) {
        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
        this._options.path = _options.path === void 0 ? null : _options.path;
        this._options.shape = _options.shape === void 0 ? null : _options.shape;
      }
      this._joints = [];
      if (!this.object.parent || this._options.ignoreParent) {
        this._init();
      } else if (this.object.parent.physicsImpostor) {
        Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
      }
    }
  }
  /**
   * This function will completely initialize this impostor.
   * It will create a new body - but only if this mesh has no parent.
   * If it has, this impostor will not be used other than to define the impostor
   * of the child mesh.
   * @internal
   */
  _init() {
    if (!this._physicsEngine) {
      return;
    }
    this._physicsEngine.removeImpostor(this);
    this.physicsBody = null;
    this._parent = this._parent || this._getPhysicsParent();
    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
      this._physicsEngine.addImpostor(this);
    }
  }
  _getPhysicsParent() {
    if (this.object.parent instanceof AbstractMesh) {
      const parentMesh = this.object.parent;
      return parentMesh.physicsImpostor;
    }
    return null;
  }
  /**
   * Should a new body be generated.
   * @returns boolean specifying if body initialization is required
   */
  isBodyInitRequired() {
    return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);
  }
  /**
   * Sets the updated scaling
   */
  setScalingUpdated() {
    this.forceUpdate();
  }
  /**
   * Force a regeneration of this or the parent's impostor's body.
   * Use with caution - This will remove all previously-instantiated joints.
   */
  forceUpdate() {
    this._init();
    if (this.parent && !this._options.ignoreParent) {
      this.parent.forceUpdate();
    }
  }
  /*public get mesh(): AbstractMesh {
      return this._mesh;
  }*/
  /**
   * Gets the body that holds this impostor. Either its own, or its parent.
   */
  get physicsBody() {
    return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
  }
  /**
   * Get the parent of the physics imposter
   * @returns Physics imposter or null
   */
  get parent() {
    return !this._options.ignoreParent && this._parent ? this._parent : null;
  }
  /**
   * Sets the parent of the physics imposter
   */
  set parent(value) {
    this._parent = value;
  }
  /**
   * Set the physics body. Used mainly by the physics engine/plugin
   */
  set physicsBody(physicsBody) {
    if (this._physicsBody && this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
    }
    this._physicsBody = physicsBody;
    this.resetUpdateFlags();
  }
  /**
   * Resets the update flags
   */
  resetUpdateFlags() {
    this._bodyUpdateRequired = false;
  }
  /**
   * Gets the object extents
   * @returns the object extents
   */
  getObjectExtents() {
    if (this.object.getBoundingInfo) {
      const q = this.object.rotationQuaternion;
      const scaling = this.object.scaling.clone();
      this.object.rotationQuaternion = _PhysicsImpostor.IDENTITY_QUATERNION;
      const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      if (worldMatrix) {
        worldMatrix.decompose(scaling, void 0, void 0);
      }
      const boundingInfo = this.object.getBoundingInfo();
      const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
      size.x = Math.abs(size.x);
      size.y = Math.abs(size.y);
      size.z = Math.abs(size.z);
      this.object.rotationQuaternion = q;
      this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
      return size;
    } else {
      return _PhysicsImpostor.DEFAULT_OBJECT_SIZE;
    }
  }
  /**
   * Gets the object center
   * @returns The object center
   */
  getObjectCenter() {
    if (this.object.getBoundingInfo) {
      const boundingInfo = this.object.getBoundingInfo();
      return boundingInfo.boundingBox.centerWorld;
    } else {
      return this.object.position;
    }
  }
  /**
   * Get a specific parameter from the options parameters
   * @param paramName The object parameter name
   * @returns The object parameter
   */
  getParam(paramName) {
    return this._options[paramName];
  }
  /**
   * Sets a specific parameter in the options given to the physics plugin
   * @param paramName The parameter name
   * @param value The value of the parameter
   */
  setParam(paramName, value) {
    this._options[paramName] = value;
    this._bodyUpdateRequired = true;
  }
  /**
   * Specifically change the body's mass. Won't recreate the physics body object
   * @param mass The mass of the physics imposter
   */
  setMass(mass) {
    if (this.getParam("mass") !== mass) {
      this.setParam("mass", mass);
    }
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
    }
  }
  /**
   * Gets the linear velocity
   * @returns  linear velocity or null
   */
  getLinearVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the linear velocity
   * @param velocity  linear velocity or null
   */
  setLinearVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
    }
  }
  /**
   * Gets the angular velocity
   * @returns angular velocity or null
   */
  getAngularVelocity() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
  }
  /**
   * Sets the angular velocity
   * @param velocity The velocity or null
   */
  setAngularVelocity(velocity) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
    }
  }
  /**
   * Execute a function with the physics plugin native code
   * Provide a function the will have two variables - the world object and the physics body object
   * @param func The function to execute with the physics plugin native code
   */
  executeNativeFunction(func) {
    if (this._physicsEngine) {
      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
    }
  }
  /**
   * Register a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  registerBeforePhysicsStep(func) {
    this._onBeforePhysicsStepCallbacks.push(func);
  }
  /**
   * Unregister a function that will be executed before the physics world is stepping forward
   * @param func The function to execute before the physics world is stepped forward
   */
  unregisterBeforePhysicsStep(func) {
    const index = this._onBeforePhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onBeforePhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Register a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  registerAfterPhysicsStep(func) {
    this._onAfterPhysicsStepCallbacks.push(func);
  }
  /**
   * Unregisters a function that will be executed after the physics step
   * @param func The function to execute after physics step
   */
  unregisterAfterPhysicsStep(func) {
    const index = this._onAfterPhysicsStepCallbacks.indexOf(func);
    if (index > -1) {
      this._onAfterPhysicsStepCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * register a function that will be executed when this impostor collides against a different body
   * @param collideAgainst Physics imposter, or array of physics imposters to collide against
   * @param func Callback that is executed on collision
   */
  registerOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
  }
  /**
   * Unregisters the physics imposter's collision callback
   * @param collideAgainst The physics object to collide against
   * @param func Callback to execute on collision
   */
  unregisterOnPhysicsCollide(collideAgainst, func) {
    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
    let index = -1;
    const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {
      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
        const sameList = cbDef.otherImpostors.every((impostor) => {
          return collidedAgainstList.indexOf(impostor) > -1;
        });
        if (sameList) {
          index = idx;
        }
        return sameList;
      }
      return false;
    });
    if (found) {
      this._onPhysicsCollideCallbacks.splice(index, 1);
    } else {
      Logger.Warn("Function to remove was not found");
    }
  }
  /**
   * Get the parent rotation
   * @returns The parent rotation
   */
  getParentsRotation() {
    let parent = this.object.parent;
    this._tmpQuat.copyFromFloats(0, 0, 0, 1);
    while (parent) {
      if (parent.rotationQuaternion) {
        this._tmpQuat2.copyFrom(parent.rotationQuaternion);
      } else {
        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
      }
      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
      parent = parent.parent;
    }
    return this._tmpQuat;
  }
  /**
   * Apply a force
   * @param force The force to apply
   * @param contactPoint The contact point for the force
   * @returns The physics imposter
   */
  applyForce(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
    }
    return this;
  }
  /**
   * Apply an impulse
   * @param force The impulse force
   * @param contactPoint The contact point for the impulse force
   * @returns The physics imposter
   */
  applyImpulse(force, contactPoint) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
    }
    return this;
  }
  /**
   * A help function to create a joint
   * @param otherImpostor A physics imposter used to create a joint
   * @param jointType The type of joint
   * @param jointData The data for the joint
   * @returns The physics imposter
   */
  createJoint(otherImpostor, jointType, jointData) {
    const joint = new PhysicsJoint(jointType, jointData);
    this.addJoint(otherImpostor, joint);
    return this;
  }
  /**
   * Add a joint to this impostor with a different impostor
   * @param otherImpostor A physics imposter used to add a joint
   * @param joint The joint to add
   * @returns The physics imposter
   */
  addJoint(otherImpostor, joint) {
    this._joints.push({
      otherImpostor,
      joint
    });
    if (this._physicsEngine) {
      this._physicsEngine.addJoint(this, otherImpostor, joint);
    }
    return this;
  }
  /**
   * Add an anchor to a cloth impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param width ratio across width from 0 to 1
   * @param height ratio up height from 0 to 1
   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
   * @returns impostor the soft imposter
   */
  addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Add a hook to a rope impostor
   * @param otherImpostor rigid impostor to anchor to
   * @param length ratio across rope from 0 to 1
   * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch
   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
   * @returns impostor the rope imposter
   */
  addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
    if (!this._physicsEngine) {
      return this;
    }
    const plugin = this._physicsEngine.getPhysicsPlugin();
    if (!plugin.appendAnchor) {
      return this;
    }
    if (this._physicsEngine) {
      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
    }
    return this;
  }
  /**
   * Will keep this body still, in a sleep mode.
   * @returns the physics imposter
   */
  sleep() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().sleepBody(this);
    }
    return this;
  }
  /**
   * Wake the body up.
   * @returns The physics imposter
   */
  wakeUp() {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
    }
    return this;
  }
  /**
   * Clones the physics imposter
   * @param newObject The physics imposter clones to this physics-enabled object
   * @returns A nullable physics imposter
   */
  clone(newObject) {
    if (!newObject) {
      return null;
    }
    return new _PhysicsImpostor(newObject, this.type, this._options, this._scene);
  }
  /**
   * Disposes the physics imposter
   */
  dispose() {
    if (!this._physicsEngine) {
      return;
    }
    this._joints.forEach((j) => {
      if (this._physicsEngine) {
        this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);
      }
    });
    this._physicsEngine.removeImpostor(this);
    if (this.parent) {
      this.parent.forceUpdate();
    } else {
    }
    this._isDisposed = true;
  }
  /**
   * Sets the delta position
   * @param position The delta position amount
   */
  setDeltaPosition(position) {
    this._deltaPosition.copyFrom(position);
  }
  /**
   * Sets the delta rotation
   * @param rotation The delta rotation amount
   */
  setDeltaRotation(rotation) {
    if (!this._deltaRotation) {
      this._deltaRotation = new Quaternion();
    }
    this._deltaRotation.copyFrom(rotation);
    this._deltaRotationConjugated = this._deltaRotation.conjugate();
  }
  /**
   * Gets the box size of the physics imposter and stores the result in the input parameter
   * @param result Stores the box size
   * @returns The physics imposter
   */
  getBoxSizeToRef(result) {
    if (this._physicsEngine) {
      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
    }
    return this;
  }
  /**
   * Gets the radius of the physics imposter
   * @returns Radius of the physics imposter
   */
  getRadius() {
    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
  }
  /**
   * Sync a bone with this impostor
   * @param bone The bone to sync to the impostor.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   */
  syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
    const tempVec = _PhysicsImpostor._TmpVecs[0];
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
        bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);
      } else {
        bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);
      }
    }
    tempVec.x = 0;
    tempVec.y = 0;
    tempVec.z = 0;
    if (jointPivot) {
      tempVec.x = jointPivot.x;
      tempVec.y = jointPivot.y;
      tempVec.z = jointPivot.z;
      bone.getDirectionToRef(tempVec, boneMesh, tempVec);
      if (distToJoint === void 0 || distToJoint === null) {
        distToJoint = jointPivot.length();
      }
      tempVec.x *= distToJoint;
      tempVec.y *= distToJoint;
      tempVec.z *= distToJoint;
    }
    if (bone.getParent()) {
      tempVec.addInPlace(mesh.getAbsolutePosition());
      bone.setAbsolutePosition(tempVec, boneMesh);
    } else {
      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
      boneMesh.position.x -= tempVec.x;
      boneMesh.position.y -= tempVec.y;
      boneMesh.position.z -= tempVec.z;
    }
  }
  /**
   * Sync impostor to a bone
   * @param bone The bone that the impostor will be synced to.
   * @param boneMesh The mesh that the bone is influencing.
   * @param jointPivot The pivot of the joint / bone in local space.
   * @param distToJoint Optional distance from the impostor to the joint.
   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
   * @param boneAxis Optional vector3 axis the bone is aligned with
   */
  syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
    const mesh = this.object;
    if (mesh.rotationQuaternion) {
      if (adjustRotation) {
        const tempQuat = _PhysicsImpostor._TmpQuat;
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);
        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
      } else {
        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);
      }
    }
    const pos = _PhysicsImpostor._TmpVecs[0];
    const boneDir = _PhysicsImpostor._TmpVecs[1];
    if (!boneAxis) {
      boneAxis = _PhysicsImpostor._TmpVecs[2];
      boneAxis.x = 0;
      boneAxis.y = 1;
      boneAxis.z = 0;
    }
    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
    bone.getAbsolutePositionToRef(boneMesh, pos);
    if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
      distToJoint = jointPivot.length();
    }
    if (distToJoint !== void 0 && distToJoint !== null) {
      pos.x += boneDir.x * distToJoint;
      pos.y += boneDir.y * distToJoint;
      pos.z += boneDir.z * distToJoint;
    }
    mesh.setAbsolutePosition(pos);
  }
};
PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
PhysicsImpostor._TmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);
PhysicsImpostor._TmpQuat = Quaternion.Identity();
PhysicsImpostor.NoImpostor = 0;
PhysicsImpostor.SphereImpostor = 1;
PhysicsImpostor.BoxImpostor = 2;
PhysicsImpostor.PlaneImpostor = 3;
PhysicsImpostor.MeshImpostor = 4;
PhysicsImpostor.CapsuleImpostor = 6;
PhysicsImpostor.CylinderImpostor = 7;
PhysicsImpostor.ParticleImpostor = 8;
PhysicsImpostor.HeightmapImpostor = 9;
PhysicsImpostor.ConvexHullImpostor = 10;
PhysicsImpostor.CustomImpostor = 100;
PhysicsImpostor.RopeImpostor = 101;
PhysicsImpostor.ClothImpostor = 102;
PhysicsImpostor.SoftbodyImpostor = 103;

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
(function(NodeMaterialBlockConnectionPointTypes2) {
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["All"] = 4095] = "All";
})(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
(function(NodeMaterialBlockTargets2) {
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
})(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates;
(function(NodeMaterialConnectionPointCompatibilityStates2) {
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["HierarchyIssue"] = 3] = "HierarchyIssue";
})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
var NodeMaterialConnectionPointDirection;
(function(NodeMaterialConnectionPointDirection2) {
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
var NodeMaterialConnectionPoint = class _NodeMaterialConnectionPoint {
  /**
   * Checks if two types are equivalent
   * @param type1 type 1 to check
   * @param type2 type 2 to check
   * @returns true if both types are equivalent, else false
   */
  static AreEquivalentTypes(type1, type2) {
    switch (type1) {
      case NodeMaterialBlockConnectionPointTypes.Vector3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Vector4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
          return true;
        }
        break;
      }
    }
    return false;
  }
  /** Gets the direction of the point */
  get direction() {
    return this._direction;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.associatedVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.associatedVariableName;
    }
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
  get innerType() {
    if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {
        return this._linkedConnectionSource.type;
      }
    }
    if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
          return this._defaultConnectionPointType;
        }
        return this._typeConnectionSource.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  /** Gets or sets the target of that connection point */
  get target() {
    if (!this._prioritizeVertex || !this._ownerBlock) {
      return this._target;
    }
    if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
      return this._target;
    }
    if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      return NodeMaterialBlockTargets.Fragment;
    }
    return NodeMaterialBlockTargets.Vertex;
  }
  set target(value) {
    this._target = value;
  }
  /**
   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
   */
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  /**
   * Gets a boolean indicating that the current point is connected to an input block
   */
  get isConnectedToInputBlock() {
    return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
  }
  /**
   * Gets a the connected input block (if any)
   */
  get connectInputBlock() {
    if (!this.isConnectedToInputBlock) {
      return null;
    }
    return this.connectedPoint.ownerBlock;
  }
  /** Get the other side of the connection (if any) */
  get connectedPoint() {
    return this._connectedPoint;
  }
  /** Get the block that owns this connection point */
  get ownerBlock() {
    return this._ownerBlock;
  }
  /** Get the block connected on the other side of this connection (if any) */
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  /** Get the block connected on the endpoints of this connection (if any) */
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  /** Gets the list of connected endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /** Gets a boolean indicating if that output point is connected to at least one input */
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  /** Gets a boolean indicating that this connection has a path to the vertex output*/
  get isDirectlyConnectedToVertexOutput() {
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the vertex shader */
  get isConnectedInVertexShader() {
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader */
  get isConnectedInFragmentShader() {
    if (this.target === NodeMaterialBlockTargets.Fragment) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.isConnectedInFragmentShader()) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Creates a block suitable to be used as an input for this input point.
   * If null is returned, a block based on the point type will be created.
   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
   */
  createCustomInputBlock() {
    return null;
  }
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   */
  constructor(name4, ownerBlock, direction) {
    this._connectedPoint = null;
    this._endpoints = new Array();
    this._typeConnectionSource = null;
    this._defaultConnectionPointType = null;
    this._linkedConnectionSource = null;
    this._acceptedConnectionPointType = null;
    this._type = NodeMaterialBlockConnectionPointTypes.Float;
    this._enforceAssociatedVariableName = false;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = [];
    this.excludedConnectionPointTypes = [];
    this.onConnectionObservable = new Observable();
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._prioritizeVertex = false;
    this._target = NodeMaterialBlockTargets.VertexAndFragment;
    this._ownerBlock = ownerBlock;
    this.name = name4;
    this._direction = direction;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialConnectionPoint"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialConnectionPoint";
  }
  /**
   * Gets a boolean indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a boolean
   */
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
      }
      for (const output of otherBlock.outputs) {
        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {
          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;
        }
      }
    }
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (_NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      }
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && _NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
        return NodeMaterialConnectionPointCompatibilityStates.Compatible;
      } else {
        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === NodeMaterialConnectionPointDirection.Input) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;
    }
    return NodeMaterialConnectionPointCompatibilityStates.Compatible;
  }
  /**
   * Connect this point to another connection point
   * @param connectionPoint defines the other connection point
   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
   * @returns the current connection point
   */
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw "Cannot connect these two connectors.";
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this._enforceAssociatedVariableName = false;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Disconnect this point from one of his endpoint
   * @param endpoint defines the other connection point
   * @returns the current connection point
   */
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this._enforceAssociatedVariableName = false;
    endpoint._enforceAssociatedVariableName = false;
    return this;
  }
  /**
   * Fill the list of excluded connection point types with all types other than those passed in the parameter
   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
   */
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 1;
    while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {
      if (!(mask & bitmask)) {
        this.excludedConnectionPointTypes.push(bitmask);
      }
      bitmask = bitmask << 1;
    }
  }
  /**
   * Serializes this point in a JSON representation
   * @param isInput defines if the connection point is an input (default is true)
   * @returns the serialized point object
   */
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.displayName = this.displayName;
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  }
  /**
   * Release resources
   */
  dispose() {
    this.onConnectionObservable.clear();
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock = class {
  /**
   * Gets the name of the block
   */
  get name() {
    return this._name;
  }
  /**
   * Sets the name of the block. Will check if the name is valid.
   */
  set name(newName) {
    if (!this.validateBlockName(newName)) {
      return;
    }
    this._name = newName;
  }
  /**
   * Gets a boolean indicating that this block can only be used once per NodeMaterial
   */
  get isUnique() {
    return this._isUnique;
  }
  /**
   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
   */
  get isFinalMerger() {
    return this._isFinalMerger;
  }
  /**
   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
   */
  get isInput() {
    return this._isInput;
  }
  /**
   * Gets a boolean indicating if this block is a teleport out
   */
  get isTeleportOut() {
    return this._isTeleportOut;
  }
  /**
   * Gets a boolean indicating if this block is a teleport in
   */
  get isTeleportIn() {
    return this._isTeleportIn;
  }
  /**
   * Gets or sets the build Id
   */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  /**
   * Gets the list of input points
   */
  get inputs() {
    return this._inputs;
  }
  /** Gets the list of output points */
  get outputs() {
    return this._outputs;
  }
  /**
   * Find an input by its name
   * @param name defines the name of the input to look for
   * @returns the input or null if not found
   */
  getInputByName(name4) {
    const filter = this._inputs.filter((e) => e.name === name4);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Find an output by its name
   * @param name defines the name of the output to look for
   * @returns the output or null if not found
   */
  getOutputByName(name4) {
    const filter = this._outputs.filter((e) => e.name === name4);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Creates a new NodeMaterialBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
   */
  constructor(name4, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false) {
    this._isFinalMerger = false;
    this._isInput = false;
    this._isTeleportOut = false;
    this._isTeleportIn = false;
    this._name = "";
    this._isUnique = false;
    this.inputsAreExclusive = false;
    this._codeVariableName = "";
    this._inputs = new Array();
    this._outputs = new Array();
    this.comments = "";
    this.visibleInInspector = false;
    this.visibleOnFrame = false;
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
    this._isFinalMerger = isFinalMerger;
    this._isInput = this.getClassName() === "InputBlock";
    this._isTeleportOut = this.getClassName() === "NodeMaterialTeleportOutBlock";
    this._isTeleportIn = this.getClassName() === "NodeMaterialTeleportInBlock";
    this._name = name4;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  /** @internal */
  _setInitialTarget(target) {
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initialize(state) {
  }
  /**
   * Bind data to effect. Will only be called for blocks with isBindable === true
   * @param effect defines the effect to bind data to
   * @param nodeMaterial defines the hosting NodeMaterial
   * @param mesh defines the mesh that will be rendered
   * @param subMesh defines the submesh that will be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bind(effect, nodeMaterial, mesh, subMesh) {
  }
  _declareOutput(output, state) {
    return `${state._getGLType(output.type)} ${output.associatedVariableName}`;
  }
  _writeVariable(currentPoint) {
    const connectionPoint = currentPoint.connectedPoint;
    if (connectionPoint) {
      return `${currentPoint.associatedVariableName}`;
    }
    return `0.`;
  }
  _writeFloat(value) {
    let stringVersion = value.toString();
    if (stringVersion.indexOf(".") === -1) {
      stringVersion += ".0";
    }
    return `${stringVersion}`;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialBlock"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialBlock";
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader
   * @returns true if connected in fragment shader
   */
  isConnectedInFragmentShader() {
    return this.outputs.some((o) => o.isConnectedInFragmentShader);
  }
  /**
   * Register a new input. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param isOptional defines a boolean indicating that this input can be omitted
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerInput(name4, type, isOptional = false, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(name4, this, NodeMaterialConnectionPointDirection.Input);
    point.type = type;
    point.isOptional = isOptional;
    if (target) {
      point.target = target;
    }
    this._inputs.push(point);
    return this;
  }
  /**
   * Register a new output. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerOutput(name4, type, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(name4, this, NodeMaterialConnectionPointDirection.Output);
    point.type = type;
    if (target) {
      point.target = target;
    }
    this._outputs.push(point);
    return this;
  }
  /**
   * Will return the first available input e.g. the first one which is not an uniform or an attribute
   * @param forOutput defines an optional connection point to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableInput(forOutput = null) {
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          return input;
        }
      }
    }
    return null;
  }
  /**
   * Will return the first available output e.g. the first one which is not yet connected and not a varying
   * @param forBlock defines an optional block to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableOutput(forBlock = null) {
    for (const output of this._outputs) {
      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
        return output;
      }
    }
    return null;
  }
  /**
   * Gets the sibling of the given output
   * @param current defines the current output
   * @returns the next output in the list or null
   */
  getSiblingOutput(current) {
    const index = this._outputs.indexOf(current);
    if (index === -1 || index >= this._outputs.length) {
      return null;
    }
    return this._outputs[index + 1];
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Connect current block with another block
   * @param other defines the block to connect with
   * @param options define the various options to help pick the right connections
   * @param options.input
   * @param options.output
   * @param options.outputSwizzle
   * @returns the current block
   */
  connectTo(other, options) {
    if (this._outputs.length === 0) {
      return;
    }
    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
    let notFound = true;
    while (notFound) {
      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
      if (output && input && output.canConnectTo(input)) {
        output.connectTo(input);
        notFound = false;
      } else if (!output) {
        throw "Unable to find a compatible match";
      } else {
        output = this.getSiblingOutput(output);
      }
    }
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _buildBlock(state) {
  }
  /**
   * Add uniforms, samplers and uniform buffers at compilation time
   * @param state defines the state to update
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param uniformBuffers defines the list of uniform buffer names
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
  }
  /**
   * Add potential fallbacks if shader compilation fails
   * @param mesh defines the mesh to be rendered
   * @param fallbacks defines the current prioritized list of fallbacks
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  provideFallbacks(mesh, fallbacks) {
  }
  /**
   * Initialize defines for shader compilation
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param useInstances specifies that instances should be used
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initializeDefines(mesh, nodeMaterial, defines, useInstances = false) {
  }
  /**
   * Update defines for shader compilation
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param useInstances specifies that instances should be used
   * @param subMesh defines which submesh to render
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {
  }
  /**
   * Lets the block try to connect some inputs automatically
   * @param material defines the hosting NodeMaterial
   * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  autoConfigure(material, additionalFilteringInfo = () => true) {
  }
  /**
   * Function called when a block is declared as repeatable content generator
   * @param vertexShaderState defines the current compilation state for the vertex shader
   * @param fragmentShaderState defines the current compilation state for the fragment shader
   * @param mesh defines the mesh to be rendered
   * @param defines defines the material defines to update
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {
  }
  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */
  get willBeGeneratedIntoVertexShaderFromFragmentShader() {
    if (this.isInput || this.isFinalMerger) {
      return false;
    }
    if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {
      if (this._outputs.some((o) => o.isConnectedInVertexShader)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if the block is ready
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param useInstances specifies that instances should be used
   * @returns true if the block is ready
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReady(mesh, nodeMaterial, defines, useInstances = false) {
    return true;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  _processBuild(block, state, input, activeBlocks) {
    block.build(state, activeBlocks);
    const localBlockIsFragment = state._vertexState != null;
    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
      if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader
      block.isInput && block.isAttribute && !block._noContextSwitch) {
        const connectedPoint = input.connectedPoint;
        if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {
          state._vertexState.compilationString += `${"v_" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};
`;
        }
        input.associatedVariableName = "v_" + connectedPoint.associatedVariableName;
        input._enforceAssociatedVariableName = true;
      }
    }
  }
  /**
   * Validates the new name for the block node.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    const reservedNames = [
      "position",
      "normal",
      "tangent",
      "particle_positionw",
      "uv",
      "uv2",
      "uv3",
      "uv4",
      "uv5",
      "uv6",
      "position2d",
      "particle_uv",
      "matricesIndices",
      "matricesWeights",
      "world0",
      "world1",
      "world2",
      "world3",
      "particle_color",
      "particle_texturemask"
    ];
    for (const reservedName of reservedNames) {
      if (newName === reservedName) {
        return false;
      }
    }
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _customBuildStep(state, activeBlocks) {
  }
  /**
   * Compile the current node and generate the shader code
   * @param state defines the current compilation state (uniforms, samplers, current string)
   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
   * @returns true if already built
   */
  build(state, activeBlocks) {
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (!this.isInput) {
      for (const output of this._outputs) {
        if (!output.associatedVariableName) {
          output.associatedVariableName = state._getFreeVariableName(output.name);
        }
      }
    }
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      if (this.target !== NodeMaterialBlockTargets.Neutral) {
        if ((input.target & this.target) === 0) {
          continue;
        }
        if ((input.target & state.target) === 0) {
          continue;
        }
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        this._processBuild(block, state, input, activeBlocks);
      }
    }
    this._customBuildStep(state, activeBlocks);
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (state.sharedData.verbose) {
      Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader"}: Building ${this.name} [${this.getClassName()}]`);
    }
    if (this.isFinalMerger) {
      switch (state.target) {
        case NodeMaterialBlockTargets.Vertex:
          state.sharedData.checks.emitVertex = true;
          break;
        case NodeMaterialBlockTargets.Fragment:
          state.sharedData.checks.emitFragment = true;
          break;
      }
    }
    if (!this.isInput && state.sharedData.emitComments) {
      state.compilationString += `
//${this.name}
`;
    }
    this._buildBlock(state);
    this._buildId = state.sharedData.buildId;
    this._buildTarget = state.target;
    for (const output of this._outputs) {
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
          this._processBuild(block, state, endpoint, activeBlocks);
        }
      }
    }
    return false;
  }
  _inputRename(name4) {
    return name4;
  }
  _outputRename(name4) {
    return name4;
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleInInspector = ${this.visibleInInspector};
${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.target = ${this.target};
`;
  }
  /**
   * @internal
   */
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    let codeString = `
// ${this.getClassName()}
`;
    if (this.comments) {
      codeString += `// ${this.comments}
`;
    }
    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`;
    codeString += this._dumpPropertiesCode();
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  /**
   * @internal
   */
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a copy of the current block
   */
  clone(scene, rootUrl = "") {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const block = new blockType();
      block._deserialize(serializationObject, scene, rootUrl);
      return block;
    }
    return null;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.comments = this.comments;
    serializationObject.visibleInInspector = this.visibleInInspector;
    serializationObject.visibleOnFrame = this.visibleOnFrame;
    serializationObject.target = this.target;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _deserialize(serializationObject, scene, rootUrl) {
    this.name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleInInspector = !!serializationObject.visibleInInspector;
    this.visibleOnFrame = !!serializationObject.visibleOnFrame;
    this._target = serializationObject.target ?? this.target;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      serializedInputs.forEach((port, i) => {
        if (port.displayName) {
          this.inputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.inputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
    if (serializedOutputs) {
      serializedOutputs.forEach((port, i) => {
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      });
    }
  }
  /**
   * Release resources
   */
  dispose() {
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new TransformBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.complementW = 1;
    this.complementZ = 0;
    this.target = NodeMaterialBlockTargets.Vertex;
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].onConnectionObservable.add((other) => {
      if (other.ownerBlock.isInput) {
        const otherAsInput = other.ownerBlock;
        if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
          this.complementW = 0;
        }
      }
    });
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TransformBlock";
  }
  /**
   * Gets the vector input
   */
  get vector() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz output component
   */
  get xyz() {
    return this._outputs[1];
  }
  /**
   * Gets the matrix transform input
   */
  get transform() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const transform = this.transform;
    if (vector.connectedPoint) {
      if (this.complementW === 0) {
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.sharedData.blocksWithDefines.push(this);
        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);
        state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});
`;
        state.compilationString += `#ifdef NONUNIFORMSCALING
`;
        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));
`;
        state.compilationString += `#endif
`;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});
`;
            break;
        }
      } else {
        const transformName = transform.associatedVariableName;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};
`;
            break;
        }
      }
      if (this.xyz.hasEndpoints) {
        state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;
`;
      }
    }
    return this;
  }
  /**
   * Update defines for shader compilation
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   */
  prepareDefines(mesh, nodeMaterial, defines) {
    if (mesh.nonUniformScaling) {
      defines.setValue("NONUNIFORMSCALING", true);
    }
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.complementZ = this.complementZ;
    serializationObject.complementW = this.complementW;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
    this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};
`;
    codeString += `${this._codeVariableName}.complementW = ${this.complementW};
`;
    return codeString;
  }
};
RegisterClass("BABYLON.TransformBlock", TransformBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new VertexOutputBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Vertex, true);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VertexOutputBlock";
  }
  /**
   * Gets the vector input component
   */
  get vector() {
    return this._inputs[0];
  }
  _isLogarithmicDepthEnabled(nodeList, useLogarithmicDepth) {
    if (useLogarithmicDepth) {
      return true;
    }
    for (const node of nodeList) {
      if (node.useLogarithmicDepth) {
        return true;
      }
    }
    return false;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.vector;
    state.compilationString += `gl_Position = ${input.associatedVariableName};
`;
    if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {
      state._emitUniformFromString("logarithmicDepthConstant", "float");
      state._emitVaryingFromString("vFragmentDepth", "float");
      state.compilationString += `vFragmentDepth = 1.0 + gl_Position.w;
`;
      state.compilationString += `gl_Position.z = log2(max(0.000001, vFragmentDepth)) * logarithmicDepthConstant;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VertexOutputBlock", VertexOutputBlock);

// node_modules/@babylonjs/core/Decorators/nodeDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 4] = "List";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType = PropertyTypeForEdition.Boolean, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options ?? {}
    });
  };
}

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FragmentOutputBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment, true);
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this.useLogarithmicDepth = false;
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FragmentOutputBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("logarithmicDepthConstant");
    state._excludeVariableName("vFragmentDepth");
  }
  /**
   * Gets the rgba input component
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb input component
   */
  get rgb() {
    return this._inputs[1];
  }
  /**
   * Gets the a input component
   */
  get a() {
    return this._inputs[2];
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {
      BindLogDepth(void 0, effect, mesh.getScene());
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rgba = this.rgba;
    const rgb = this.rgb;
    const a = this.a;
    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
    state.sharedData.blocksWithDefines.push(this);
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      state._emitUniformFromString("logarithmicDepthConstant", "float");
      state._emitVaryingFromString("vFragmentDepth", "float");
      state.sharedData.bindableBlocks.push(this);
    }
    this._linearDefineName = state._getFreeDefineName("CONVERTTOLINEAR");
    this._gammaDefineName = state._getFreeDefineName("CONVERTTOGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    if (rgba.connectedPoint) {
      if (a.isConnected) {
        state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});
`;
      } else {
        state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};
`;
      }
    } else if (rgb.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});
`;
      } else {
        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});
`;
      }
    } else {
      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
    }
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);
`;
    state.compilationString += `#endif
`;
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;
`;
    }
    state.compilationString += `#if defined(PREPASS)\r
`;
    state.compilationString += `gl_FragData[0] = gl_FragColor;\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = serializationObject.convertToLinearSpace;
    this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;
  }
};
__decorate([
  editableInPropertyPage("Convert to gamma space", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], FragmentOutputBlock.prototype, "convertToGammaSpace", void 0);
__decorate([
  editableInPropertyPage("Convert to linear space", PropertyTypeForEdition.Boolean, "PROPERTIES", { notifiers: { update: true } })
], FragmentOutputBlock.prototype, "convertToLinearSpace", void 0);
__decorate([
  editableInPropertyPage("Use logarithmic depth", PropertyTypeForEdition.Boolean, "PROPERTIES")
], FragmentOutputBlock.prototype, "useLogarithmicDepth", void 0);
RegisterClass("BABYLON.FragmentOutputBlock", FragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointMode.js
var NodeMaterialBlockConnectionPointMode;
(function(NodeMaterialBlockConnectionPointMode2) {
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Uniform"] = 0] = "Uniform";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Attribute"] = 1] = "Attribute";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Varying"] = 2] = "Varying";
  NodeMaterialBlockConnectionPointMode2[NodeMaterialBlockConnectionPointMode2["Undefined"] = 3] = "Undefined";
})(NodeMaterialBlockConnectionPointMode || (NodeMaterialBlockConnectionPointMode = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
(function(NodeMaterialSystemValues2) {
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraParameters"] = 10] = "CameraParameters";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["MaterialAlpha"] = 11] = "MaterialAlpha";
})(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
(function(AnimatedInputBlockTypes2) {
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["RealTime"] = 2] = "RealTime";
})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName = {
  position2d: "position",
  particle_uv: "vUV",
  particle_color: "vColor",
  particle_texturemask: "textureMask",
  particle_positionw: "vPositionW"
};
var attributeInFragmentOnly = {
  particle_uv: true,
  particle_color: true,
  particle_texturemask: true,
  particle_positionw: true
};
var attributeAsUniform = {
  particle_texturemask: true
};
var InputBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this.isUniform && this.value != null) {
        if (!isNaN(this.value)) {
          this._type = NodeMaterialBlockConnectionPointTypes.Float;
          return this._type;
        }
        switch (this.value.getClassName()) {
          case "Vector2":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "Vector3":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "Vector4":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "Color3":
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case "Color4":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
          case "Matrix":
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
        }
      }
      if (this.isAttribute) {
        switch (this.name) {
          case "position":
          case "normal":
          case "particle_positionw":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "uv":
          case "uv2":
          case "uv3":
          case "uv4":
          case "uv5":
          case "uv6":
          case "position2d":
          case "particle_uv":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "matricesIndices":
          case "matricesWeights":
          case "matricesIndicesExtra":
          case "matricesWeightsExtra":
          case "world0":
          case "world1":
          case "world2":
          case "world3":
          case "tangent":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "color":
          case "instanceColor":
          case "particle_color":
          case "particle_texturemask":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
        }
      }
      if (this.isSystemValue) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.World:
          case NodeMaterialSystemValues.WorldView:
          case NodeMaterialSystemValues.WorldViewProjection:
          case NodeMaterialSystemValues.View:
          case NodeMaterialSystemValues.ViewProjection:
          case NodeMaterialSystemValues.Projection:
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
          case NodeMaterialSystemValues.CameraPosition:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case NodeMaterialSystemValues.FogColor:
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case NodeMaterialSystemValues.DeltaTime:
          case NodeMaterialSystemValues.MaterialAlpha:
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case NodeMaterialSystemValues.CameraParameters:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
        }
      }
    }
    return this._type;
  }
  /**
   * Creates a new InputBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
   */
  constructor(name4, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {
    super(name4, target, false);
    this._mode = NodeMaterialBlockConnectionPointMode.Undefined;
    this._animationType = AnimatedInputBlockTypes.None;
    this.min = 0;
    this.max = 0;
    this.isBoolean = false;
    this.matrixMode = 0;
    this._systemValue = null;
    this.isConstant = false;
    this.groupInInspector = "";
    this.onValueChangedObservable = new Observable();
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._type = type;
    this.setDefaultValue();
    this.registerOutput("output", type);
  }
  /**
   * Validates if a name is a reserve word.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    if (!this.isAttribute) {
      return super.validateBlockName(newName);
    }
    return true;
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Set the source of this connection point to a vertex attribute
   * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
   * @returns the current connection point
   */
  setAsAttribute(attributeName) {
    this._mode = NodeMaterialBlockConnectionPointMode.Attribute;
    if (attributeName) {
      this.name = attributeName;
    }
    return this;
  }
  /**
   * Set the source of this connection point to a system value
   * @param value define the system value to use (world, view, etc...) or null to switch to manual value
   * @returns the current connection point
   */
  setAsSystemValue(value) {
    this.systemValue = value;
    return this;
  }
  /**
   * Gets or sets the value of that point.
   * Please note that this value will be ignored if valueCallback is defined
   */
  get value() {
    return this._storedValue;
  }
  set value(value) {
    if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
      if (this.isBoolean) {
        value = value ? 1 : 0;
      } else if (this.min !== this.max) {
        value = Math.max(this.min, value);
        value = Math.min(this.max, value);
      }
    }
    this._storedValue = value;
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
    this.onValueChangedObservable.notifyObservers(this);
  }
  /**
   * Gets or sets a callback used to get the value of that point.
   * Please note that setting this value will force the connection point to ignore the value property
   */
  get valueCallback() {
    return this._valueCallback;
  }
  set valueCallback(value) {
    this._valueCallback = value;
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Gets or sets the type of animation applied to the input */
  get animationType() {
    return this._animationType;
  }
  set animationType(value) {
    this._animationType = value;
  }
  /**
   * Gets a boolean indicating that this connection point not defined yet
   */
  get isUndefined() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an uniform.
   * In this case the connection point name must be the name of the uniform to use.
   * Can only be set on inputs
   */
  get isUniform() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;
  }
  set isUniform(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an attribute.
   * In this case the connection point name must be the name of the attribute to use
   * Can only be set on inputs
   */
  get isAttribute() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;
  }
  set isAttribute(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is generating a varying variable.
   * Can only be set on exit points
   */
  get isVarying() {
    return this._mode === NodeMaterialBlockConnectionPointMode.Varying;
  }
  set isVarying(value) {
    this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;
    this.associatedVariableName = "";
  }
  /**
   * Gets a boolean indicating that the current connection point is a system value
   */
  get isSystemValue() {
    return this._systemValue != null;
  }
  /**
   * Gets or sets the current well known value or null if not defined as a system value
   */
  get systemValue() {
    return this._systemValue;
  }
  set systemValue(value) {
    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;
    this.associatedVariableName = "";
    this._systemValue = value;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InputBlock";
  }
  /**
   * Animate the input if animationType !== None
   * @param scene defines the rendering scene
   */
  animate(scene) {
    switch (this._animationType) {
      case AnimatedInputBlockTypes.Time: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value += scene.getAnimationRatio() * 0.01;
        }
        break;
      }
      case AnimatedInputBlockTypes.RealTime: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1e3;
        }
        break;
      }
    }
  }
  _emitDefine(define) {
    if (define[0] === "!") {
      return `#ifndef ${define.substring(1)}
`;
    }
    return `#ifdef ${define}
`;
  }
  initialize() {
    this.associatedVariableName = "";
  }
  /**
   * Set the input block to its default value (based on its type)
   */
  setDefaultValue() {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        this.value = Color3.White();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        this.value = new Color4(1, 1, 1, 1);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  }
  _emitConstant(state) {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return `${state._emitFloat(this.value)}`;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return `vec2(${this.value.x}, ${this.value.y})`;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;
    }
    return "";
  }
  /** @internal */
  get _noContextSwitch() {
    return attributeInFragmentOnly[this.name];
  }
  _emit(state, define) {
    if (this.isUniform) {
      if (!this.associatedVariableName) {
        this.associatedVariableName = state._getFreeVariableName("u_" + this.name);
      }
      if (this.isConstant) {
        if (state.constants.indexOf(this.associatedVariableName) !== -1) {
          return;
        }
        state.constants.push(this.associatedVariableName);
        state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};
`;
        return;
      }
      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.uniforms.push(this.associatedVariableName);
      if (define) {
        state._uniformDeclaration += this._emitDefine(define);
      }
      state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};
`;
      if (define) {
        state._uniformDeclaration += `#endif
`;
      }
      const hints = state.sharedData.hints;
      if (this._systemValue !== null && this._systemValue !== void 0) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.WorldView:
            hints.needWorldViewMatrix = true;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            hints.needWorldViewProjectionMatrix = true;
            break;
        }
      } else {
        if (this._animationType !== AnimatedInputBlockTypes.None) {
          state.sharedData.animatedInputs.push(this);
        }
      }
      return;
    }
    if (this.isAttribute) {
      this.associatedVariableName = remapAttributeName[this.name] ?? this.name;
      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
        if (attributeInFragmentOnly[this.name]) {
          if (attributeAsUniform[this.name]) {
            state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
          } else {
            state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
          }
        } else {
          this._emit(state._vertexState, define);
        }
        return;
      }
      if (state.attributes.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state.attributes.push(this.associatedVariableName);
      if (attributeInFragmentOnly[this.name]) {
        if (attributeAsUniform[this.name]) {
          state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);
        } else {
          state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);
        }
      } else {
        if (define) {
          state._attributeDeclaration += this._emitDefine(define);
        }
        state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};
`;
        if (define) {
          state._attributeDeclaration += `#endif
`;
        }
      }
    }
  }
  /**
   * @internal
   */
  _transmitWorld(effect, world, worldView, worldViewProjection) {
    if (!this._systemValue) {
      return;
    }
    const variableName = this.associatedVariableName;
    switch (this._systemValue) {
      case NodeMaterialSystemValues.World:
        effect.setMatrix(variableName, world);
        break;
      case NodeMaterialSystemValues.WorldView:
        effect.setMatrix(variableName, worldView);
        break;
      case NodeMaterialSystemValues.WorldViewProjection:
        effect.setMatrix(variableName, worldViewProjection);
        break;
    }
  }
  /**
   * @internal
   */
  _transmit(effect, scene, material) {
    if (this.isAttribute) {
      return;
    }
    const variableName = this.associatedVariableName;
    if (this._systemValue) {
      switch (this._systemValue) {
        case NodeMaterialSystemValues.World:
        case NodeMaterialSystemValues.WorldView:
        case NodeMaterialSystemValues.WorldViewProjection:
          return;
        case NodeMaterialSystemValues.View:
          effect.setMatrix(variableName, scene.getViewMatrix());
          break;
        case NodeMaterialSystemValues.Projection:
          effect.setMatrix(variableName, scene.getProjectionMatrix());
          break;
        case NodeMaterialSystemValues.ViewProjection:
          effect.setMatrix(variableName, scene.getTransformMatrix());
          break;
        case NodeMaterialSystemValues.CameraPosition:
          scene.bindEyePosition(effect, variableName, true);
          break;
        case NodeMaterialSystemValues.FogColor:
          effect.setColor3(variableName, scene.fogColor);
          break;
        case NodeMaterialSystemValues.DeltaTime:
          effect.setFloat(variableName, scene.deltaTime / 1e3);
          break;
        case NodeMaterialSystemValues.CameraParameters:
          if (scene.activeCamera) {
            effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);
          }
          break;
        case NodeMaterialSystemValues.MaterialAlpha:
          effect.setFloat(variableName, material.alpha);
          break;
      }
      return;
    }
    const value = this._valueCallback ? this._valueCallback() : this._storedValue;
    if (value === null) {
      return;
    }
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        effect.setFloat(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Int:
        effect.setInt(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setColor3(variableName, TmpColors.Color3[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setDirectColor4(variableName, TmpColors.Color4[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        effect.setVector2(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        effect.setVector3(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        effect.setVector4(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        effect.setMatrix(variableName, value);
        break;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.isUniform || this.isSystemValue) {
      state.sharedData.inputBlocks.push(this);
    }
    this._emit(state);
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    if (this.isAttribute) {
      return super._dumpPropertiesCode() + `${variableName}.setAsAttribute("${this.name}");
`;
    }
    if (this.isSystemValue) {
      return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});
`;
    }
    if (this.isUniform) {
      const codes = [];
      let valueString = "";
      switch (this.type) {
        case NodeMaterialBlockConnectionPointTypes.Float:
          valueString = `${this.value}`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector2:
          valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector3:
          valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector4:
          valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Color3:
          valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Color4:
          valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Matrix:
          valueString = `BABYLON.Matrix.FromArray([${this.value.m}])`;
          break;
      }
      codes.push(`${variableName}.value = ${valueString}`);
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);
      }
      codes.push(`${variableName}.isConstant = ${this.isConstant}`);
      codes.push("");
      return super._dumpPropertiesCode() + codes.join(";\n");
    }
    return super._dumpPropertiesCode();
  }
  dispose() {
    this.onValueChangedObservable.clear();
    super.dispose();
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.type = this.type;
    serializationObject.mode = this._mode;
    serializationObject.systemValue = this._systemValue;
    serializationObject.animationType = this._animationType;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.isBoolean = this.isBoolean;
    serializationObject.matrixMode = this.matrixMode;
    serializationObject.isConstant = this.isConstant;
    serializationObject.groupInInspector = this.groupInInspector;
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._mode = serializationObject.mode;
    super._deserialize(serializationObject, scene, rootUrl);
    this._type = serializationObject.type;
    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
    this._animationType = serializationObject.animationType;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.isBoolean = !!serializationObject.isBoolean;
    this.matrixMode = serializationObject.matrixMode || 0;
    this.isConstant = !!serializationObject.isConstant;
    this.groupInInspector = serializationObject.groupInInspector || "";
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.name === "tangent" && serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
      this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
    }
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      const valueType = GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  }
};
RegisterClass("BABYLON.InputBlock", InputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock = class extends NodeMaterialBlock {
  /**
   * Create a new CurrentScreenBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.VertexAndFragment);
    this._samplerName = "textureSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CurrentScreenBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("textureSampler");
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, "vec2");
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    state._emitVaryingFromString(this._mainUVName, "vec2");
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});
`;
      return;
    }
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
      state.sharedData.blockingBlocks.push(this);
    }
    if (state.sharedData.textureBlocks.indexOf(this) < 0) {
      state.sharedData.textureBlocks.push(this);
    }
    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
      state.sharedData.blocksWithDefines.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state._emit2DSampler(this._samplerName);
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    state._emit2DSampler(this._samplerName);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.CurrentScreenBlock", CurrentScreenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleTextureBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._samplerName = "diffuseSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleTextureBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("diffuseSampler");
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "particle_uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("particle_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  prepareDefines(mesh, nodeMaterial, defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _writeOutput(state, output, swizzle) {
    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    state._emit2DSampler(this._samplerName);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});
`;
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.ParticleTextureBlock", ParticleTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleRampGradientBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleRampGradientBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the rampColor output component
   */
  get rampColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("remapRanges");
    state._excludeVariableName("rampSampler");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("alpha");
    state._excludeVariableName("remappedColorIndex");
    state._excludeVariableName("rampColor");
    state._excludeVariableName("finalAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state._emit2DSampler("rampSampler");
    state._emitVaryingFromString("remapRanges", "vec4", "RAMPGRADIENT");
    state.compilationString += `
            #ifdef RAMPGRADIENT
                vec4 baseColor = ${this.color.associatedVariableName};
                float alpha = ${this.color.associatedVariableName}.a;

                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);

                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));
                baseColor.rgb *= rampColor.rgb;

                // Remapped alpha
                float finalAlpha = baseColor.a;
                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);

                ${this._declareOutput(this.rampColor, state)} = baseColor;
            #else
                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleRampGradientBlock", ParticleRampGradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleBlendMultiplyBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleBlendMultiplyBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the alphaTexture input component
   */
  get alphaTexture() {
    return this._inputs[1];
  }
  /**
   * Gets the alphaColor input component
   */
  get alphaColor() {
    return this._inputs[2];
  }
  /**
   * Gets the blendColor output component
   */
  get blendColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("sourceAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state.compilationString += `
            #ifdef BLENDMULTIPLYMODE
                ${this._declareOutput(this.blendColor, state)};
                float sourceAlpha = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName}.rgb = ${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha);
                ${this.blendColor.associatedVariableName}.a = ${this.color.associatedVariableName}.a;
            #else
                ${this._declareOutput(this.blendColor, state)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleBlendMultiplyBlock", ParticleBlendMultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock = class extends NodeMaterialBlock {
  /**
   * Create a new VectorMergerBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.xSwizzle = "x";
    this.ySwizzle = "y";
    this.zSwizzle = "z";
    this.wSwizzle = "w";
    this.registerInput("xyzw ", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("zw ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VectorMergerBlock";
  }
  /**
   * Gets the xyzw component (input)
   */
  get xyzwIn() {
    return this._inputs[0];
  }
  /**
   * Gets the xyz component (input)
   */
  get xyzIn() {
    return this._inputs[1];
  }
  /**
   * Gets the xy component (input)
   */
  get xyIn() {
    return this._inputs[2];
  }
  /**
   * Gets the zw component (input)
   */
  get zwIn() {
    return this._inputs[3];
  }
  /**
   * Gets the x component (input)
   */
  get x() {
    return this._inputs[4];
  }
  /**
   * Gets the y component (input)
   */
  get y() {
    return this._inputs[5];
  }
  /**
   * Gets the z component (input)
   */
  get z() {
    return this._inputs[6];
  }
  /**
   * Gets the w component (input)
   */
  get w() {
    return this._inputs[7];
  }
  /**
   * Gets the xyzw component (output)
   */
  get xyzw() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component (output)
   */
  get xyzOut() {
    return this._outputs[1];
  }
  /**
   * Gets the xy component (output)
   */
  get xyOut() {
    return this._outputs[2];
  }
  /**
   * Gets the zw component (output)
   */
  get zwOut() {
    return this._outputs[3];
  }
  /**
   * Gets the xy component (output)
   * @deprecated Please use xyOut instead.
   */
  get xy() {
    return this.xyOut;
  }
  /**
   * Gets the xyz component (output)
   * @deprecated Please use xyzOut instead.
   */
  get xyz() {
    return this.xyzOut;
  }
  _inputRename(name4) {
    if (name4 === "xyzw ") {
      return "xyzwIn";
    }
    if (name4 === "xyz ") {
      return "xyzIn";
    }
    if (name4 === "xy ") {
      return "xyIn";
    }
    if (name4 === "zw ") {
      return "zwIn";
    }
    return name4;
  }
  _buildSwizzle(len) {
    const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;
    return "." + swizzle.substr(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const xInput = this.x;
    const yInput = this.y;
    const zInput = this.z;
    const wInput = this.w;
    const xyInput = this.xyIn;
    const zwInput = this.zwIn;
    const xyzInput = this.xyzIn;
    const xyzwInput = this.xyzwIn;
    const v4Output = this._outputs[0];
    const v3Output = this._outputs[1];
    const v2Output = this._outputs[2];
    const v2CompOutput = this._outputs[3];
    if (xyzwInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyzInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyInput.isConnected) {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = vec3(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    } else {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += this._declareOutput(v4Output, state) + ` = vec4(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v3Output, state) + ` = vec3(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += this._declareOutput(v2Output, state) + ` = vec2(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"})${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += this._declareOutput(v2CompOutput, state) + ` = vec2(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.xSwizzle = this.xSwizzle;
    serializationObject.ySwizzle = this.ySwizzle;
    serializationObject.zSwizzle = this.zSwizzle;
    serializationObject.wSwizzle = this.wSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.xSwizzle = serializationObject.xSwizzle ?? "x";
    this.ySwizzle = serializationObject.ySwizzle ?? "y";
    this.zSwizzle = serializationObject.zSwizzle ?? "z";
    this.wSwizzle = serializationObject.wSwizzle ?? "w";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";
`;
    codeString += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";
`;
    codeString += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";
`;
    codeString += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";
`;
    return codeString;
  }
};
RegisterClass("BABYLON.VectorMergerBlock", VectorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new RemapBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.sourceRange = new Vector2(-1, 1);
    this.targetRange = new Vector2(0, 1);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RemapBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the source min input component
   */
  get sourceMin() {
    return this._inputs[1];
  }
  /**
   * Gets the source max input component
   */
  get sourceMax() {
    return this._inputs[2];
  }
  /**
   * Gets the target min input component
   */
  get targetMin() {
    return this._inputs[3];
  }
  /**
   * Gets the target max input component
   */
  get targetMax() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
    const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
    const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
    const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
    state.compilationString += this._declareOutput(output, state) + ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});
`;
    codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.sourceRange = this.sourceRange.asArray();
    serializationObject.targetRange = this.targetRange.asArray();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
    this.targetRange = Vector2.FromArray(serializationObject.targetRange);
  }
};
__decorate([
  editableInPropertyPage("From", PropertyTypeForEdition.Vector2)
], RemapBlock.prototype, "sourceRange", void 0);
__decorate([
  editableInPropertyPage("To", PropertyTypeForEdition.Vector2)
], RemapBlock.prototype, "targetRange", void 0);
RegisterClass("BABYLON.RemapBlock", RemapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MultiplyBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1, true);
    this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MultiplyBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += this._declareOutput(output, state) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.MultiplyBlock", MultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
(function(NodeMaterialModes2) {
  NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
  NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
  NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
  NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
})(NodeMaterialModes || (NodeMaterialModes = {}));

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.defines.js
var ImageProcessingConfigurationDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.EXPOSURE = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.rebuild();
  }
};

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = class _BaseParticleSystem {
  /**
   * Gets or sets a texture used to add random noise to particle positions
   */
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this._noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    this._reset();
  }
  /**
   * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
   */
  get isAnimationSheetEnabled() {
    return this._isAnimationSheetEnabled;
  }
  set isAnimationSheetEnabled(value) {
    if (this._isAnimationSheetEnabled == value) {
      return;
    }
    this._isAnimationSheetEnabled = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.
   */
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
  }
  /**
   * Get hosting scene
   * @returns the scene
   */
  getScene() {
    return this._scene;
  }
  _hasTargetStopDurationDependantGradient() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  }
  /**
   * Gets the current list of drag gradients.
   * You must use addDragGradient and removeDragGradient to update this list
   * @returns the list of drag gradients
   */
  getDragGradients() {
    return this._dragGradients;
  }
  /**
   * Gets the current list of limit velocity gradients.
   * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list
   * @returns the list of limit velocity gradients
   */
  getLimitVelocityGradients() {
    return this._limitVelocityGradients;
  }
  /**
   * Gets the current list of color gradients.
   * You must use addColorGradient and removeColorGradient to update this list
   * @returns the list of color gradients
   */
  getColorGradients() {
    return this._colorGradients;
  }
  /**
   * Gets the current list of size gradients.
   * You must use addSizeGradient and removeSizeGradient to update this list
   * @returns the list of size gradients
   */
  getSizeGradients() {
    return this._sizeGradients;
  }
  /**
   * Gets the current list of color remap gradients.
   * You must use addColorRemapGradient and removeColorRemapGradient to update this list
   * @returns the list of color remap gradients
   */
  getColorRemapGradients() {
    return this._colorRemapGradients;
  }
  /**
   * Gets the current list of alpha remap gradients.
   * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list
   * @returns the list of alpha remap gradients
   */
  getAlphaRemapGradients() {
    return this._alphaRemapGradients;
  }
  /**
   * Gets the current list of life time gradients.
   * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list
   * @returns the list of life time gradients
   */
  getLifeTimeGradients() {
    return this._lifeTimeGradients;
  }
  /**
   * Gets the current list of angular speed gradients.
   * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list
   * @returns the list of angular speed gradients
   */
  getAngularSpeedGradients() {
    return this._angularSpeedGradients;
  }
  /**
   * Gets the current list of velocity gradients.
   * You must use addVelocityGradient and removeVelocityGradient to update this list
   * @returns the list of velocity gradients
   */
  getVelocityGradients() {
    return this._velocityGradients;
  }
  /**
   * Gets the current list of start size gradients.
   * You must use addStartSizeGradient and removeStartSizeGradient to update this list
   * @returns the list of start size gradients
   */
  getStartSizeGradients() {
    return this._startSizeGradients;
  }
  /**
   * Gets the current list of emit rate gradients.
   * You must use addEmitRateGradient and removeEmitRateGradient to update this list
   * @returns the list of emit rate gradients
   */
  getEmitRateGradients() {
    return this._emitRateGradients;
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction1() {
    if (this.particleEmitterType.direction1) {
      return this.particleEmitterType.direction1;
    }
    return Vector3.Zero();
  }
  set direction1(value) {
    if (this.particleEmitterType.direction1) {
      this.particleEmitterType.direction1 = value;
    }
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction2() {
    if (this.particleEmitterType.direction2) {
      return this.particleEmitterType.direction2;
    }
    return Vector3.Zero();
  }
  set direction2(value) {
    if (this.particleEmitterType.direction2) {
      this.particleEmitterType.direction2 = value;
    }
  }
  /**
   * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get minEmitBox() {
    if (this.particleEmitterType.minEmitBox) {
      return this.particleEmitterType.minEmitBox;
    }
    return Vector3.Zero();
  }
  set minEmitBox(value) {
    if (this.particleEmitterType.minEmitBox) {
      this.particleEmitterType.minEmitBox = value;
    }
  }
  /**
   * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get maxEmitBox() {
    if (this.particleEmitterType.maxEmitBox) {
      return this.particleEmitterType.maxEmitBox;
    }
    return Vector3.Zero();
  }
  set maxEmitBox(value) {
    if (this.particleEmitterType.maxEmitBox) {
      this.particleEmitterType.maxEmitBox = value;
    }
  }
  /**
   * Gets or sets the billboard mode to use when isBillboardBased = true.
   * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
   */
  get isBillboardBased() {
    return this._isBillboardBased;
  }
  set isBillboardBased(value) {
    if (this._isBillboardBased === value) {
      return;
    }
    this._isBillboardBased = value;
    this._reset();
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  }
  /** @internal */
  _reset() {
  }
  /**
   * @internal
   */
  _removeGradientAndTexture(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    let index = 0;
    for (const valueGradient of gradients) {
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  }
  /**
   * Instantiates a particle system.
   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
   * @param name The name of the particle system
   */
  constructor(name4) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this.targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this.applyFog = false;
    this._wasDispatched = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = _BaseParticleSystem.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this._useLogarithmicDepth = false;
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name4;
    this.name = name4;
  }
  /**
   * Creates a Point Emitter for the particle system (emits directly from the emitter position)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   */
  createPointEmitter(direction1, direction2) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
   * @param radius The radius of the hemisphere to emit from
   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
   * @param radius The radius of the sphere to emit from
   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createSphereEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the sphere to emit from
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
   */
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
   * @param radius The radius of the emission cylinder
   * @param height The height of the emission cylinder
   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
   * @param directionRandomizer How much to randomize the particle direction [0-1]
   */
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the cylinder to emit from
   * @param height The height of the emission cylinder
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
   */
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
   * @param radius The radius of the cone to emit from
   * @param angle The base angle of the cone
   */
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
   */
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    throw new Error("Method not implemented.");
  }
};
BaseParticleSystem.BLENDMODE_ONEONE = 0;
BaseParticleSystem.BLENDMODE_STANDARD = 1;
BaseParticleSystem.BLENDMODE_ADD = 2;
BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ColorSplitterBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ColorSplitterBlock";
  }
  /**
   * Gets the rgba component (input)
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb component (input)
   */
  get rgbIn() {
    return this._inputs[1];
  }
  /**
   * Gets the rgb component (output)
   */
  get rgbOut() {
    return this._outputs[0];
  }
  /**
   * Gets the r component (output)
   */
  get r() {
    return this._outputs[1];
  }
  /**
   * Gets the g component (output)
   */
  get g() {
    return this._outputs[2];
  }
  /**
   * Gets the b component (output)
   */
  get b() {
    return this._outputs[3];
  }
  /**
   * Gets the a component (output)
   */
  get a() {
    return this._outputs[4];
  }
  _inputRename(name4) {
    if (name4 === "rgb ") {
      return "rgbIn";
    }
    return name4;
  }
  _outputRename(name4) {
    if (name4 === "rgb") {
      return "rgbOut";
    }
    return name4;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.rgba.isConnected ? this.rgba : this.rgbIn;
    if (!input.isConnected) {
      return;
    }
    const rgbOutput = this._outputs[0];
    const rOutput = this._outputs[1];
    const gOutput = this._outputs[2];
    const bOutput = this._outputs[3];
    const aOutput = this._outputs[4];
    if (rgbOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rgbOutput, state) + ` = ${input.associatedVariableName}.rgb;
`;
    }
    if (rOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(rOutput, state) + ` = ${input.associatedVariableName}.r;
`;
    }
    if (gOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(gOutput, state) + ` = ${input.associatedVariableName}.g;
`;
    }
    if (bOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(bOutput, state) + ` = ${input.associatedVariableName}.b;
`;
    }
    if (aOutput.hasEndpoints) {
      state.compilationString += this._declareOutput(aOutput, state) + ` = ${input.associatedVariableName}.a;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ColorSplitterBlock", ColorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
    this.scene.proceduralTextures = [];
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
  }
  _beforeClear() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  }
};

// node_modules/@babylonjs/core/Shaders/procedural.vertex.js
var name = "proceduralVertexShader";
var shader = `attribute vec2 position;varying vec2 vPosition;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vPosition=position;vUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = class _ProceduralTexture extends Texture {
  /**
   * Instantiates a new procedural texture.
   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
   * This is the base class of any Procedural texture and contains most of the shareable code.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures
   * @param name  Define the name of the texture
   * @param size Define the size of the texture to create
   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:
   *  * object: \{ fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ fragmentSource: "fragment shader code string" \}, the string contains the shader code
   *  * string: the string contains a name "XXX" to lookup in Effect.ShadersStore["XXXFragmentShader"]
   * @param scene Define the scene the texture belongs to
   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
   * @param generateMipMaps Define if the texture should creates mip maps or not
   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
   * @param textureType The FBO internal texture type
   */
  constructor(name4, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
    super(null, scene, !generateMipMaps);
    this.isEnabled = true;
    this.autoClear = true;
    this.onGeneratedObservable = new Observable();
    this.onBeforeGenerationObservable = new Observable();
    this.nodeMaterialSource = null;
    this._textures = {};
    this._currentRefreshId = -1;
    this._frameId = -1;
    this._refreshRate = 1;
    this._vertexBuffers = {};
    this._uniforms = new Array();
    this._samplers = new Array();
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors4 = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._matrices = {};
    this._fallbackTextureUsed = false;
    this._cachedDefines = null;
    this._contentUpdateId = -1;
    this._rtWrapper = null;
    if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {
      this._options = fallbackTexture;
      this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;
    } else {
      this._options = {};
      this._fallbackTexture = fallbackTexture;
    }
    scene = this.getScene() || EngineStore.LastCreatedScene;
    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(this);
    this._fullEngine = scene.getEngine();
    this.name = name4;
    this.isRenderTarget = true;
    this._size = size;
    this._textureType = textureType;
    this._generateMipMaps = generateMipMaps;
    this._drawWrapper = new DrawWrapper(this._fullEngine);
    this.setFragment(fragment);
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
    this._texture = rtWrapper.texture;
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  _createRtWrapper(isCube, size, generateMipMaps, textureType) {
    if (isCube) {
      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      this.setFloat("face", 0);
    } else {
      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
    }
    return this._rtWrapper;
  }
  /**
   * The effect that is created when initializing the post process.
   * @returns The created effect corresponding the postprocess.
   */
  getEffect() {
    return this._drawWrapper.effect;
  }
  /**
   * @internal
   */
  _setEffect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Gets texture content (Use this function wisely as reading from a texture can be slow)
   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)
   */
  getContent() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    if (this._contentData) {
      this._contentData.then((buffer) => {
        this._contentData = this.readPixels(0, 0, buffer);
        this._contentUpdateId = this._frameId;
      });
    } else {
      this._contentData = this.readPixels(0, 0);
      this._contentUpdateId = this._frameId;
    }
    return this._contentData;
  }
  _createIndexBuffer() {
    const engine = this._fullEngine;
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  }
  /**
   * Resets the texture in order to recreate its associated resources.
   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code
   */
  reset() {
    var _a;
    (_a = this._drawWrapper.effect) == null ? void 0 : _a.dispose();
    this._drawWrapper.effect = null;
    this._cachedDefines = null;
  }
  _getDefines() {
    return "";
  }
  /**
   * Executes a function when the texture will be ready to be drawn.
   * @param func The callback to be used.
   */
  executeWhenReady(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    const effect = this.getEffect();
    if (effect) {
      effect.executeWhenCompiled(() => {
        func(this);
      });
    }
  }
  /**
   * Is the texture ready to be used ? (rendered at least once)
   * @returns true if ready, otherwise, false.
   */
  isReady() {
    const engine = this._fullEngine;
    if (this.nodeMaterialSource) {
      return this._drawWrapper.effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    if (!this._texture) {
      return false;
    }
    const defines = this._getDefines();
    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
      return true;
    }
    const shaders = {
      vertex: "procedural",
      fragmentElement: this._fragment.fragmentElement,
      fragmentSource: this._fragment.fragmentSource,
      fragment: typeof this._fragment === "string" ? this._fragment : void 0
    };
    if (this._cachedDefines !== defines) {
      this._cachedDefines = defines;
      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
        var _a;
        (_a = this._rtWrapper) == null ? void 0 : _a.dispose();
        this._rtWrapper = this._texture = null;
        if (this._fallbackTexture) {
          this._texture = this._fallbackTexture._texture;
          if (this._texture) {
            this._texture.incrementReferences();
          }
        }
        this._fallbackTextureUsed = true;
      });
    }
    return this._drawWrapper.effect.isReady();
  }
  /**
   * Resets the refresh counter of the texture and start bak from scratch.
   * Could be useful to regenerate the texture if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  /**
   * Set the fragment shader to use in order to render the texture.
   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
   */
  setFragment(fragment) {
    this._fragment = fragment;
  }
  /**
   * Define the refresh rate of the texture or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  /** @internal */
  _shouldRender() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  /**
   * Get the size the texture is rendering at.
   * @returns the size (on cube texture it is always squared)
   */
  getRenderSize() {
    return this._size;
  }
  /**
   * Resize the texture to new value.
   * @param size Define the new size the texture should have
   * @param generateMipMaps Define whether the new texture should create mip maps
   */
  resize(size, generateMipMaps) {
    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
      return;
    }
    const isCube = this._texture.isCube;
    this._rtWrapper.dispose();
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
    this._texture = rtWrapper.texture;
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  }
  _checkUniform(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader program used to render.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setTexture(name4, texture) {
    if (this._samplers.indexOf(name4) === -1) {
      this._samplers.push(name4);
    }
    this._textures[name4] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloat(name4, value) {
    this._checkUniform(name4);
    this._floats[name4] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setInt(name4, value) {
    this._checkUniform(name4);
    this._ints[name4] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloats(name4, value) {
    this._checkUniform(name4);
    this._floatsArrays[name4] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor3(name4, value) {
    this._checkUniform(name4);
    this._colors3[name4] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor4(name4, value) {
    this._checkUniform(name4);
    this._colors4[name4] = value;
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector2(name4, value) {
    this._checkUniform(name4);
    this._vectors2[name4] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector3(name4, value) {
    this._checkUniform(name4);
    this._vectors3[name4] = value;
    return this;
  }
  /**
   * Set a mat4 in the shader from a MAtrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setMatrix(name4, value) {
    this._checkUniform(name4);
    this._matrices[name4] = value;
    return this;
  }
  /**
   * Render the texture to its associated render target.
   * @param useCameraPostProcess Define if camera post process should be applied to the texture
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(useCameraPostProcess) {
    var _a, _b;
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this._fullEngine;
    engine.enableEffect(this._drawWrapper);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (const name4 in this._textures) {
        this._drawWrapper.effect.setTexture(name4, this._textures[name4]);
      }
      for (const name4 in this._ints) {
        this._drawWrapper.effect.setInt(name4, this._ints[name4]);
      }
      for (const name4 in this._floats) {
        this._drawWrapper.effect.setFloat(name4, this._floats[name4]);
      }
      for (const name4 in this._floatsArrays) {
        this._drawWrapper.effect.setArray(name4, this._floatsArrays[name4]);
      }
      for (const name4 in this._colors3) {
        this._drawWrapper.effect.setColor3(name4, this._colors3[name4]);
      }
      for (const name4 in this._colors4) {
        const color = this._colors4[name4];
        this._drawWrapper.effect.setFloat4(name4, color.r, color.g, color.b, color.a);
      }
      for (const name4 in this._vectors2) {
        this._drawWrapper.effect.setVector2(name4, this._vectors2[name4]);
      }
      for (const name4 in this._vectors3) {
        this._drawWrapper.effect.setVector3(name4, this._vectors3[name4]);
      }
      for (const name4 in this._matrices) {
        this._drawWrapper.effect.setMatrix(name4, this._matrices[name4]);
      }
    }
    if (!this._texture || !this._rtWrapper) {
      return;
    }
    (_a = engine._debugPushGroup) == null ? void 0 : _a.call(engine, `procedural texture generation for ${this.name}`, 1);
    const viewPort = engine.currentViewport;
    if (this.isCube) {
      for (let face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        this._drawWrapper.effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      }
    } else {
      engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true);
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
      if (this.autoClear) {
        engine.clear(scene.clearColor, true, false, false);
      }
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    engine.unBindFramebuffer(this._rtWrapper, this.isCube);
    if (viewPort) {
      engine.setViewport(viewPort);
    }
    if (this.isCube) {
      engine.generateMipMapsForCubemap(this._texture);
    }
    (_b = engine._debugPopGroup) == null ? void 0 : _b.call(engine, 1);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  }
  /**
   * Clone the texture.
   * @returns the cloned texture
   */
  clone() {
    const textureSize = this.getSize();
    const newTexture = new _ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    super.dispose();
  }
};
__decorate([
  serialize()
], ProceduralTexture.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "autoClear", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_generateMipMaps", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_size", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "refreshRate", null);
RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations;
(function(TrigonometryBlockOperations2) {
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
})(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
var TrigonometryBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new TrigonometryBlock
   * @param name defines the block name
   */
  constructor(name4) {
    super(name4, NodeMaterialBlockTargets.Neutral);
    this.operation = TrigonometryBlockOperations.Cos;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TrigonometryBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    let operation = "";
    switch (this.operation) {
      case TrigonometryBlockOperations.Cos: {
        operation = "cos";
        break;
      }
      case TrigonometryBlockOperations.Sin: {
        operation = "sin";
        break;
      }
      case TrigonometryBlockOperations.Abs: {
        operation = "abs";
        break;
      }
      case TrigonometryBlockOperations.Exp: {
        operation = "exp";
        break;
      }
      case TrigonometryBlockOperations.Exp2: {
        operation = "exp2";
        break;
      }
      case TrigonometryBlockOperations.Round: {
        operation = "round";
        break;
      }
      case TrigonometryBlockOperations.Floor: {
        operation = "floor";
        break;
      }
      case TrigonometryBlockOperations.Ceiling: {
        operation = "ceil";
        break;
      }
      case TrigonometryBlockOperations.Sqrt: {
        operation = "sqrt";
        break;
      }
      case TrigonometryBlockOperations.Log: {
        operation = "log";
        break;
      }
      case TrigonometryBlockOperations.Tan: {
        operation = "tan";
        break;
      }
      case TrigonometryBlockOperations.ArcTan: {
        operation = "atan";
        break;
      }
      case TrigonometryBlockOperations.ArcCos: {
        operation = "acos";
        break;
      }
      case TrigonometryBlockOperations.ArcSin: {
        operation = "asin";
        break;
      }
      case TrigonometryBlockOperations.Fract: {
        operation = "fract";
        break;
      }
      case TrigonometryBlockOperations.Sign: {
        operation = "sign";
        break;
      }
      case TrigonometryBlockOperations.Radians: {
        operation = "radians";
        break;
      }
      case TrigonometryBlockOperations.Degrees: {
        operation = "degrees";
        break;
      }
    }
    state.compilationString += this._declareOutput(output, state) + ` = ${operation}(${this.input.associatedVariableName});
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.operation = serializationObject.operation;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};
`;
    return codeString;
  }
};
RegisterClass("BABYLON.TrigonometryBlock", TrigonometryBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState = class {
  constructor() {
    this.supportUniformBuffers = false;
    this.attributes = [];
    this.uniforms = [];
    this.constants = [];
    this.samplers = [];
    this.functions = {};
    this.extensions = {};
    this.prePassOutput = {};
    this.counters = {};
    this._attributeDeclaration = "";
    this._uniformDeclaration = "";
    this._constantDeclaration = "";
    this._samplerDeclaration = "";
    this._varyingTransfer = "";
    this._injectAtEnd = "";
    this._repeatableContentAnchorIndex = 0;
    this._builtCompilationString = "";
    this.compilationString = "";
  }
  /**
   * Finalize the compilation strings
   * @param state defines the current compilation state
   */
  finalize(state) {
    const emitComments = state.sharedData.emitComments;
    const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
    this.compilationString = `
${emitComments ? "//Entry point\n" : ""}void main(void) {
${this.compilationString}`;
    if (this._constantDeclaration) {
      this.compilationString = `
${emitComments ? "//Constants\n" : ""}${this._constantDeclaration}
${this.compilationString}`;
    }
    let functionCode = "";
    for (const functionName in this.functions) {
      functionCode += this.functions[functionName] + `
`;
    }
    this.compilationString = `
${functionCode}
${this.compilationString}`;
    if (!isFragmentMode && this._varyingTransfer) {
      this.compilationString = `${this.compilationString}
${this._varyingTransfer}`;
    }
    if (this._injectAtEnd) {
      this.compilationString = `${this.compilationString}
${this._injectAtEnd}`;
    }
    this.compilationString = `${this.compilationString}
}`;
    if (this.sharedData.varyingDeclaration) {
      this.compilationString = `
${emitComments ? "//Varyings\n" : ""}${this.sharedData.varyingDeclaration}
${this.compilationString}`;
    }
    if (this._samplerDeclaration) {
      this.compilationString = `
${emitComments ? "//Samplers\n" : ""}${this._samplerDeclaration}
${this.compilationString}`;
    }
    if (this._uniformDeclaration) {
      this.compilationString = `
${emitComments ? "//Uniforms\n" : ""}${this._uniformDeclaration}
${this.compilationString}`;
    }
    if (this._attributeDeclaration && !isFragmentMode) {
      this.compilationString = `
${emitComments ? "//Attributes\n" : ""}${this._attributeDeclaration}
${this.compilationString}`;
    }
    this.compilationString = "precision highp float;\n" + this.compilationString;
    this.compilationString = "#if defined(WEBGL2) || defines(WEBGPU)\nprecision highp sampler2DArray;\n#endif\n" + this.compilationString;
    if (isFragmentMode) {
      this.compilationString = "#if defined(PREPASS)\r\n#extension GL_EXT_draw_buffers : require\r\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r\nhighp vec4 gl_FragColor;\r\n#endif\r\n" + this.compilationString;
    }
    for (const extensionName in this.extensions) {
      const extension = this.extensions[extensionName];
      this.compilationString = `
${extension}
${this.compilationString}`;
    }
    this._builtCompilationString = this.compilationString;
  }
  /** @internal */
  get _repeatableContentAnchor() {
    return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;
  }
  /**
   * @internal
   */
  _getFreeVariableName(prefix) {
    prefix = prefix.replace(/[^a-zA-Z_]+/g, "");
    if (this.sharedData.variableNames[prefix] === void 0) {
      this.sharedData.variableNames[prefix] = 0;
      if (prefix === "output" || prefix === "texture") {
        return prefix + this.sharedData.variableNames[prefix];
      }
      return prefix;
    } else {
      this.sharedData.variableNames[prefix]++;
    }
    return prefix + this.sharedData.variableNames[prefix];
  }
  /**
   * @internal
   */
  _getFreeDefineName(prefix) {
    if (this.sharedData.defineNames[prefix] === void 0) {
      this.sharedData.defineNames[prefix] = 0;
    } else {
      this.sharedData.defineNames[prefix]++;
    }
    return prefix + this.sharedData.defineNames[prefix];
  }
  /**
   * @internal
   */
  _excludeVariableName(name4) {
    this.sharedData.variableNames[name4] = 0;
  }
  /**
   * @internal
   */
  _emit2DSampler(name4) {
    if (this.samplers.indexOf(name4) < 0) {
      this._samplerDeclaration += `uniform sampler2D ${name4};
`;
      this.samplers.push(name4);
    }
  }
  /**
   * @internal
   */
  _emit2DArraySampler(name4) {
    if (this.samplers.indexOf(name4) < 0) {
      this._samplerDeclaration += `uniform sampler2DArray ${name4};
`;
      this.samplers.push(name4);
    }
  }
  /**
   * @internal
   */
  _getGLType(type) {
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return "mat4";
    }
    return "";
  }
  /**
   * @internal
   */
  _emitExtension(name4, extension, define = "") {
    if (this.extensions[name4]) {
      return;
    }
    if (define) {
      extension = `#if ${define}
${extension}
#endif`;
    }
    this.extensions[name4] = extension;
  }
  /**
   * @internal
   */
  _emitFunction(name4, code, comments) {
    if (this.functions[name4]) {
      return;
    }
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    this.functions[name4] = code;
  }
  /**
   * @internal
   */
  _emitCodeFromInclude(includeName, comments, options) {
    if (options && options.repeatKey) {
      return `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
    }
    let code = Effect.IncludesShadersStore[includeName] + "\n";
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    if (!options) {
      return code;
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        code = code.replace(replaceString.search, replaceString.replace);
      }
    }
    return code;
  }
  /**
   * @internal
   */
  _emitFunctionFromInclude(includeName, comments, options, storeKey = "") {
    const key = includeName + storeKey;
    if (this.functions[key]) {
      return;
    }
    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
      if (options && options.repeatKey) {
        this.functions[key] = `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
      } else {
        this.functions[key] = `#include<${includeName}>${(options == null ? void 0 : options.substitutionVars) ? "(" + (options == null ? void 0 : options.substitutionVars) + ")" : ""}
`;
      }
      if (this.sharedData.emitComments) {
        this.functions[key] = comments + `
` + this.functions[key];
      }
      return;
    }
    this.functions[key] = Effect.IncludesShadersStore[includeName];
    if (this.sharedData.emitComments) {
      this.functions[key] = comments + `
` + this.functions[key];
    }
    if (options.removeIfDef) {
      this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
    }
    if (options.removeAttributes) {
      this.functions[key] = this.functions[key].replace(/\s*?attribute .+?;/g, "\n");
    }
    if (options.removeUniforms) {
      this.functions[key] = this.functions[key].replace(/\s*?uniform .*?;/g, "\n");
    }
    if (options.removeVaryings) {
      this.functions[key] = this.functions[key].replace(/\s*?(varying|in) .+?;/g, "\n");
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
      }
    }
  }
  /**
   * @internal
   */
  _registerTempVariable(name4) {
    if (this.sharedData.temps.indexOf(name4) !== -1) {
      return false;
    }
    this.sharedData.temps.push(name4);
    return true;
  }
  /**
   * @internal
   */
  _emitVaryingFromString(name4, type, define = "", notDefine = false) {
    if (this.sharedData.varyings.indexOf(name4) !== -1) {
      return false;
    }
    this.sharedData.varyings.push(name4);
    if (define) {
      if (define.startsWith("defined(")) {
        this.sharedData.varyingDeclaration += `#if ${define}
`;
      } else {
        this.sharedData.varyingDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
    }
    this.sharedData.varyingDeclaration += `varying ${type} ${name4};
`;
    if (define) {
      this.sharedData.varyingDeclaration += `#endif
`;
    }
    return true;
  }
  /**
   * @internal
   */
  _emitUniformFromString(name4, type, define = "", notDefine = false) {
    if (this.uniforms.indexOf(name4) !== -1) {
      return;
    }
    this.uniforms.push(name4);
    if (define) {
      if (define.startsWith("defined(")) {
        this._uniformDeclaration += `#if ${define}
`;
      } else {
        this._uniformDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
    }
    this._uniformDeclaration += `uniform ${type} ${name4};
`;
    if (define) {
      this._uniformDeclaration += `#endif
`;
    }
  }
  /**
   * @internal
   */
  _emitFloat(value) {
    if (value.toString() === value.toFixed(0)) {
      return `${value}.0`;
    }
    return value.toString();
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData = class {
  /** Creates a new shared data */
  constructor() {
    this.temps = [];
    this.varyings = [];
    this.varyingDeclaration = "";
    this.inputBlocks = [];
    this.textureBlocks = [];
    this.bindableBlocks = [];
    this.forcedBindableBlocks = [];
    this.blocksWithFallbacks = [];
    this.blocksWithDefines = [];
    this.repeatableContentBlocks = [];
    this.dynamicUniformBlocks = [];
    this.blockingBlocks = [];
    this.animatedInputs = [];
    this.variableNames = {};
    this.defineNames = {};
    this.hints = {
      needWorldViewMatrix: false,
      needWorldViewProjectionMatrix: false,
      needAlphaBlending: false,
      needAlphaTesting: false
    };
    this.checks = {
      emitVertex: false,
      emitFragment: false,
      notConnectedNonOptionalInputs: new Array()
    };
    this.allowEmptyVertexProgram = false;
    this.variableNames["position"] = 0;
    this.variableNames["normal"] = 0;
    this.variableNames["tangent"] = 0;
    this.variableNames["uv"] = 0;
    this.variableNames["uv2"] = 0;
    this.variableNames["uv3"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv5"] = 0;
    this.variableNames["uv6"] = 0;
    this.variableNames["color"] = 0;
    this.variableNames["matricesIndices"] = 0;
    this.variableNames["matricesWeights"] = 0;
    this.variableNames["matricesIndicesExtra"] = 0;
    this.variableNames["matricesWeightsExtra"] = 0;
    this.variableNames["diffuseBase"] = 0;
    this.variableNames["specularBase"] = 0;
    this.variableNames["worldPos"] = 0;
    this.variableNames["shadow"] = 0;
    this.variableNames["view"] = 0;
    this.variableNames["vTBN"] = 0;
    this.defineNames["MAINUV0"] = 0;
    this.defineNames["MAINUV1"] = 0;
    this.defineNames["MAINUV2"] = 0;
    this.defineNames["MAINUV3"] = 0;
    this.defineNames["MAINUV4"] = 0;
    this.defineNames["MAINUV5"] = 0;
    this.defineNames["MAINUV6"] = 0;
    this.defineNames["MAINUV7"] = 0;
  }
  /**
   * Emits console errors and exceptions if there is a failing check
   */
  emitErrors() {
    let errorMessage = "";
    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
      errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\n";
    }
    if (!this.checks.emitFragment) {
      errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\n";
    }
    for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {
      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
    }
    if (errorMessage) {
      throw "Build of NodeMaterial failed:\n" + errorMessage;
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var NodeMaterialDefines = class extends MaterialDefines {
  /**
   * Creates a new NodeMaterialDefines
   */
  constructor() {
    super();
    this.NORMAL = false;
    this.TANGENT = false;
    this.VERTEXCOLOR_NME = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.PREPASS = false;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.EXPOSURE = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.BUMPDIRECTUV = 0;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.rebuild();
  }
  /**
   * Set the value of a specific key
   * @param name defines the name of the key to set
   * @param value defines the value to set
   * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing
   */
  setValue(name4, value, markAsUnprocessedIfDirty = false) {
    if (this[name4] === void 0) {
      this._keys.push(name4);
    }
    if (markAsUnprocessedIfDirty && this[name4] !== value) {
      this.markAsUnprocessed();
    }
    this[name4] = value;
  }
};
var NodeMaterial = class _NodeMaterial extends PushMaterial {
  /**
   * Checks if a block is a texture block
   * @param block The block to check
   * @returns True if the block is a texture block
   */
  static _BlockIsTextureBlock(block) {
    return block.getClassName() === "TextureBlock" || block.getClassName() === "ReflectionTextureBaseBlock" || block.getClassName() === "ReflectionTextureBlock" || block.getClassName() === "ReflectionBlock" || block.getClassName() === "RefractionBlock" || block.getClassName() === "CurrentScreenBlock" || block.getClassName() === "ParticleTextureBlock" || block.getClassName() === "ImageSourceBlock" || block.getClassName() === "TriPlanarBlock" || block.getClassName() === "BiPlanarBlock" || block.getClassName() === "PrePassTextureBlock";
  }
  /** Get the inspector from bundle or global
   * @returns the global NME
   */
  _getGlobalNodeMaterialEditor() {
    if (typeof NODEEDITOR !== "undefined") {
      return NODEEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  /** Gets or sets options to control the node material overall behavior */
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets or sets the mode property
   */
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
  }
  /** Gets or sets the unique identifier used to identified the effect associated with the material */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Create a new node based material
   * @param name defines the material name
   * @param scene defines the hosting scene
   * @param options defines creation option
   */
  constructor(name4, scene, options = {}) {
    super(name4, scene || EngineStore.LastCreatedScene);
    this._buildId = _NodeMaterial._BuildIdGenerator++;
    this._buildWasSuccessful = false;
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._optimizers = new Array();
    this._animationFrame = -1;
    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();
    this.editorData = null;
    this.ignoreAlpha = false;
    this.maxSimultaneousLights = 4;
    this.onBuildObservable = new Observable();
    this._vertexOutputNodes = new Array();
    this._fragmentOutputNodes = new Array();
    this.attachedBlocks = [];
    this._mode = NodeMaterialModes.Material;
    this.forceAlphaBlending = false;
    this._options = {
      emitComments: false,
      ...options
    };
    this._attachImageProcessingConfiguration(null);
  }
  /**
   * Gets the current class name of the material e.g. "NodeMaterial"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterial";
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  /**
   * Get a block by its name
   * @param name defines the name of the block to retrieve
   * @returns the required block or null if not found
   */
  getBlockByName(name4) {
    let result = null;
    for (const block of this.attachedBlocks) {
      if (block.name === name4) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name4 + "`");
          return result;
        }
      }
    }
    return result;
  }
  /**
   * Get a block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required block or null if not found
   */
  getBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Get an input block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required input block or null if not found
   */
  getInputBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (block.isInput && predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Gets the list of input blocks attached to this material
   * @returns an array of InputBlocks
   */
  getInputBlocks() {
    const blocks = [];
    for (const block of this.attachedBlocks) {
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  }
  /**
   * Adds a new optimizer to the list of optimizers
   * @param optimizer defines the optimizers to add
   * @returns the current material
   */
  registerOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index > -1) {
      return;
    }
    this._optimizers.push(optimizer);
    return this;
  }
  /**
   * Remove an optimizer from the list of optimizers
   * @param optimizer defines the optimizers to remove
   * @returns the current material
   */
  unregisterOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index === -1) {
      return;
    }
    this._optimizers.splice(index, 1);
    return this;
  }
  /**
   * Add a new block to the list of output nodes
   * @param node defines the node to add
   * @returns the current material
   */
  addOutputNode(node) {
    if (node.target === null) {
      throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._addVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._addFragmentOutputNode(node);
    }
    return this;
  }
  /**
   * Remove a block from the list of root nodes
   * @param node defines the node to remove
   * @returns the current material
   */
  removeOutputNode(node) {
    if (node.target === null) {
      return this;
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._removeVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._removeFragmentOutputNode(node);
    }
    return this;
  }
  _addVertexOutputNode(node) {
    if (this._vertexOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Vertex;
    this._vertexOutputNodes.push(node);
    return this;
  }
  _removeVertexOutputNode(node) {
    const index = this._vertexOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._vertexOutputNodes.splice(index, 1);
    return this;
  }
  _addFragmentOutputNode(node) {
    if (this._fragmentOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Fragment;
    this._fragmentOutputNodes.push(node);
    return this;
  }
  _removeFragmentOutputNode(node) {
    const index = this._fragmentOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._fragmentOutputNodes.splice(index, 1);
    return this;
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    if (this.ignoreAlpha) {
      return false;
    }
    return this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._sharedData && this._sharedData.hints.needAlphaTesting;
  }
  _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
      nodesToProcessForOtherBuildState.push(block);
    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
      nodesToProcessForOtherBuildState.push(block);
    }
    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);
  }
  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    node.initialize(state);
    if (autoConfigure) {
      node.autoConfigure(this);
    }
    node._preparationId = this._buildId;
    if (this.attachedBlocks.indexOf(node) === -1) {
      if (node.isUnique) {
        const className = node.getClassName();
        for (const other of this.attachedBlocks) {
          if (other.getClassName() === className) {
            throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;
          }
        }
      }
      this.attachedBlocks.push(node);
    }
    for (const input of node.inputs) {
      input.associatedVariableName = "";
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    }
    if (node.isTeleportOut) {
      const teleport = node;
      if (teleport.entryPoint) {
        this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);
      }
    }
    for (const output of node.outputs) {
      output.associatedVariableName = "";
    }
  }
  _resetDualBlocks(node, id) {
    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
      node.buildId = id;
    }
    for (const inputs of node.inputs) {
      const connectedPoint = inputs.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._resetDualBlocks(block, id);
        }
      }
    }
    if (node.isTeleportOut) {
      const teleportOut = node;
      if (teleportOut.entryPoint) {
        this._resetDualBlocks(teleportOut.entryPoint, id);
      }
    }
  }
  /**
   * Remove a block from the current node material
   * @param block defines the block to remove
   */
  removeBlock(block) {
    const attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block.isFinalMerger) {
      this.removeOutputNode(block);
    }
  }
  /**
   * Build the material and generates the inner effect
   * @param verbose defines if the build should log activity
   * @param updateBuildId defines if the internal build Id should be updated (default is true)
   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)
   */
  build(verbose = false, updateBuildId = true, autoConfigure = false) {
    if (!this._vertexCompilationState && !autoConfigure) {
      autoConfigure = true;
    }
    this._buildWasSuccessful = false;
    const engine = this.getScene().getEngine();
    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;
    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
      throw "You must define at least one vertexOutputNode";
    }
    if (this._fragmentOutputNodes.length === 0) {
      throw "You must define at least one fragmentOutputNode";
    }
    this._vertexCompilationState = new NodeMaterialBuildState();
    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
    this._fragmentCompilationState = new NodeMaterialBuildState();
    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
    this._sharedData = new NodeMaterialBuildStateSharedData();
    this._sharedData.nodeMaterial = this;
    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;
    this._vertexCompilationState.sharedData = this._sharedData;
    this._fragmentCompilationState.sharedData = this._sharedData;
    this._sharedData.buildId = this._buildId;
    this._sharedData.emitComments = this._options.emitComments;
    this._sharedData.verbose = verbose;
    this._sharedData.scene = this.getScene();
    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
    const vertexNodes = [];
    const fragmentNodes = [];
    for (const vertexOutputNode of this._vertexOutputNodes) {
      vertexNodes.push(vertexOutputNode);
      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);
    }
    for (const fragmentOutputNode of this._fragmentOutputNodes) {
      fragmentNodes.push(fragmentOutputNode);
      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);
    }
    this.optimize();
    for (const vertexOutputNode of vertexNodes) {
      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
    }
    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
    this._fragmentCompilationState._vertexState = this._vertexCompilationState;
    for (const fragmentOutputNode of fragmentNodes) {
      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
    }
    for (const fragmentOutputNode of fragmentNodes) {
      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
    }
    this._vertexCompilationState.finalize(this._vertexCompilationState);
    this._fragmentCompilationState.finalize(this._fragmentCompilationState);
    if (updateBuildId) {
      this._buildId = _NodeMaterial._BuildIdGenerator++;
    }
    this._sharedData.emitErrors();
    if (verbose) {
      Logger.Log("Vertex shader:");
      Logger.Log(this._vertexCompilationState.compilationString);
      Logger.Log("Fragment shader:");
      Logger.Log(this._fragmentCompilationState.compilationString);
    }
    this._buildWasSuccessful = true;
    this.onBuildObservable.notifyObservers(this);
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.materialDefines) {
          continue;
        }
        const defines = subMesh.materialDefines;
        defines.markAllAsDirty();
        defines.reset();
      }
    }
    if (this.prePassTextureInputs.length) {
      this.getScene().enablePrePassRenderer();
    }
    const prePassRenderer = this.getScene().prePassRenderer;
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  }
  /**
   * Runs an otpimization phase to try to improve the shader code
   */
  optimize() {
    for (const optimizer of this._optimizers) {
      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
    }
  }
  _prepareDefinesForAttributes(mesh, defines) {
    const oldNormal = defines["NORMAL"];
    const oldTangent = defines["TANGENT"];
    const oldColor = defines["VERTEXCOLOR_NME"];
    defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
    defines["VERTEXCOLOR_NME"] = hasVertexColors;
    let uvChanged = false;
    for (let i = 1; i <= 6; ++i) {
      const oldUV = defines["UV" + i];
      defines["UV" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`);
      uvChanged = uvChanged || defines["UV" + i] !== oldUV;
    }
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(this.getScene(), defines, !oit);
    if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || oldColor !== defines["VERTEXCOLOR_NME"] || uvChanged) {
      defines.markAsAttributesDirty();
    }
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return true;
  }
  /**
   * Outputs written to the prepass
   */
  get prePassTextureOutputs() {
    const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === "PrePassOutputBlock");
    const result = [4];
    if (!prePassOutputBlock) {
      return result;
    }
    if (this.prePassTextureInputs.length) {
      return result;
    }
    if (prePassOutputBlock.viewDepth.isConnected) {
      result.push(5);
    }
    if (prePassOutputBlock.viewNormal.isConnected) {
      result.push(6);
    }
    if (prePassOutputBlock.worldPosition.isConnected) {
      result.push(1);
    }
    return result;
  }
  /**
   * Gets the list of prepass texture required
   */
  get prePassTextureInputs() {
    const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === "PrePassTextureBlock");
    const result = [];
    for (const block of prePassTextureBlocks) {
      if (block.position.isConnected && !result.includes(1)) {
        result.push(1);
      }
      if (block.depth.isConnected && !result.includes(5)) {
        result.push(5);
      }
      if (block.normal.isConnected && !result.includes(6)) {
        result.push(6);
      }
    }
    return result;
  }
  /**
   * Sets the required values to the prepass renderer.
   * @param prePassRenderer defines the prepass renderer to set
   * @returns true if the pre pass is needed
   */
  setPrePassRenderer(prePassRenderer) {
    const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);
    if (prePassRenderer && prePassTexturesRequired.length > 1) {
      let cfg = prePassRenderer.getEffectConfiguration("nodeMaterial");
      if (!cfg) {
        cfg = prePassRenderer.addEffectConfiguration({
          enabled: true,
          needsImageProcessing: false,
          name: "nodeMaterial",
          texturesRequired: []
        });
      }
      for (const prePassTexture of prePassTexturesRequired) {
        if (!cfg.texturesRequired.includes(prePassTexture)) {
          cfg.texturesRequired.push(prePassTexture);
        }
      }
      cfg.enabled = true;
    }
    return prePassTexturesRequired.length > 1;
  }
  /**
   * Create a post process from the material
   * @param camera The camera to apply the render pass to.
   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType Type of textures used when performing the post process. (default: 0)
   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
   * @returns the post process created
   */
  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    if (this.mode !== NodeMaterialModes.PostProcess) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
  }
  /**
   * Create the post process effect from the material
   * @param postProcess The post process to create the effect for
   */
  createEffectForPostProcess(postProcess) {
    this._createEffectForPostProcess(postProcess);
  }
  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    let tempName = this.name + this._buildId;
    const defines = new NodeMaterialDefines();
    const dummyMesh = new AbstractMesh(tempName + "PostProcess", this.getScene());
    let buildId = this._buildId;
    this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    if (!postProcess) {
      postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat);
    } else {
      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
    }
    postProcess.nodeMaterialSource = this;
    postProcess.onApplyObservable.add((effect) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result = this._processDefines(dummyMesh, defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName));
      }
      this._checkInternals(effect);
    });
    return postProcess;
  }
  /**
   * Create a new procedural texture based on this node material
   * @param size defines the size of the texture
   * @param scene defines the hosting scene
   * @returns the new procedural texture attached to this node material
   */
  createProceduralTexture(size, scene) {
    if (this.mode !== NodeMaterialModes.ProceduralTexture) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    let tempName = this.name + this._buildId;
    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
    const dummyMesh = new AbstractMesh(tempName + "Procedural", this.getScene());
    dummyMesh.reservedDataStore = {
      hidden: true
    };
    const defines = new NodeMaterialDefines();
    const result = this._processDefines(dummyMesh, defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
    let effect = this.getScene().getEngine().createEffect({
      vertexElement: tempName,
      fragmentElement: tempName
    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result == null ? void 0 : result.fallbacks, void 0);
    proceduralTexture.nodeMaterialSource = this;
    proceduralTexture._setEffect(effect);
    let buildId = this._buildId;
    proceduralTexture.onBeforeGenerationObservable.add(() => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result2 = this._processDefines(dummyMesh, defines);
      if (result2) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => {
          effect = this.getScene().getEngine().createEffect({
            vertexElement: tempName,
            fragmentElement: tempName
          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result2 == null ? void 0 : result2.fallbacks, void 0);
          proceduralTexture._setEffect(effect);
        });
      }
      this._checkInternals(effect);
    });
    return proceduralTexture;
  }
  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined = "") {
    let tempName = this.name + this._buildId + "_" + blendMode;
    if (!defines) {
      defines = new NodeMaterialDefines();
    }
    if (!dummyMesh) {
      dummyMesh = this.getScene().getMeshByName(this.name + "Particle");
      if (!dummyMesh) {
        dummyMesh = new AbstractMesh(this.name + "Particle", this.getScene());
        dummyMesh.reservedDataStore = {
          hidden: true
        };
      }
    }
    let buildId = this._buildId;
    const particleSystemDefines = [];
    let join = particleSystemDefinesJoined;
    if (!effect) {
      const result = this._processDefines(dummyMesh, defines);
      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      join = particleSystemDefines.join("\n");
      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result == null ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);
      particleSystem.setCustomEffect(effect, blendMode);
    }
    effect.onBindObservable.add((effect2) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId + "_" + blendMode;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      particleSystemDefines.length = 0;
      particleSystem.fillDefines(particleSystemDefines, blendMode);
      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
      if (particleSystemDefinesJoinedCurrent !== join) {
        defines.markAllAsDirty();
        join = particleSystemDefinesJoinedCurrent;
      }
      const result = this._processDefines(dummyMesh, defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);
        effect2 = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result == null ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);
        particleSystem.setCustomEffect(effect2, blendMode);
        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, dummyMesh, particleSystemDefinesJoined);
        return;
      }
      this._checkInternals(effect2);
    });
  }
  _checkInternals(effect) {
    if (this._sharedData.animatedInputs) {
      const scene = this.getScene();
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    for (const block of this._sharedData.bindableBlocks) {
      block.bind(effect, this);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmit(effect, this.getScene(), this);
    }
  }
  /**
   * Create the effect to be used as the custom effect for a particle system
   * @param particleSystem Particle system to create the effect for
   * @param onCompiled defines a function to call when the effect creation is successful
   * @param onError defines a function to call when the effect creation has failed
   */
  createEffectForParticles(particleSystem, onCompiled, onError) {
    if (this.mode !== NodeMaterialModes.Particle) {
      Logger.Log("Incompatible material mode");
      return;
    }
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
  }
  /**
   * Use this material as the shadow depth wrapper of a target material
   * @param targetMaterial defines the target material
   */
  createAsShadowDepthWrapper(targetMaterial) {
    if (this.mode !== NodeMaterialModes.Material) {
      Logger.Log("Incompatible material mode");
      return;
    }
    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());
  }
  _processDefines(mesh, defines, useInstances = false, subMesh) {
    let result = null;
    const scene = this.getScene();
    if (PrepareDefinesForCamera(scene, defines)) {
      defines.markAsMiscDirty();
    }
    this._sharedData.blocksWithDefines.forEach((b) => {
      b.initializeDefines(mesh, this, defines, useInstances);
    });
    this._sharedData.blocksWithDefines.forEach((b) => {
      b.prepareDefines(mesh, this, defines, useInstances, subMesh);
    });
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
      this._sharedData.repeatableContentBlocks.forEach((b) => {
        b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);
      });
      const uniformBuffers = [];
      this._sharedData.dynamicUniformBlocks.forEach((b) => {
        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);
      });
      const mergedUniforms = this._vertexCompilationState.uniforms;
      this._fragmentCompilationState.uniforms.forEach((u) => {
        const index = mergedUniforms.indexOf(u);
        if (index === -1) {
          mergedUniforms.push(u);
        }
      });
      const mergedSamplers = this._vertexCompilationState.samplers;
      this._fragmentCompilationState.samplers.forEach((s) => {
        const index = mergedSamplers.indexOf(s);
        if (index === -1) {
          mergedSamplers.push(s);
        }
      });
      const fallbacks = new EffectFallbacks();
      this._sharedData.blocksWithFallbacks.forEach((b) => {
        b.provideFallbacks(mesh, fallbacks);
      });
      result = {
        lightDisposed,
        uniformBuffers,
        mergedUniforms,
        mergedSamplers,
        fallbacks
      };
    }
    return result;
  }
  /**
   * Get if the submesh is ready to be used and all its information available.
   * Child classes can use it to update shaders
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._buildWasSuccessful) {
      return false;
    }
    const scene = this.getScene();
    if (this._sharedData.animatedInputs) {
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new NodeMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    this._prepareDefinesForAttributes(mesh, defines);
    if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {
      return false;
    }
    const result = this._processDefines(mesh, defines, useInstances, subMesh);
    if (result) {
      const previousEffect = subMesh.effect;
      const join = defines.toString();
      let effect = engine.createEffect({
        vertex: "nodeMaterial" + this._buildId,
        fragment: "nodeMaterial" + this._buildId,
        vertexSource: this._vertexCompilationState.compilationString,
        fragmentSource: this._fragmentCompilationState.compilationString
      }, {
        attributes: this._vertexCompilationState.attributes,
        uniformsNames: result.mergedUniforms,
        uniformBuffersNames: result.uniformBuffers,
        samplers: result.mergedSamplers,
        defines: join,
        fallbacks: result.fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        multiTarget: defines.PREPASS,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (result.lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Get a string representing the shaders built by the current node graph
   */
  get compiledShaders() {
    return `// Vertex shader
${this._vertexCompilationState.compilationString}

// Fragment shader
${this._fragmentCompilationState.compilationString}`;
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   */
  bindOnlyWorldMatrix(world) {
    const scene = this.getScene();
    if (!this._activeEffect) {
      return;
    }
    const hints = this._sharedData.hints;
    if (hints.needWorldViewMatrix) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
    }
    if (hints.needWorldViewProjectionMatrix) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    const sharedData = this._sharedData;
    if (mustRebind) {
      for (const block of sharedData.bindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const inputBlock of sharedData.inputBlocks) {
        inputBlock._transmit(effect, scene, this);
      }
    } else if (!this.isFrozen) {
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._sharedData) {
      activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture));
    }
    return activeTextures;
  }
  /**
   * Gets the list of texture blocks
   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!
   * @returns an array of texture blocks
   */
  getTextureBlocks() {
    if (!this._sharedData) {
      return [];
    }
    return this._sharedData.textureBlocks;
  }
  /**
   * Gets the list of all texture blocks
   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks
   * @returns
   */
  getAllTextureBlocks() {
    const textureBlocks = [];
    for (const block of this.attachedBlocks) {
      if (_NodeMaterial._BlockIsTextureBlock(block)) {
        textureBlocks.push(block);
      }
    }
    return textureBlocks;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (!this._sharedData) {
      return false;
    }
    for (const t of this._sharedData.textureBlocks) {
      if (t.texture === texture) {
        return true;
      }
    }
    return false;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      for (const texture of this.getTextureBlocks().filter((tb) => tb.texture).map((tb) => tb.texture)) {
        texture.dispose();
      }
    }
    for (const block of this.attachedBlocks) {
      block.dispose();
    }
    this.attachedBlocks.length = 0;
    this._sharedData = null;
    this._vertexCompilationState = null;
    this._fragmentCompilationState = null;
    this.onBuildObservable.clear();
    if (this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
      this._imageProcessingObserver = null;
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /** Creates the node editor window.
   * @param additionalConfig Define the configuration of the editor
   */
  _createNodeEditor(additionalConfig) {
    const nodeEditorConfig = {
      nodeMaterial: this,
      ...additionalConfig
    };
    this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);
  }
  /**
   * Launch the node material editor
   * @param config Define the configuration of the editor
   * @returns a promise fulfilled when the node editor is visible
   */
  edit(config) {
    return new Promise((resolve) => {
      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
      if (typeof this.BJSNODEMATERIALEDITOR == "undefined") {
        const editorUrl = config && config.editorURL ? config.editorURL : _NodeMaterial.EditorURL;
        Tools.LoadBabylonScript(editorUrl, () => {
          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
          this._createNodeEditor(config == null ? void 0 : config.nodeEditorConfig);
          resolve();
        });
      } else {
        this._createNodeEditor(config == null ? void 0 : config.nodeEditorConfig);
        resolve();
      }
    });
  }
  /**
   * Clear the current material
   */
  clear() {
    this._vertexOutputNodes.length = 0;
    this._fragmentOutputNodes.length = 0;
    this.attachedBlocks.length = 0;
  }
  /**
   * Clear the current material and set it to a default state
   */
  setToDefault() {
    this.clear();
    this.editorData = null;
    const positionInput = new InputBlock("Position");
    positionInput.setAsAttribute("position");
    const worldInput = new InputBlock("World");
    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
    const worldPos = new TransformBlock("WorldPos");
    positionInput.connectTo(worldPos);
    worldInput.connectTo(worldPos);
    const viewProjectionInput = new InputBlock("ViewProjection");
    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);
    const worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
    worldPos.connectTo(worldPosdMultipliedByViewProjection);
    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
    const pixelColor = new InputBlock("color");
    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    pixelColor.connectTo(fragmentOutput);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Material;
  }
  /**
   * Clear the current material and set it to a default state for post process
   */
  setToDefaultPostProcess() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const scale = new InputBlock("Scale");
    scale.visibleInInspector = true;
    scale.value = new Vector2(1, 1);
    const uv0 = new RemapBlock("uv0");
    position.connectTo(uv0);
    const uv = new MultiplyBlock("UV scale");
    uv0.connectTo(uv);
    scale.connectTo(uv);
    const currentScreen = new CurrentScreenBlock("CurrentScreen");
    uv.connectTo(currentScreen);
    currentScreen.texture = new Texture("https://assets.babylonjs.com/nme/currentScreenPostProcess.png", this.getScene());
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    currentScreen.connectTo(fragmentOutput, { output: "rgba" });
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.PostProcess;
  }
  /**
   * Clear the current material and set it to a default state for procedural texture
   */
  setToDefaultProceduralTexture() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const time = new InputBlock("Time");
    time.value = 0;
    time.min = 0;
    time.max = 0;
    time.isBoolean = false;
    time.matrixMode = 0;
    time.animationType = AnimatedInputBlockTypes.Time;
    time.isConstant = false;
    const color = new InputBlock("Color3");
    color.value = new Color3(1, 1, 1);
    color.isConstant = false;
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    const vectorMerger = new VectorMergerBlock("VectorMerger");
    vectorMerger.visibleInInspector = false;
    const cos = new TrigonometryBlock("Cos");
    cos.operation = TrigonometryBlockOperations.Cos;
    position.connectTo(vectorMerger);
    time.output.connectTo(cos.input);
    cos.output.connectTo(vectorMerger.z);
    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.ProceduralTexture;
  }
  /**
   * Clear the current material and set it to a default state for particle
   */
  setToDefaultParticle() {
    this.clear();
    this.editorData = null;
    const uv = new InputBlock("uv");
    uv.setAsAttribute("particle_uv");
    const texture = new ParticleTextureBlock("ParticleTexture");
    uv.connectTo(texture);
    const color = new InputBlock("Color");
    color.setAsAttribute("particle_color");
    const multiply = new MultiplyBlock("Texture * Color");
    texture.connectTo(multiply);
    color.connectTo(multiply);
    const rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
    multiply.connectTo(rampGradient);
    const cSplitter = new ColorSplitterBlock("ColorSplitter");
    color.connectTo(cSplitter);
    const blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
    rampGradient.connectTo(blendMultiply);
    texture.connectTo(blendMultiply, { output: "a" });
    cSplitter.connectTo(blendMultiply, { output: "a" });
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    blendMultiply.connectTo(fragmentOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Particle;
  }
  /**
   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead
   * @param url defines the url to load from
   * @param rootUrl defines the root URL for nested url in the node material
   * @returns a promise that will fulfil when the material is fully loaded
   */
  async loadAsync(url, rootUrl = "") {
    return _NodeMaterial.ParseFromFileAsync("", url, this.getScene(), rootUrl, true, this);
  }
  _gatherBlocks(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (const input of rootNode.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
    if (rootNode.isTeleportOut) {
      const block = rootNode;
      if (block.entryPoint) {
        this._gatherBlocks(block.entryPoint, list);
      }
    }
  }
  /**
   * Generate a string containing the code declaration required to create an equivalent of this material
   * @returns a string
   */
  generateCode() {
    let alreadyDumped = [];
    const vertexBlocks = [];
    const uniqueNames = ["const", "var", "let"];
    for (const outputNode of this._vertexOutputNodes) {
      this._gatherBlocks(outputNode, vertexBlocks);
    }
    const fragmentBlocks = [];
    for (const outputNode of this._fragmentOutputNodes) {
      this._gatherBlocks(outputNode, fragmentBlocks);
    }
    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name || "node material"}");
`;
    codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};
`;
    for (const node of vertexBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const node of fragmentBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    alreadyDumped = [];
    codeString += "\n// Connections\n";
    for (const node of this._vertexOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    codeString += "\n// Output nodes\n";
    for (const node of this._vertexOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    codeString += `nodeMaterial.build();
`;
    return codeString;
  }
  /**
   * Serializes this material in a JSON representation
   * @param selectedBlocks defines an optional list of blocks to serialize
   * @returns the serialized material object
   */
  serialize(selectedBlocks) {
    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    let blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeMaterial";
      serializationObject.outputNodes = [];
      for (const outputNode of this._vertexOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        serializationObject.outputNodes.push(outputNode.uniqueId);
      }
      for (const outputNode of this._fragmentOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
          serializationObject.outputNodes.push(outputNode.uniqueId);
        }
      }
    }
    serializationObject.blocks = [];
    for (const block of blocks) {
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (const block of this.attachedBlocks) {
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    return serializationObject;
  }
  _restoreConnections(block, source, map) {
    for (const outputPoint of block.outputs) {
      for (const candidate of source.blocks) {
        const target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (const input of candidate.inputs) {
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            const inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   */
  parseSerializedObject(source, rootUrl = "", merge = false) {
    if (!merge) {
      this.clear();
    }
    const map = {};
    for (const parsedBlock of source.blocks) {
      const blockType = GetClass(parsedBlock.customType);
      if (blockType) {
        const block = new blockType();
        block._deserialize(parsedBlock, this.getScene(), rootUrl);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (const block of this.attachedBlocks) {
      if (block.isTeleportOut) {
        const teleportOut = block;
        const id = teleportOut._tempEntryPointUniqueId;
        if (id) {
          const source2 = map[id];
          source2.attachToEndpoint(teleportOut);
        }
      }
    }
    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      const parsedBlock = source.blocks[blockIndex];
      const block = map[parsedBlock.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodes) {
      for (const outputNodeId of source.outputNodes) {
        this.addOutputNode(map[outputNodeId]);
      }
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      const locations = source.locations || source.editorData.locations;
      for (const location of locations) {
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      const blockMap = [];
      for (const key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    this.comment = source.comment;
    if (source.forceAlphaBlending !== void 0) {
      this.forceAlphaBlending = source.forceAlphaBlending;
    }
    if (source.alphaMode !== void 0) {
      this.alphaMode = source.alphaMode;
    }
    if (!merge) {
      this._mode = source.mode ?? NodeMaterialModes.Material;
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   * @deprecated Please use the parseSerializedObject method instead
   */
  loadFromSerialization(source, rootUrl = "", merge = false) {
    this.parseSerializedObject(source, rootUrl, merge);
  }
  /**
   * Makes a duplicate of the current material.
   * @param name defines the name to use for the new material
   * @param shareEffect defines if the clone material should share the same effect (default is false)
   * @returns the cloned material
   */
  clone(name4, shareEffect = false) {
    const serializationObject = this.serialize();
    const clone = SerializationHelper.Clone(() => new _NodeMaterial(name4, this.getScene(), this.options), this);
    clone.id = name4;
    clone.name = name4;
    clone.parseSerializedObject(serializationObject);
    clone._buildId = this._buildId;
    clone.build(false, !shareEffect);
    return clone;
  }
  /**
   * Awaits for all the material textures to be ready before resolving the returned promise.
   * @returns A promise that resolves when the textures are ready.
   */
  whenTexturesReadyAsync() {
    const textureReadyPromises = [];
    this.getActiveTextures().forEach((texture) => {
      const internalTexture = texture.getInternalTexture();
      if (internalTexture && !internalTexture.isReady) {
        textureReadyPromises.push(new Promise((textureResolve, textureReject) => {
          internalTexture.onLoadedObservable.addOnce(() => {
            textureResolve();
          });
          internalTexture.onErrorObservable.addOnce((e) => {
            textureReject(e);
          });
        }));
      }
    });
    return Promise.all(textureReadyPromises);
  }
  /**
   * Creates a node material from parsed material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new node material
   */
  static Parse(source, scene, rootUrl = "") {
    const nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(source.name, scene), source, scene, rootUrl);
    nodeMaterial.parseSerializedObject(source, rootUrl);
    nodeMaterial.build();
    return nodeMaterial;
  }
  /**
   * Creates a node material from a snippet saved in a remote file
   * @param name defines the name of the material to create
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL for nested url in the node material
   * @param skipBuild defines whether to build the node material
   * @param targetMaterial defines a material to use instead of creating a new one
   * @returns a promise that will resolve to the new node material
   */
  static async ParseFromFileAsync(name4, url, scene, rootUrl = "", skipBuild = false, targetMaterial) {
    const material = targetMaterial ?? new _NodeMaterial(name4, scene);
    const data = await scene._loadFileAsync(url);
    const serializationObject = JSON.parse(data);
    material.parseSerializedObject(serializationObject, rootUrl);
    if (!skipBuild) {
      material.build();
    }
    return material;
  }
  /**
   * Creates a node material from a snippet saved by the node material editor
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param nodeMaterial defines a node material to update (instead of creating a new one)
   * @param skipBuild defines whether to build the node material
   * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)
   * @returns a promise that will resolve to the new node material
   */
  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = "", nodeMaterial, skipBuild = false, waitForTextureReadyness = false) {
    if (snippetId === "_BLANK") {
      return Promise.resolve(_NodeMaterial.CreateDefault("blank", scene));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.nodeMaterial);
            if (!nodeMaterial) {
              nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);
              nodeMaterial.uniqueId = scene.getUniqueId();
            }
            nodeMaterial.parseSerializedObject(serializationObject);
            nodeMaterial.snippetId = snippetId;
            try {
              if (!skipBuild) {
                nodeMaterial.build();
              }
            } catch (err) {
              reject(err);
            }
            if (waitForTextureReadyness) {
              nodeMaterial.whenTexturesReadyAsync().then(() => {
                resolve(nodeMaterial);
              }).catch((err) => {
                reject(err);
              });
            } else {
              resolve(nodeMaterial);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
  /**
   * Creates a new node material set to default basic configuration
   * @param name defines the name of the material
   * @param scene defines the hosting scene
   * @returns a new NodeMaterial
   */
  static CreateDefault(name4, scene) {
    const newMaterial = new _NodeMaterial(name4, scene);
    newMaterial.setToDefault();
    newMaterial.build();
    return newMaterial;
  }
};
NodeMaterial._BuildIdGenerator = 0;
NodeMaterial.EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/nodeEditor/babylon.nodeEditor.js`;
NodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
NodeMaterial.IgnoreTexturesAtLoadTime = false;
__decorate([
  serialize()
], NodeMaterial.prototype, "ignoreAlpha", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("mode")
], NodeMaterial.prototype, "_mode", void 0);
__decorate([
  serialize("comment")
], NodeMaterial.prototype, "comment", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "forceAlphaBlending", void 0);
RegisterClass("BABYLON.NodeMaterial", NodeMaterial);

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
function CreateIcoSphereVertexData(options) {
  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  const radius = options.radius || 1;
  const flat = options.flat === void 0 ? true : options.flat;
  const subdivisions = (options.subdivisions || 4) | 0;
  const radiusX = options.radiusX || radius;
  const radiusY = options.radiusY || radius;
  const radiusZ = options.radiusZ || radius;
  const t = (1 + Math.sqrt(5)) / 2;
  const icoVertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
    // v8-11
  ];
  const ico_indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  const vertices_unalias_id = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    // vertex alias
    0,
    2,
    3,
    3,
    3,
    4,
    7,
    8,
    9,
    9,
    10,
    11
    // 23: B + 12
  ];
  const ico_vertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    // vertex alias (for same vertex on different faces)
    0,
    4,
    3,
    3,
    4,
    4,
    3,
    1,
    4,
    2,
    4,
    4,
    0,
    2,
    1,
    1,
    2,
    2,
    3,
    3,
    1,
    3,
    2,
    4
    // 23: B + 12
  ];
  const ustep = 138 / 1024;
  const vstep = 239 / 1024;
  const uoffset = 60 / 1024;
  const voffset = 26 / 1024;
  const island_u_offset = -40 / 1024;
  const island_v_offset = 20 / 1024;
  const island = [
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0
    //  15 - 19
  ];
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let current_indice = 0;
  const face_vertex_pos = new Array(3);
  const face_vertex_uv = new Array(3);
  let v012;
  for (v012 = 0; v012 < 3; v012++) {
    face_vertex_pos[v012] = Vector3.Zero();
    face_vertex_uv[v012] = Vector2.Zero();
  }
  for (let face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      const v_id = ico_indices[3 * face + v012];
      face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);
      face_vertex_pos[v012].normalize();
      face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);
    }
    const interp_vertex = (i1, i2, c1, c2) => {
      const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);
      const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);
      const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));
      pos_interp.normalize();
      let vertex_normal;
      if (flat) {
        const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);
        const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);
        vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));
      } else {
        vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);
      }
      vertex_normal.x /= radiusX;
      vertex_normal.y /= radiusY;
      vertex_normal.z /= radiusZ;
      vertex_normal.normalize();
      const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);
      const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);
      const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));
      positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);
      normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);
      uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uv_interp.y : uv_interp.y);
      indices.push(current_indice);
      current_indice++;
    };
    for (let i2 = 0; i2 < subdivisions; i2++) {
      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {
        interp_vertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interp_vertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interp_vertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interp_vertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateIcoSphere(name4, options = {}, scene = null) {
  const sphere = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateIcoSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var IcoSphereBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateIcoSphere
};
VertexData.CreateIcoSphere = CreateIcoSphereVertexData;
Mesh.CreateIcoSphere = (name4, options, scene) => {
  return CreateIcoSphere(name4, options, scene);
};

// node_modules/@babylonjs/core/XR/features/WebXRHandTracking.js
var HandPart;
(function(HandPart2) {
  HandPart2["WRIST"] = "wrist";
  HandPart2["THUMB"] = "thumb";
  HandPart2["INDEX"] = "index";
  HandPart2["MIDDLE"] = "middle";
  HandPart2["RING"] = "ring";
  HandPart2["LITTLE"] = "little";
})(HandPart || (HandPart = {}));
var WebXRHandJoint;
(function(WebXRHandJoint2) {
  WebXRHandJoint2["WRIST"] = "wrist";
  WebXRHandJoint2["THUMB_METACARPAL"] = "thumb-metacarpal";
  WebXRHandJoint2["THUMB_PHALANX_PROXIMAL"] = "thumb-phalanx-proximal";
  WebXRHandJoint2["THUMB_PHALANX_DISTAL"] = "thumb-phalanx-distal";
  WebXRHandJoint2["THUMB_TIP"] = "thumb-tip";
  WebXRHandJoint2["INDEX_FINGER_METACARPAL"] = "index-finger-metacarpal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_PROXIMAL"] = "index-finger-phalanx-proximal";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_INTERMEDIATE"] = "index-finger-phalanx-intermediate";
  WebXRHandJoint2["INDEX_FINGER_PHALANX_DISTAL"] = "index-finger-phalanx-distal";
  WebXRHandJoint2["INDEX_FINGER_TIP"] = "index-finger-tip";
  WebXRHandJoint2["MIDDLE_FINGER_METACARPAL"] = "middle-finger-metacarpal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_PROXIMAL"] = "middle-finger-phalanx-proximal";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_INTERMEDIATE"] = "middle-finger-phalanx-intermediate";
  WebXRHandJoint2["MIDDLE_FINGER_PHALANX_DISTAL"] = "middle-finger-phalanx-distal";
  WebXRHandJoint2["MIDDLE_FINGER_TIP"] = "middle-finger-tip";
  WebXRHandJoint2["RING_FINGER_METACARPAL"] = "ring-finger-metacarpal";
  WebXRHandJoint2["RING_FINGER_PHALANX_PROXIMAL"] = "ring-finger-phalanx-proximal";
  WebXRHandJoint2["RING_FINGER_PHALANX_INTERMEDIATE"] = "ring-finger-phalanx-intermediate";
  WebXRHandJoint2["RING_FINGER_PHALANX_DISTAL"] = "ring-finger-phalanx-distal";
  WebXRHandJoint2["RING_FINGER_TIP"] = "ring-finger-tip";
  WebXRHandJoint2["PINKY_FINGER_METACARPAL"] = "pinky-finger-metacarpal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_PROXIMAL"] = "pinky-finger-phalanx-proximal";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_INTERMEDIATE"] = "pinky-finger-phalanx-intermediate";
  WebXRHandJoint2["PINKY_FINGER_PHALANX_DISTAL"] = "pinky-finger-phalanx-distal";
  WebXRHandJoint2["PINKY_FINGER_TIP"] = "pinky-finger-tip";
})(WebXRHandJoint || (WebXRHandJoint = {}));
var handJointReferenceArray = [
  WebXRHandJoint.WRIST,
  WebXRHandJoint.THUMB_METACARPAL,
  WebXRHandJoint.THUMB_PHALANX_PROXIMAL,
  WebXRHandJoint.THUMB_PHALANX_DISTAL,
  WebXRHandJoint.THUMB_TIP,
  WebXRHandJoint.INDEX_FINGER_METACARPAL,
  WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.INDEX_FINGER_TIP,
  WebXRHandJoint.MIDDLE_FINGER_METACARPAL,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.MIDDLE_FINGER_TIP,
  WebXRHandJoint.RING_FINGER_METACARPAL,
  WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.RING_FINGER_TIP,
  WebXRHandJoint.PINKY_FINGER_METACARPAL,
  WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,
  WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,
  WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,
  WebXRHandJoint.PINKY_FINGER_TIP
];
var handPartsDefinition = {
  [HandPart.WRIST]: [WebXRHandJoint.WRIST],
  [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],
  [HandPart.INDEX]: [
    WebXRHandJoint.INDEX_FINGER_METACARPAL,
    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.INDEX_FINGER_TIP
  ],
  [HandPart.MIDDLE]: [
    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.MIDDLE_FINGER_TIP
  ],
  [HandPart.RING]: [
    WebXRHandJoint.RING_FINGER_METACARPAL,
    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.RING_FINGER_TIP
  ],
  [HandPart.LITTLE]: [
    WebXRHandJoint.PINKY_FINGER_METACARPAL,
    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,
    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,
    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,
    WebXRHandJoint.PINKY_FINGER_TIP
  ]
};
var WebXRHand = class {
  /**
   * Get the hand mesh.
   */
  get handMesh() {
    return this._handMesh;
  }
  /**
   * Get meshes of part of the hand.
   * @param part The part of hand to get.
   * @returns An array of meshes that correlate to the hand part requested.
   */
  getHandPartMeshes(part) {
    return handPartsDefinition[part].map((name4) => this._jointMeshes[handJointReferenceArray.indexOf(name4)]);
  }
  /**
   * Retrieves a mesh linked to a named joint in the hand.
   * @param jointName The name of the joint.
   * @returns An AbstractMesh whose position corresponds with the joint position.
   */
  getJointMesh(jointName) {
    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];
  }
  /**
   * Construct a new hand object
   * @param xrController The controller to which the hand correlates.
   * @param _jointMeshes The meshes to be used to track the hand joints.
   * @param _handMesh An optional hand mesh.
   * @param rigMapping An optional rig mapping for the hand mesh.
   *                   If not provided (but a hand mesh is provided),
   *                   it will be assumed that the hand mesh's bones are named
   *                   directly after the WebXR bone names.
   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes
   * @param _jointsInvisible Are the tracked joint meshes visible
   * @param _jointScaleFactor Scale factor for all joint meshes
   */
  constructor(xrController, _jointMeshes, _handMesh, rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {
    this.xrController = xrController;
    this._jointMeshes = _jointMeshes;
    this._handMesh = _handMesh;
    this.rigMapping = rigMapping;
    this._leftHandedMeshes = _leftHandedMeshes;
    this._jointsInvisible = _jointsInvisible;
    this._jointScaleFactor = _jointScaleFactor;
    this._jointTransforms = new Array(handJointReferenceArray.length);
    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);
    this._tempJointMatrix = new Matrix();
    this._jointRadii = new Float32Array(handJointReferenceArray.length);
    this._scene = _jointMeshes[0].getScene();
    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {
      const jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);
      jointTransform.rotationQuaternion = new Quaternion();
      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();
    }
    if (_handMesh) {
      this.setHandMesh(_handMesh, rigMapping);
    }
    if (this.xrController.motionController) {
      if (this.xrController.motionController.rootMesh) {
        this.xrController.motionController.rootMesh.dispose(false, true);
      }
    }
    this.xrController.onMotionControllerInitObservable.add((motionController) => {
      motionController._doNotLoadControllerMesh = true;
    });
  }
  /**
   * Sets the current hand mesh to render for the WebXRHand.
   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.
   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.
   * @param _xrSessionManager The XRSessionManager used to initialize the hand mesh.
   */
  setHandMesh(handMesh, rigMapping, _xrSessionManager) {
    this._handMesh = handMesh;
    handMesh.alwaysSelectAsActiveMesh = true;
    handMesh.getChildMeshes().forEach((mesh) => {
      mesh.alwaysSelectAsActiveMesh = true;
    });
    if (this._handMesh.skeleton) {
      const handMeshSkeleton = this._handMesh.skeleton;
      handJointReferenceArray.forEach((jointName, jointIdx) => {
        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);
        if (jointBoneIdx !== -1) {
          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);
        }
      });
    }
  }
  /**
   * Update this hand from the latest xr frame.
   * @param xrFrame The latest frame received from WebXR.
   * @param referenceSpace The current viewer reference space.
   */
  updateFromXRFrame(xrFrame, referenceSpace) {
    const hand = this.xrController.inputSource.hand;
    if (!hand) {
      return;
    }
    const anyHand = hand;
    const jointSpaces = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));
    let trackingSuccessful = false;
    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {
      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);
    } else if (xrFrame.getJointPose) {
      trackingSuccessful = true;
      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {
        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);
        if (jointPose) {
          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);
          this._jointRadii[jointIdx] = jointPose.radius || 8e-3;
        } else {
          trackingSuccessful = false;
          break;
        }
      }
    }
    if (!trackingSuccessful) {
      return;
    }
    handJointReferenceArray.forEach((_jointName, jointIdx) => {
      const jointTransform = this._jointTransforms[jointIdx];
      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);
      this._tempJointMatrix.decompose(void 0, jointTransform.rotationQuaternion, jointTransform.position);
      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;
      const jointMesh = this._jointMeshes[jointIdx];
      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;
      jointMesh.position.copyFrom(jointTransform.position);
      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);
      jointMesh.scaling.setAll(scaledJointRadius);
      if (!this._scene.useRightHandedSystem) {
        jointMesh.position.z *= -1;
        jointMesh.rotationQuaternion.z *= -1;
        jointMesh.rotationQuaternion.w *= -1;
        if (this._leftHandedMeshes && this._handMesh) {
          jointTransform.position.z *= -1;
          jointTransform.rotationQuaternion.z *= -1;
          jointTransform.rotationQuaternion.w *= -1;
        }
      }
    });
    if (this._handMesh) {
      this._handMesh.isVisible = true;
    }
  }
  /**
   * Dispose this Hand object
   * @param disposeMeshes Should the meshes be disposed as well
   */
  dispose(disposeMeshes = false) {
    var _a;
    if (this._handMesh) {
      if (disposeMeshes) {
        (_a = this._handMesh.skeleton) == null ? void 0 : _a.dispose();
        this._handMesh.dispose(false, true);
      } else {
        this._handMesh.isVisible = false;
      }
    }
  }
};
var WebXRHandTracking = class _WebXRHandTracking extends WebXRAbstractFeature {
  static _GenerateTrackedJointMeshes(featureOptions) {
    const meshes = {};
    ["left", "right"].map((handedness) => {
      var _a, _b, _c, _d, _e;
      const trackedMeshes = [];
      const originalMesh = ((_a = featureOptions.jointMeshes) == null ? void 0 : _a.sourceMesh) || CreateIcoSphere("jointParent", _WebXRHandTracking._ICOSPHERE_PARAMS);
      originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) == null ? void 0 : _b.keepOriginalVisible);
      for (let i = 0; i < handJointReferenceArray.length; ++i) {
        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);
        if ((_c = featureOptions.jointMeshes) == null ? void 0 : _c.onHandJointMeshGenerated) {
          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);
          if (returnedMesh) {
            if (returnedMesh !== newInstance) {
              newInstance.dispose();
              newInstance = returnedMesh;
            }
          }
        }
        newInstance.isPickable = false;
        if ((_d = featureOptions.jointMeshes) == null ? void 0 : _d.enablePhysics) {
          const props = ((_e = featureOptions.jointMeshes) == null ? void 0 : _e.physicsProps) || {};
          newInstance.scaling.setAll(0.02);
          const type = props.impostorType !== void 0 ? props.impostorType : PhysicsImpostor.SphereImpostor;
          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });
        }
        newInstance.rotationQuaternion = new Quaternion();
        newInstance.isVisible = false;
        trackedMeshes.push(newInstance);
      }
      meshes[handedness] = trackedMeshes;
    });
    return { left: meshes.left, right: meshes.right };
  }
  static _GenerateDefaultHandMeshesAsync(scene, xrSessionManager, options) {
    return new Promise(async (resolve) => {
      var _a, _b, _c, _d, _e, _f;
      const riggedMeshes = {};
      if ((_b = (_a = _WebXRHandTracking._RightHandGLB) == null ? void 0 : _a.meshes[1]) == null ? void 0 : _b.isDisposed()) {
        _WebXRHandTracking._RightHandGLB = null;
      }
      if ((_d = (_c = _WebXRHandTracking._LeftHandGLB) == null ? void 0 : _c.meshes[1]) == null ? void 0 : _d.isDisposed()) {
        _WebXRHandTracking._LeftHandGLB = null;
      }
      const handsDefined = !!(_WebXRHandTracking._RightHandGLB && _WebXRHandTracking._LeftHandGLB);
      const handGLBs = await Promise.all([
        _WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync("", _WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, _WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),
        _WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync("", _WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, _WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)
      ]);
      _WebXRHandTracking._RightHandGLB = handGLBs[0];
      _WebXRHandTracking._LeftHandGLB = handGLBs[1];
      const handShader = await NodeMaterial.ParseFromFileAsync("handShader", _WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL, scene);
      handShader.needDepthPrePass = true;
      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;
      handShader.alphaMode = 2;
      handShader.build(false);
      const handColors = {
        base: Color3.FromInts(116, 63, 203),
        fresnel: Color3.FromInts(149, 102, 229),
        fingerColor: Color3.FromInts(177, 130, 255),
        tipFresnel: Color3.FromInts(220, 200, 255),
        ...(_e = options == null ? void 0 : options.handMeshes) == null ? void 0 : _e.customColors
      };
      const handNodes = {
        base: handShader.getBlockByName("baseColor"),
        fresnel: handShader.getBlockByName("fresnelColor"),
        fingerColor: handShader.getBlockByName("fingerColor"),
        tipFresnel: handShader.getBlockByName("tipFresnelColor")
      };
      handNodes.base.value = handColors.base;
      handNodes.fresnel.value = handColors.fresnel;
      handNodes.fingerColor.value = handColors.fingerColor;
      handNodes.tipFresnel.value = handColors.tipFresnel;
      const isMultiview = (_f = xrSessionManager._getBaseLayerWrapper()) == null ? void 0 : _f.isMultiview;
      ["left", "right"].forEach((handedness) => {
        const handGLB = handedness == "left" ? _WebXRHandTracking._LeftHandGLB : _WebXRHandTracking._RightHandGLB;
        if (!handGLB) {
          throw new Error("Could not load hand model");
        }
        const handMesh = handGLB.meshes[1];
        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;
        if (!isMultiview) {
          handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);
        }
        handMesh.isVisible = false;
        riggedMeshes[handedness] = handMesh;
        if (!handsDefined && !scene.useRightHandedSystem) {
          handGLB.meshes[1].rotate(Axis.Y, Math.PI);
        }
      });
      handShader.dispose();
      resolve({ left: riggedMeshes.left, right: riggedMeshes.right });
    });
  }
  /**
   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.
   * @param handedness The handedness being mapped for.
   * @returns A mapping from XRHandJoint to bone name.
   */
  static _GenerateDefaultHandMeshRigMapping(handedness) {
    const H = handedness == "right" ? "R" : "L";
    return {
      [WebXRHandJoint.WRIST]: `wrist_${H}`,
      [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,
      [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,
      [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,
      [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,
      [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,
      [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,
      [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,
      [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,
      [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,
      [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,
      [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`
    };
  }
  /**
   * Check if the needed objects are defined.
   * This does not mean that the feature is enabled, but that the objects needed are well defined.
   * @returns true if the needed objects for this feature are defined
   */
  isCompatible() {
    return typeof XRHand !== "undefined";
  }
  /**
   * Get the hand object according to the controller id
   * @param controllerId the controller id to which we want to get the hand
   * @returns null if not found or the WebXRHand object if found
   */
  getHandByControllerId(controllerId) {
    return this._attachedHands[controllerId];
  }
  /**
   * Get a hand object according to the requested handedness
   * @param handedness the handedness to request
   * @returns null if not found or the WebXRHand object if found
   */
  getHandByHandedness(handedness) {
    if (handedness == "none") {
      return null;
    }
    return this._trackingHands[handedness];
  }
  /**
   * Creates a new instance of the XR hand tracking feature.
   * @param _xrSessionManager An instance of WebXRSessionManager.
   * @param options Options to use when constructing this feature.
   */
  constructor(_xrSessionManager, options) {
    super(_xrSessionManager);
    this.options = options;
    this._attachedHands = {};
    this._trackingHands = { left: null, right: null };
    this._handResources = { jointMeshes: null, handMeshes: null, rigMappings: null };
    this._worldScaleObserver = null;
    this.onHandAddedObservable = new Observable();
    this.onHandRemovedObservable = new Observable();
    this._attachHand = (xrController) => {
      var _a, _b, _c;
      if (!xrController.inputSource.hand || xrController.inputSource.handedness == "none" || !this._handResources.jointMeshes) {
        return;
      }
      const handedness = xrController.inputSource.handedness;
      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], (_a = this.options.handMeshes) == null ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = this.options.jointMeshes) == null ? void 0 : _b.invisible, (_c = this.options.jointMeshes) == null ? void 0 : _c.scaleFactor);
      this._attachedHands[xrController.uniqueId] = webxrHand;
      this._trackingHands[handedness] = webxrHand;
      this.onHandAddedObservable.notifyObservers(webxrHand);
    };
    this._detachHand = (xrController) => {
      this._detachHandById(xrController.uniqueId);
    };
    this.xrNativeFeatureName = "hand-tracking";
    const anyOptions = options;
    const anyJointMeshOptions = anyOptions.jointMeshes;
    if (anyJointMeshOptions) {
      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;
      }
      if (typeof anyJointMeshOptions.handMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;
      }
      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;
      }
      if (typeof anyJointMeshOptions.rigMapping !== "undefined") {
        options.handMeshes = options.handMeshes || {};
        const leftRigMapping = {};
        const rightRigMapping = {};
        [
          [anyJointMeshOptions.rigMapping.left, leftRigMapping],
          [anyJointMeshOptions.rigMapping.right, rightRigMapping]
        ].forEach((rigMappingTuple) => {
          const legacyRigMapping = rigMappingTuple[0];
          const rigMapping = rigMappingTuple[1];
          legacyRigMapping.forEach((modelJointName, index) => {
            rigMapping[handJointReferenceArray[index]] = modelJointName;
          });
        });
        options.handMeshes.customRigMappings = {
          left: leftRigMapping,
          right: rightRigMapping
        };
      }
    }
  }
  /**
   * Attach this feature.
   * Will usually be called by the features manager.
   *
   * @returns true if successful.
   */
  attach() {
    var _a, _b, _c, _d;
    if (!super.attach()) {
      return false;
    }
    this._handResources = {
      jointMeshes: _WebXRHandTracking._GenerateTrackedJointMeshes(this.options),
      handMeshes: ((_a = this.options.handMeshes) == null ? void 0 : _a.customMeshes) || null,
      rigMappings: ((_b = this.options.handMeshes) == null ? void 0 : _b.customRigMappings) || null
    };
    if (!((_c = this.options.handMeshes) == null ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) == null ? void 0 : _d.disableDefaultMeshes)) {
      _WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this._xrSessionManager, this.options).then((defaultHandMeshes) => {
        var _a2, _b2;
        this._handResources.handMeshes = defaultHandMeshes;
        this._handResources.rigMappings = {
          left: _WebXRHandTracking._GenerateDefaultHandMeshRigMapping("left"),
          right: _WebXRHandTracking._GenerateDefaultHandMeshRigMapping("right")
        };
        (_a2 = this._trackingHands.left) == null ? void 0 : _a2.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left, this._xrSessionManager);
        (_b2 = this._trackingHands.right) == null ? void 0 : _b2.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right, this._xrSessionManager);
        this._handResources.handMeshes.left.scaling.setAll(this._xrSessionManager.worldScalingFactor);
        this._handResources.handMeshes.right.scaling.setAll(this._xrSessionManager.worldScalingFactor);
      });
      this._worldScaleObserver = this._xrSessionManager.onWorldScaleFactorChangedObservable.add((scalingFactors) => {
        if (this._handResources.handMeshes) {
          this._handResources.handMeshes.left.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);
          this._handResources.handMeshes.right.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);
        }
      });
    }
    this.options.xrInput.controllers.forEach(this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);
    return true;
  }
  _onXRFrame(_xrFrame) {
    var _a, _b;
    (_a = this._trackingHands.left) == null ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);
    (_b = this._trackingHands.right) == null ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);
  }
  _detachHandById(controllerId, disposeMesh) {
    var _a;
    const hand = this.getHandByControllerId(controllerId);
    if (hand) {
      const handedness = hand.xrController.inputSource.handedness == "left" ? "left" : "right";
      if (((_a = this._trackingHands[handedness]) == null ? void 0 : _a.xrController.uniqueId) === controllerId) {
        this._trackingHands[handedness] = null;
      }
      this.onHandRemovedObservable.notifyObservers(hand);
      hand.dispose(disposeMesh);
      delete this._attachedHands[controllerId];
    }
  }
  /**
   * Detach this feature.
   * Will usually be called by the features manager.
   *
   * @returns true if successful.
   */
  detach() {
    var _a;
    if (!super.detach()) {
      return false;
    }
    Object.keys(this._attachedHands).forEach((uniqueId) => {
      var _a2;
      return this._detachHandById(uniqueId, (_a2 = this.options.handMeshes) == null ? void 0 : _a2.disposeOnSessionEnd);
    });
    if ((_a = this.options.handMeshes) == null ? void 0 : _a.disposeOnSessionEnd) {
      if (this._handResources.jointMeshes) {
        this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());
        this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());
      }
    }
    if (this._worldScaleObserver) {
      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);
    }
    return true;
  }
  /**
   * Dispose this feature and all of the resources attached.
   */
  dispose() {
    var _a;
    super.dispose();
    this.onHandAddedObservable.clear();
    this.onHandRemovedObservable.clear();
    if (this._handResources.handMeshes && !((_a = this.options.handMeshes) == null ? void 0 : _a.customMeshes)) {
      this._handResources.handMeshes.left.dispose();
      this._handResources.handMeshes.right.dispose();
      _WebXRHandTracking._RightHandGLB = null;
      _WebXRHandTracking._LeftHandGLB = null;
    }
    if (this._handResources.jointMeshes) {
      this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());
      this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());
    }
  }
};
WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;
WebXRHandTracking.Version = 1;
WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = "https://assets.babylonjs.com/meshes/HandMeshes/";
WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = "r_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = "l_hand_rhs.glb";
WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = "https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json";
WebXRHandTracking._ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };
WebXRHandTracking._RightHandGLB = null;
WebXRHandTracking._LeftHandGLB = null;
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {
  return () => new WebXRHandTracking(xrSessionManager, options);
}, WebXRHandTracking.Version, false);

// node_modules/@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js
var HandConstraintZone;
(function(HandConstraintZone2) {
  HandConstraintZone2[HandConstraintZone2["ABOVE_FINGER_TIPS"] = 0] = "ABOVE_FINGER_TIPS";
  HandConstraintZone2[HandConstraintZone2["RADIAL_SIDE"] = 1] = "RADIAL_SIDE";
  HandConstraintZone2[HandConstraintZone2["ULNAR_SIDE"] = 2] = "ULNAR_SIDE";
  HandConstraintZone2[HandConstraintZone2["BELOW_WRIST"] = 3] = "BELOW_WRIST";
})(HandConstraintZone || (HandConstraintZone = {}));
var HandConstraintOrientation;
(function(HandConstraintOrientation2) {
  HandConstraintOrientation2[HandConstraintOrientation2["LOOK_AT_CAMERA"] = 0] = "LOOK_AT_CAMERA";
  HandConstraintOrientation2[HandConstraintOrientation2["HAND_ROTATION"] = 1] = "HAND_ROTATION";
})(HandConstraintOrientation || (HandConstraintOrientation = {}));
var HandConstraintVisibility;
(function(HandConstraintVisibility2) {
  HandConstraintVisibility2[HandConstraintVisibility2["ALWAYS_VISIBLE"] = 0] = "ALWAYS_VISIBLE";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_UP"] = 1] = "PALM_UP";
  HandConstraintVisibility2[HandConstraintVisibility2["GAZE_FOCUS"] = 2] = "GAZE_FOCUS";
  HandConstraintVisibility2[HandConstraintVisibility2["PALM_AND_GAZE"] = 3] = "PALM_AND_GAZE";
})(HandConstraintVisibility || (HandConstraintVisibility = {}));
var HandConstraintBehavior = class {
  /**
   * Builds a hand constraint behavior
   */
  constructor() {
    this._sceneRenderObserver = null;
    this._zoneAxis = {};
    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;
    this.palmUpStrictness = 0.95;
    this.gazeProximityRadius = 0.15;
    this.targetOffset = 0.1;
    this.targetZone = HandConstraintZone.ULNAR_SIDE;
    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;
    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;
    this.handedness = "none";
    this.lerpTime = 100;
    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);
    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);
    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);
    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);
  }
  /** gets or sets behavior's name */
  get name() {
    return "HandConstraint";
  }
  /** Enable the behavior */
  enable() {
    this._node.setEnabled(true);
  }
  /** Disable the behavior */
  disable() {
    this._node.setEnabled(false);
  }
  _getHandPose() {
    if (!this._handTracking) {
      return null;
    }
    let hand;
    if (this.handedness === "none") {
      hand = this._handTracking.getHandByHandedness("left") || this._handTracking.getHandByHandedness("right");
    } else {
      hand = this._handTracking.getHandByHandedness(this.handedness);
    }
    if (hand) {
      const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);
      const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);
      const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);
      if (wrist && middleMetacarpal && pinkyMetacarpal) {
        const handPose = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };
        const up = TmpVectors.Vector3[0];
        const forward = TmpVectors.Vector3[1];
        const left = TmpVectors.Vector3[2];
        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();
        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();
        Vector3.CrossToRef(up, forward, forward);
        Vector3.CrossToRef(forward, up, left);
        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);
        return handPose;
      }
    }
    return null;
  }
  /**
   * Initializes the hand constraint behavior
   */
  init() {
  }
  /**
   * Attaches the hand constraint to a `TransformNode`
   * @param node defines the node to attach the behavior to
   */
  attach(node) {
    this._node = node;
    this._scene = node.getScene();
    if (!this._node.rotationQuaternion) {
      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);
    }
    let lastTick = Date.now();
    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      const pose = this._getHandPose();
      this._node.reservedDataStore = this._node.reservedDataStore || {};
      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};
      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;
      if (pose) {
        const zoneOffset = TmpVectors.Vector3[0];
        const camera = this._scene.activeCamera;
        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);
        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];
        if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {
          const toCamera = TmpVectors.Vector3[1];
          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();
          if (this._scene.useRightHandedSystem) {
            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          } else {
            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
          }
        }
        if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {
          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        } else {
          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);
        }
        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);
        zoneOffset.scaleInPlace(this.targetOffset);
        const targetPosition = TmpVectors.Vector3[2];
        const targetRotation = TmpVectors.Quaternion[1];
        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);
        if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {
          targetRotation.copyFrom(pose.quaternion);
        } else {
          targetRotation.copyFrom(cameraLookAtQuaternion);
        }
        const elapsed = Date.now() - lastTick;
        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);
        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);
        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;
      }
      this._setVisibility(pose);
      lastTick = Date.now();
    });
  }
  _setVisibility(pose) {
    let palmVisible = true;
    let gazeVisible = true;
    const camera = this._scene.activeCamera;
    if (camera) {
      const cameraForward = camera.getForwardRay();
      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {
        gazeVisible = false;
        let gaze;
        if (this._eyeTracking) {
          gaze = this._eyeTracking.getEyeGaze();
        }
        gaze = gaze || cameraForward;
        const gazeToBehavior = TmpVectors.Vector3[0];
        if (pose) {
          pose.position.subtractToRef(gaze.origin, gazeToBehavior);
        } else {
          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);
        }
        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);
        const projectedSquared = projectedDistance * projectedDistance;
        if (projectedDistance > 0) {
          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;
          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {
            gazeVisible = true;
          }
        }
      }
      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {
        palmVisible = false;
        if (pose) {
          const palmDirection = TmpVectors.Vector3[0];
          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);
          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {
            palmVisible = true;
          }
        }
      }
    }
    this._node.setEnabled(palmVisible && gazeVisible);
  }
  /**
   * Detaches the behavior from the `TransformNode`
   */
  detach() {
    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);
  }
  /**
   * Links the behavior to the XR experience in which to retrieve hand transform information.
   * @param xr xr experience
   */
  linkToXRExperience(xr) {
    const featuresManager = xr.featuresManager ? xr.featuresManager : xr;
    if (!featuresManager) {
      Tools.Error("XR features manager must be available or provided directly for the Hand Menu to work");
    } else {
      try {
        this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);
      } catch {
      }
      try {
        this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);
      } catch {
        Tools.Error("Hand tracking must be enabled for the Hand Menu to work");
      }
    }
  }
};

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer = class _UtilityLayerRenderer {
  /**
   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
   * @returns the camera that is used when rendering the utility layer
   */
  getRenderCamera(getRigParentIfPossible) {
    if (this._renderCamera) {
      return this._renderCamera;
    } else {
      let activeCam;
      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
      } else {
        activeCam = this.originalScene.activeCamera;
      }
      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
        return activeCam.rigParent;
      }
      return activeCam;
    }
  }
  /**
   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
   * @param cam the camera that should be used when rendering the utility layer
   */
  setRenderCamera(cam) {
    this._renderCamera = cam;
  }
  /**
   * @internal
   * Light which used by gizmos to get light shading
   */
  _getSharedGizmoLight() {
    if (!this._sharedGizmoLight) {
      this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
      this._sharedGizmoLight.intensity = 2;
      this._sharedGizmoLight.groundColor = Color3.Gray();
    }
    return this._sharedGizmoLight;
  }
  /**
   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
   */
  static get DefaultUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultUtilityLayer == null) {
      return _UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
    }
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * Creates an utility layer, and set it as a default utility layer
   * @param scene associated scene
   * @internal
   */
  static _CreateDefaultUtilityLayerFromScene(scene) {
    _UtilityLayerRenderer._DefaultUtilityLayer = new _UtilityLayerRenderer(scene);
    _UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
      _UtilityLayerRenderer._DefaultUtilityLayer = null;
    });
    return _UtilityLayerRenderer._DefaultUtilityLayer;
  }
  /**
   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
   */
  static get DefaultKeepDepthUtilityLayer() {
    if (_UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new _UtilityLayerRenderer(EngineStore.LastCreatedScene);
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
      _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
      });
    }
    return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
  }
  /**
   * Instantiates a UtilityLayerRenderer
   * @param originalScene the original scene that will be rendered on top of
   * @param handleEvents boolean indicating if the utility layer should handle events
   */
  constructor(originalScene, handleEvents = true) {
    this.originalScene = originalScene;
    this._pointerCaptures = {};
    this._lastPointerEvents = {};
    this._sharedGizmoLight = null;
    this._renderCamera = null;
    this.pickUtilitySceneFirst = true;
    this.shouldRender = true;
    this.onlyCheckPointerDownEvents = true;
    this.processAllEvents = false;
    this.pickingEnabled = true;
    this.onPointerOutObservable = new Observable();
    this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
    this.utilityLayerScene._allowPostProcessClearColor = false;
    this.utilityLayerScene.postProcessesEnabled = false;
    this.utilityLayerScene.detachControl();
    if (handleEvents) {
      this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
        if (!this.utilityLayerScene.activeCamera) {
          return;
        }
        if (!this.pickingEnabled) {
          return;
        }
        if (!this.processAllEvents) {
          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
            return;
          }
        }
        this.utilityLayerScene.pointerX = originalScene.pointerX;
        this.utilityLayerScene.pointerY = originalScene.pointerY;
        const pointerEvent = prePointerInfo.event;
        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
          this._pointerCaptures[pointerEvent.pointerId] = false;
          return;
        }
        const getNearPickDataForScene = (scene) => {
          let scenePick = null;
          if (prePointerInfo.nearInteractionPickingInfo) {
            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
              scenePick = prePointerInfo.nearInteractionPickingInfo;
            } else {
              scenePick = new PickingInfo();
            }
          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
            scenePick = prePointerInfo.originalPickingInfo;
          } else {
            let previousActiveCamera = null;
            if (this._renderCamera) {
              previousActiveCamera = scene._activeCamera;
              scene._activeCamera = this._renderCamera;
              prePointerInfo.ray = null;
            }
            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
            if (previousActiveCamera) {
              scene._activeCamera = previousActiveCamera;
            }
          }
          return scenePick;
        };
        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
        if (!prePointerInfo.ray && utilityScenePick) {
          prePointerInfo.ray = utilityScenePick.ray;
        }
        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
          if (!prePointerInfo.skipOnPointerObservable) {
            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
          }
          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
            this._pointerCaptures[pointerEvent.pointerId] = false;
          }
          return;
        }
        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
          if (utilityScenePick && utilityScenePick.hit) {
            if (!prePointerInfo.skipOnPointerObservable) {
              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
            }
            prePointerInfo.skipOnPointerObservable = true;
          }
        } else {
          const originalScenePick = getNearPickDataForScene(originalScene);
          const pointerEvent2 = prePointerInfo.event;
          if (originalScenePick && utilityScenePick) {
            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                this._pointerCaptures[pointerEvent2.pointerId] = true;
              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                  this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                  delete this._lastPointerEvents[pointerEvent2.pointerId];
                }
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              if (!prePointerInfo.skipOnPointerObservable) {
                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
              }
            } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                prePointerInfo.skipOnPointerObservable = true;
              } else {
                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                  if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                    this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                    delete this._lastPointerEvents[pointerEvent2.pointerId];
                  }
                }
                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
              }
            }
            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
              this._pointerCaptures[pointerEvent2.pointerId] = false;
            }
          }
        }
      });
      if (this._originalPointerObserver) {
        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
      }
    }
    this.utilityLayerScene.autoClear = false;
    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
      if (this.shouldRender && camera == this.getRenderCamera()) {
        this.render();
      }
    });
    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
      this.dispose();
    });
    this._updateCamera();
  }
  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
    if (!prePointerInfo.skipOnPointerObservable) {
      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
      this._lastPointerEvents[pointerEvent.pointerId] = true;
    }
  }
  /**
   * Renders the utility layers scene on top of the original scene
   */
  render() {
    this._updateCamera();
    if (this.utilityLayerScene.activeCamera) {
      const oldScene = this.utilityLayerScene.activeCamera.getScene();
      const camera = this.utilityLayerScene.activeCamera;
      camera._scene = this.utilityLayerScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = this.utilityLayerScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = this.utilityLayerScene;
      }
      this.utilityLayerScene.render(false);
      camera._scene = oldScene;
      if (camera.leftCamera) {
        camera.leftCamera._scene = oldScene;
      }
      if (camera.rightCamera) {
        camera.rightCamera._scene = oldScene;
      }
    }
  }
  /**
   * Disposes of the renderer
   */
  dispose() {
    this.onPointerOutObservable.clear();
    if (this._afterRenderObserver) {
      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
    }
    if (this._sceneDisposeObserver) {
      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
    if (this._originalPointerObserver) {
      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
    }
    this.utilityLayerScene.dispose();
  }
  _updateCamera() {
    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
    this.utilityLayerScene.activeCamera = this.getRenderCamera();
  }
};
UtilityLayerRenderer._DefaultUtilityLayer = null;
UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var GizmoAnchorPoint;
(function(GizmoAnchorPoint2) {
  GizmoAnchorPoint2[GizmoAnchorPoint2["Origin"] = 0] = "Origin";
  GizmoAnchorPoint2[GizmoAnchorPoint2["Pivot"] = 1] = "Pivot";
})(GizmoAnchorPoint || (GizmoAnchorPoint = {}));
var GizmoCoordinatesMode;
(function(GizmoCoordinatesMode2) {
  GizmoCoordinatesMode2[GizmoCoordinatesMode2["World"] = 0] = "World";
  GizmoCoordinatesMode2[GizmoCoordinatesMode2["Local"] = 1] = "Local";
})(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));
var Gizmo = class _Gizmo {
  /**
   * Ratio for the scale of the gizmo (Default: 1)
   */
  set scaleRatio(value) {
    this._scaleRatio = value;
  }
  get scaleRatio() {
    return this._scaleRatio;
  }
  /**
   * True when the mouse pointer is hovered a gizmo mesh
   */
  get isHovered() {
    return this._isHovered;
  }
  /**
   * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
   * * When set, interactions will be enabled
   */
  get attachedMesh() {
    return this._attachedMesh;
  }
  set attachedMesh(value) {
    this._attachedMesh = value;
    if (value) {
      this._attachedNode = value;
    }
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  /**
   * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
   * * When set, interactions will be enabled
   */
  get attachedNode() {
    return this._attachedNode;
  }
  set attachedNode(value) {
    this._attachedNode = value;
    this._attachedMesh = null;
    this._rootMesh.setEnabled(value ? true : false);
    this._attachedNodeChanged(value);
  }
  /**
   * Disposes and replaces the current meshes in the gizmo with the specified mesh
   * @param mesh The mesh to replace the default mesh of the gizmo
   */
  setCustomMesh(mesh) {
    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
      throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
    }
    this._rootMesh.getChildMeshes().forEach((c) => {
      c.dispose();
    });
    mesh.parent = this._rootMesh;
    this._customMeshSet = true;
  }
  /**
   * Additional transform applied to the gizmo.
   * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.
   * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.
   */
  get additionalTransformNode() {
    return this._additionalTransformNode;
  }
  set additionalTransformNode(value) {
    this._additionalTransformNode = value;
  }
  /**
   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
   */
  set updateGizmoRotationToMatchAttachedMesh(value) {
    this._updateGizmoRotationToMatchAttachedMesh = value;
  }
  get updateGizmoRotationToMatchAttachedMesh() {
    return this._updateGizmoRotationToMatchAttachedMesh;
  }
  /**
   * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
   */
  set updateGizmoPositionToMatchAttachedMesh(value) {
    this._updateGizmoPositionToMatchAttachedMesh = value;
  }
  get updateGizmoPositionToMatchAttachedMesh() {
    return this._updateGizmoPositionToMatchAttachedMesh;
  }
  /**
   * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.
   * (Default: GizmoAnchorPoint.Origin)
   */
  set anchorPoint(value) {
    this._anchorPoint = value;
  }
  get anchorPoint() {
    return this._anchorPoint;
  }
  /**
   * Set the coordinate system to use. By default it's local.
   * But it's possible for a user to tweak so its local for translation and world for rotation.
   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
   */
  set coordinatesMode(coordinatesMode) {
    this._coordinatesMode = coordinatesMode;
    const local = coordinatesMode == GizmoCoordinatesMode.Local;
    this.updateGizmoRotationToMatchAttachedMesh = local;
    this.updateGizmoPositionToMatchAttachedMesh = true;
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  /**
   * When set, the gizmo will always appear the same size no matter where the camera is (default: true)
   */
  set updateScale(value) {
    this._updateScale = value;
  }
  get updateScale() {
    return this._updateScale;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _attachedNodeChanged(value) {
  }
  /**
   * Creates a gizmo
   * @param gizmoLayer The utility layer the gizmo will be added to
   */
  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
    this.gizmoLayer = gizmoLayer;
    this._attachedMesh = null;
    this._attachedNode = null;
    this._customRotationQuaternion = null;
    this._scaleRatio = 1;
    this._isHovered = false;
    this._customMeshSet = false;
    this._updateGizmoRotationToMatchAttachedMesh = true;
    this._updateGizmoPositionToMatchAttachedMesh = true;
    this._anchorPoint = GizmoAnchorPoint.Origin;
    this._updateScale = true;
    this._coordinatesMode = GizmoCoordinatesMode.Local;
    this._interactionsEnabled = true;
    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
    this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
    this._rootMesh.rotationQuaternion = Quaternion.Identity();
    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {
      this._update();
    });
  }
  /**
   * posture that the gizmo will be display
   * When set null, default value will be used (Quaternion(0, 0, 0, 1))
   */
  get customRotationQuaternion() {
    return this._customRotationQuaternion;
  }
  set customRotationQuaternion(customRotationQuaternion) {
    this._customRotationQuaternion = customRotationQuaternion;
  }
  /**
   * Updates the gizmo to match the attached mesh's position/rotation
   */
  _update() {
    if (this.attachedNode) {
      let effectiveNode = this.attachedNode;
      if (this.attachedMesh) {
        effectiveNode = this.attachedMesh || this.attachedNode;
      }
      if (this.updateGizmoPositionToMatchAttachedMesh) {
        if (this.anchorPoint == GizmoAnchorPoint.Pivot && effectiveNode.getAbsolutePivotPoint) {
          const position = effectiveNode.getAbsolutePivotPoint();
          this._rootMesh.position.copyFrom(position);
        } else {
          const row = effectiveNode.getWorldMatrix().getRow(3);
          const position = row ? row.toVector3() : new Vector3(0, 0, 0);
          this._rootMesh.position.copyFrom(position);
        }
      }
      if (this.updateGizmoRotationToMatchAttachedMesh) {
        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === "AbstractMesh" || effectiveNode.getClassName() === "TransformNode" || effectiveNode.getClassName() === "InstancedMesh";
        const transformNode = supportedNode ? effectiveNode : void 0;
        effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion, void 0, _Gizmo.PreserveScaling ? transformNode : void 0);
        this._rootMesh.rotationQuaternion.normalize();
      } else {
        if (this._customRotationQuaternion) {
          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);
        } else {
          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
        }
      }
      if (this.updateScale) {
        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
        const cameraPosition = activeCamera.globalPosition;
        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);
        let scale = this.scaleRatio;
        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
          if (activeCamera.orthoTop && activeCamera.orthoBottom) {
            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;
            scale *= orthoHeight;
          }
        } else {
          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;
          const direction = activeCamera.getDirection(camForward);
          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);
        }
        this._rootMesh.scaling.setAll(scale);
        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !_Gizmo.PreserveScaling) {
          this._rootMesh.scaling.y *= -1;
        }
      } else {
        this._rootMesh.scaling.setAll(this.scaleRatio);
      }
    }
    if (this.additionalTransformNode) {
      this._rootMesh.computeWorldMatrix(true);
      this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);
      TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion, this._rootMesh.position);
    }
  }
  /**
   * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)
   * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.
   * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.
   * @param transform local transform that needs to be transform by the pivot inverse matrix
   * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix
   * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix
   */
  _handlePivotMatrixInverse(transform, localMatrix, result) {
    if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {
      transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);
      TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);
      return;
    }
    result.copyFrom(localMatrix);
  }
  /**
   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.
   */
  _matrixChanged() {
    if (!this._attachedNode) {
      return;
    }
    if (this._attachedNode._isCamera) {
      const camera = this._attachedNode;
      let worldMatrix;
      let worldMatrixUC;
      if (camera.parent) {
        const parentInv = TmpVectors.Matrix[1];
        camera.parent._worldMatrix.invertToRef(parentInv);
        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);
        worldMatrix = TmpVectors.Matrix[0];
      } else {
        worldMatrix = this._attachedNode._worldMatrix;
      }
      if (camera.getScene().useRightHandedSystem) {
        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);
        worldMatrixUC = TmpVectors.Matrix[1];
      } else {
        worldMatrixUC = worldMatrix;
      }
      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
      const inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
      if (inheritsTargetCamera) {
        const targetCamera = this._attachedNode;
        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        if (targetCamera.rotationQuaternion) {
          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          targetCamera.rotationQuaternion.normalize();
        }
      }
      camera.position.copyFrom(TmpVectors.Vector3[0]);
    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
      const transform = this._attachedNode;
      if (transform.parent) {
        const parentInv = TmpVectors.Matrix[0];
        const localMat = TmpVectors.Matrix[1];
        transform.parent.getWorldMatrix().invertToRef(parentInv);
        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
        const matrixToDecompose = TmpVectors.Matrix[4];
        this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);
        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
        TmpVectors.Quaternion[0].normalize();
        if (transform.isUsingPivotMatrix()) {
          const r = TmpVectors.Quaternion[1];
          Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);
          const scaleMatrix = TmpVectors.Matrix[2];
          Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);
          const rotationMatrix = TmpVectors.Matrix[2];
          r.toRotationMatrix(rotationMatrix);
          const pivotMatrix = transform.getPivotMatrix();
          const invPivotMatrix = TmpVectors.Matrix[3];
          pivotMatrix.invertToRef(invPivotMatrix);
          pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);
          TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);
          transform.position.subtractInPlace(TmpVectors.Vector3[1]);
        }
      } else {
        const matrixToDecompose = TmpVectors.Matrix[4];
        this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);
        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
      }
      TmpVectors.Vector3[0].scaleInPlace(1 / transform.scalingDeterminant);
      transform.scaling.copyFrom(TmpVectors.Vector3[0]);
      if (!transform.billboardMode) {
        if (transform.rotationQuaternion) {
          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
          transform.rotationQuaternion.normalize();
        } else {
          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();
        }
      }
    } else if (this._attachedNode.getClassName() === "Bone") {
      const bone = this._attachedNode;
      const parent = bone.getParent();
      if (parent) {
        const invParent = TmpVectors.Matrix[0];
        const boneLocalMatrix = TmpVectors.Matrix[1];
        parent.getFinalMatrix().invertToRef(invParent);
        bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(boneLocalMatrix);
      } else {
        const lmat = bone.getLocalMatrix();
        lmat.copyFrom(bone.getFinalMatrix());
      }
      bone.markAsDirty();
    } else {
      const light = this._attachedNode;
      if (light.getTypeID) {
        const type = light.getTypeID();
        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {
          const parent = light.parent;
          if (parent) {
            const invParent = TmpVectors.Matrix[0];
            const nodeLocalMatrix = TmpVectors.Matrix[1];
            parent.getWorldMatrix().invertToRef(invParent);
            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);
            nodeLocalMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          } else {
            this._attachedNode._worldMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          }
          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
          if (light.direction) {
            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);
          }
        }
      }
    }
  }
  /**
   * refresh gizmo mesh material
   * @param gizmoMeshes
   * @param material material to apply
   */
  _setGizmoMeshMaterial(gizmoMeshes, material) {
    if (gizmoMeshes) {
      gizmoMeshes.forEach((m) => {
        m.material = material;
        if (m.color) {
          m.color = material.diffuseColor;
        }
      });
    }
  }
  /**
   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.
   * @param gizmoLayer The utility layer the gizmo will be added to
   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
   * @returns {Observer<PointerInfo>} pointerObserver
   */
  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {
    let dragging = false;
    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
      var _a, _b;
      if (pointerInfo.pickInfo) {
        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
          if (dragging) {
            return;
          }
          gizmoAxisCache.forEach((cache) => {
            var _a2, _b2;
            if (cache.colliderMeshes && cache.gizmoMeshes) {
              const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            }
          });
        }
        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _a.parent)) {
            dragging = true;
            const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _b.parent);
            statusMap.active = true;
            gizmoAxisCache.forEach((cache) => {
              var _a2, _b2;
              const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;
              cache.gizmoMeshes.forEach((m) => {
                m.material = material;
                if (m.color) {
                  m.color = material.diffuseColor;
                }
              });
            });
          }
        }
        if (pointerInfo.type === PointerEventTypes.POINTERUP) {
          gizmoAxisCache.forEach((cache) => {
            cache.active = false;
            dragging = false;
            cache.gizmoMeshes.forEach((m) => {
              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;
              if (m.color) {
                m.color = cache.material.diffuseColor;
              }
            });
          });
        }
      }
    });
    return pointerObserver;
  }
  /**
   * Disposes of the gizmo
   */
  dispose() {
    this._rootMesh.dispose();
    if (this._beforeRenderObserver) {
      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
    }
  }
};
Gizmo.PreserveScaling = false;
Gizmo.UseAbsoluteScaling = true;

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateSegmentedBoxVertexData(options) {
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const widthSegments = (options.widthSegments || options.segments || 1) | 0;
  const heightSegments = (options.heightSegments || options.segments || 1) | 0;
  const depthSegments = (options.depthSegments || options.segments || 1) | 0;
  const rotationMatrix = new Matrix();
  const translationMatrix = new Matrix();
  const transformMatrix = new Matrix();
  const bottomPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  bottomPlane.transform(transformMatrix);
  const topPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);
  topPlane.transform(transformMatrix);
  const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negXPlane.transform(transformMatrix);
  const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posXPlane.transform(transformMatrix);
  const negZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);
  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negZPlane.transform(transformMatrix);
  const posZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);
  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posZPlane.transform(transformMatrix);
  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);
  return bottomPlane;
}
function CreateBox(name4, options = {}, scene = null) {
  const box = new Mesh(name4, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var BoxBuilder = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CreateBox
};
VertexData.CreateBox = CreateBoxVertexData;
Mesh.CreateBox = (name4, size, scene = null, updatable, sideOrientation) => {
  const options = {
    size,
    sideOrientation,
    updatable
  };
  return CreateBox(name4, options, scene);
};

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes = class {
};
ClipboardEventTypes.COPY = 1;
ClipboardEventTypes.CUT = 2;
ClipboardEventTypes.PASTE = 3;
var ClipboardInfo = class {
  /**
   *Creates an instance of ClipboardInfo.
   * @param type Defines the type of event (BABYLON.ClipboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
  /**
   *  Get the clipboard event's type from the keycode.
   * @param keyCode Defines the keyCode for the current keyboard event.
   * @returns {number}
   */
  static GetTypeFromCharacter(keyCode) {
    const charCode = keyCode;
    switch (charCode) {
      case 67:
        return ClipboardEventTypes.COPY;
      case 86:
        return ClipboardEventTypes.PASTE;
      case 88:
        return ClipboardEventTypes.CUT;
      default:
        return -1;
    }
  }
};

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_LAYER;
    this.scene = scene || EngineStore.LastCreatedScene;
    if (!this.scene) {
      return;
    }
    this._engine = this.scene.getEngine();
    this.scene.layers = [];
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);
    this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);
    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);
    this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
    const layers = this.scene.layers;
    for (const layer of layers) {
      layer._rebuild();
    }
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
    const layers = this.scene.layers;
    while (layers.length) {
      layers[0].dispose();
    }
  }
  _draw(predicate) {
    const layers = this.scene.layers;
    if (layers.length) {
      this._engine.setDepthBuffer(false);
      for (const layer of layers) {
        if (predicate(layer)) {
          layer.render();
        }
      }
      this._engine.setDepthBuffer(true);
    }
  }
  _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {
    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawCameraBackground(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, true, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, true, camera.layerMask);
    });
  }
  _drawCameraForegroundWithoutPostProcessing(camera) {
    this._draw((layer) => {
      return this._drawCameraPredicate(layer, false, false, camera.layerMask);
    });
  }
  _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {
    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
  }
  _drawRenderTargetBackground(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {
    this._draw((layer) => {
      return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);
    });
  }
  /**
   * Adds all the elements from the container to the scene
   * @param container the container holding the elements
   */
  addFromContainer(container) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      this.scene.layers.push(layer);
    });
  }
  /**
   * Removes all the elements in the container from the scene
   * @param container contains the elements to remove
   * @param dispose if the removed element should be disposed (default: false)
   */
  removeFromContainer(container, dispose = false) {
    if (!container.layers) {
      return;
    }
    container.layers.forEach((layer) => {
      const index = this.scene.layers.indexOf(layer);
      if (index !== -1) {
        this.scene.layers.splice(index, 1);
      }
      if (dispose) {
        layer.dispose();
      }
    });
  }
};

// node_modules/@babylonjs/core/Shaders/layer.fragment.js
var name2 = "layerPixelShader";
var shader2 = `varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/layer.vertex.js
var name3 = "layerVertexShader";
var shader3 = `attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Layers/layer.js
var Layer = class {
  /**
   * Determines if the layer is drawn before (true) or after (false) post-processing.
   * If the layer is background, it is always before.
   */
  set applyPostProcess(value) {
    this._applyPostProcess = value;
  }
  get applyPostProcess() {
    return this.isBackground || this._applyPostProcess;
  }
  /**
   * Back compatibility with callback before the onDisposeObservable existed.
   * The set callback will be triggered when the layer has been disposed.
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * Back compatibility with callback before the onBeforeRenderObservable existed.
   * The set callback will be triggered just before rendering the layer.
   */
  set onBeforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
  }
  /**
   * Back compatibility with callback before the onAfterRenderObservable existed.
   * The set callback will be triggered just after rendering the layer.
   */
  set onAfterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
  }
  /**
   * Instantiates a new layer.
   * This represents a full screen 2d layer.
   * This can be useful to display a picture in the  background of your scene for instance.
   * @see https://www.babylonjs-playground.com/#08A2BS#1
   * @param name Define the name of the layer in the scene
   * @param imgUrl Define the url of the texture to display in the layer
   * @param scene Define the scene the layer belongs to
   * @param isBackground Defines whether the layer is displayed in front or behind the scene
   * @param color Defines a color for the layer
   */
  constructor(name4, imgUrl, scene, isBackground, color) {
    this.name = name4;
    this._applyPostProcess = true;
    this.scale = new Vector2(1, 1);
    this.offset = new Vector2(0, 0);
    this.alphaBlendingMode = 2;
    this.layerMask = 268435455;
    this.renderTargetTextures = [];
    this.renderOnlyInRenderTargetTextures = false;
    this.isEnabled = true;
    this._vertexBuffers = {};
    this.onDisposeObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
    this.isBackground = isBackground === void 0 ? true : isBackground;
    this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
    this._scene = scene || EngineStore.LastCreatedScene;
    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
    if (!layerComponent) {
      layerComponent = new LayerSceneComponent(this._scene);
      this._scene._addComponent(layerComponent);
    }
    this._scene.layers.push(this);
    const engine = this._scene.getEngine();
    this._drawWrapper = new DrawWrapper(engine);
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
    this._createIndexBuffer();
  }
  _createIndexBuffer() {
    const engine = this._scene.getEngine();
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
  }
  /**
   * Checks if the layer is ready to be rendered
   * @returns true if the layer is ready. False otherwise.
   */
  isReady() {
    var _a;
    const engine = this._scene.getEngine();
    let defines = "";
    if (this.alphaTest) {
      defines = "#define ALPHATEST";
    }
    if (this.texture && !this.texture.gammaSpace) {
      defines += "\n#define LINEAR";
    }
    if (this._previousDefines !== defines) {
      this._previousDefines = defines;
      this._drawWrapper.effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines);
    }
    const currentEffect = this._drawWrapper.effect;
    return (currentEffect == null ? void 0 : currentEffect.isReady()) && ((_a = this.texture) == null ? void 0 : _a.isReady());
  }
  /**
   * Renders the layer in the scene.
   */
  render() {
    if (!this.isEnabled) {
      return;
    }
    const engine = this._scene.getEngine();
    if (!this.isReady()) {
      return;
    }
    const currentEffect = this._drawWrapper.effect;
    this.onBeforeRenderObservable.notifyObservers(this);
    engine.enableEffect(this._drawWrapper);
    engine.setState(false);
    currentEffect.setTexture("textureSampler", this.texture);
    currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
    currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
    currentEffect.setVector2("offset", this.offset);
    currentEffect.setVector2("scale", this.scale);
    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
    if (!this.alphaTest) {
      engine.setAlphaMode(this.alphaBlendingMode);
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
      engine.setAlphaMode(0);
    } else {
      engine.drawElementsType(Material.TriangleFillMode, 0, 6);
    }
    this.onAfterRenderObservable.notifyObservers(this);
  }
  /**
   * Disposes and releases the associated resources.
   */
  dispose() {
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this.texture) {
      this.texture.dispose();
      this.texture = null;
    }
    this.renderTargetTextures = [];
    const index = this._scene.layers.indexOf(this);
    this._scene.layers.splice(index, 1);
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderObservable.clear();
  }
};

export {
  FadeInOutBehavior,
  Ray,
  PivotTools,
  CreatePlaneVertexData,
  CreatePlane,
  PlaneBuilder,
  PointerDragBehavior,
  BaseSixDofDragBehavior,
  SixDofDragBehavior,
  SurfaceMagnetismBehavior,
  FollowBehavior,
  WebXRFeatureName,
  WebXRFeaturesManager,
  WebXRAbstractFeature,
  PhysicsJoint,
  DistanceJoint,
  MotorEnabledJoint,
  HingeJoint,
  Hinge2Joint,
  PhysicsImpostor,
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialConnectionPoint,
  NodeMaterialBlock,
  TransformBlock,
  VertexOutputBlock,
  PropertyTypeForEdition,
  editableInPropertyPage,
  FragmentOutputBlock,
  NodeMaterialBlockConnectionPointMode,
  NodeMaterialSystemValues,
  AnimatedInputBlockTypes,
  InputBlock,
  CurrentScreenBlock,
  ParticleTextureBlock,
  ParticleRampGradientBlock,
  ParticleBlendMultiplyBlock,
  VectorMergerBlock,
  RemapBlock,
  MultiplyBlock,
  NodeMaterialModes,
  BaseParticleSystem,
  ColorSplitterBlock,
  ProceduralTextureSceneComponent,
  ProceduralTexture,
  TrigonometryBlockOperations,
  TrigonometryBlock,
  NodeMaterialDefines,
  NodeMaterial,
  CreateIcoSphereVertexData,
  CreateIcoSphere,
  IcoSphereBuilder,
  HandPart,
  WebXRHandJoint,
  WebXRHand,
  WebXRHandTracking,
  HandConstraintZone,
  HandConstraintOrientation,
  HandConstraintVisibility,
  HandConstraintBehavior,
  UtilityLayerRenderer,
  GizmoAnchorPoint,
  GizmoCoordinatesMode,
  Gizmo,
  CreateBoxVertexData,
  CreateSegmentedBoxVertexData,
  CreateBox,
  BoxBuilder,
  ClipboardEventTypes,
  ClipboardInfo,
  LayerSceneComponent,
  Layer
};
//# sourceMappingURL=chunk-LPB4FTRL.js.map
